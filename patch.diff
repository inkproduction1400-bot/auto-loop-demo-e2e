// E017: URLパスによるテナント識別
+  test('should identify tenant from URL path correctly', async ({ page }) => {
+    // 基本テナント
+    await page.goto('/tenant/test-tenant-basic/booking');
+    await expect(page.locator('[data-test="tenant-test-tenant-basic"]')).toBeVisible();
+    await expect(page.locator('[data-test="tenant-name"]')).toHaveText('基本テスト店舗');
+    
+    // カスタムテナント
+    await page.goto('/tenant/test-tenant-custom/booking');
+    await expect(page.locator('[data-test="tenant-test-tenant-custom"]')).toBeVisible();
+    await expect(page.locator('[data-test="tenant-name"]')).toHaveText('カスタムテスト店舗');
+    
+    // 存在しないテナント
+    await page.goto('/tenant/non-existent/booking');
+    await expect(page.locator('[data-test="tenant-not-found"]')).toBeVisible();
+    await expect(page.locator('[data-test="tenant-not-found"]')).toHaveText('テナントが見つかりません');
+  });
+
+  // E018: テナント別ロゴ・色の表示
+  test('should display tenant-specific branding', async ({ page }) => {
+    await page.goto('/tenant/test-tenant-custom/booking');
+    
+    // カスタムテナントのブランド要素確認
+    await expect(page.locator('[data-test="tenant-logo"]')).toBeVisible();
+    await expect(page.locator('[data-test="tenant-logo"]')).toHaveAttribute('alt', 'カスタムテスト店舗');
+    
+    // カスタムカラーテーマ適用確認
+    const primaryColor = await page.locator('[data-test="primary-color"]').getAttribute('style');
+    expect(primaryColor).toContain('--primary-color');
+    
+    // ロゴアップロード機能（管理者用）
+    await page.goto('/tenant/test-tenant-custom/admin');
+    await page.fill('[data-test="admin-email"]', 'admin@test.com');
+    await page.fill('[data-test="admin-password"]', 'admin123');
+    await page.click('[data-test="admin-login"]');
+    
+    await page.click('[data-test="brand-settings"]');
+    await expect(page.locator('[data-test="logo-upload"]')).toBeVisible();
+    await expect(page.locator('[data-test="color-picker"]')).toBeVisible();
+    await expect(page.locator('[data-test="site-name"]')).toHaveValue('カスタムテスト店舗');
+  });
+
+  // E019: テナント別料金表の適用
+  test('should apply tenant-specific pricing', async ({ page }) => {
+    // 基本テナント（大人3000円）
+    await page.goto('/tenant/test-tenant-basic/booking');
+    await page.click('[data-test="date-2025-01-08"]');
+    await page.click('[data-test="slot-14:00-14:30"]');
+    await page.fill('[data-test="count-adult"]', '1');
+    
+    await expect(page.locator('[data-test="price-subtotal"]')).toHaveText('¥3,000');
+    await expect(page.locator('[data-test="price-tax"]')).toHaveText('¥300'); // 10%
+    await expect(page.locator('[data-test="price-total"]')).toHaveText('¥3,300');
+    
+    // カスタムテナント（大人5000円、税率8%）
+    await page.goto('/tenant/test-tenant-custom/booking');
+    await page.click('[data-test="date-2025-01-08"]');
+    await page.click('[data-test="slot-10:00-10:30"]');
+    await page.fill('[data-test="count-adult"]', '1');
+    
+    await expect(page.locator('[data-test="price-subtotal"]')).toHaveText('¥5,000');
+    await expect(page.locator('[data-test="price-tax"]')).toHaveText('¥400'); // 8%
+    await expect(page.locator('[data-test="price-total"]')).toHaveText('¥5,400');
+  });
+
+  // E020: data-tenant属性でのテナント識別
+  test('should identify tenant from widget data-tenant attribute', async ({ page }) => {
+    // ウィジェット埋め込みページをシミュレート
+    await page.goto('/widget-test.html');
+    
+    // ウィジェットスクリプトを動的に挿入
+    await page.evaluate(() => {
+      const script = document.createElement('script');
+      script.src = '/widget.js';
+      script.setAttribute('data-tenant', 'test-tenant-basic');
+      script.setAttribute('data-theme', 'light');
+      script.setAttribute('data-test', 'widget-script');
+      document.head.appendChild(script);
+    });
+    
+    // ウィジェットの読み込み完了を待機
+    await page.waitForSelector('[data-test="widget-container"]');
+    
+    // テナント識別確認
+    await expect(page.locator('[data-test="widget-tenant-id"]')).toHaveText('test-tenant-basic');
+    await expect(page.locator('[data-test="widget-tenant-name"]')).toHaveText('基本テスト店舗');
+    
+    // ウィジェット内での予約フロー
+    await page.click('[data-test="widget-date-2025-01-08"]');
+    await page.click('[data-test="widget-slot-14:00-14:30"]');
+    
+    // テナント固有の料金表示
+    await page.fill('[data-test="widget-count-adult"]', '1');
+    await expect(page.locator('[data-test="widget-price-total"]')).toHaveText('¥3,300');
+  });
+
+  // E034: 複数経路テナントID競合時の解決確認（v1.1追加）
+  test('should resolve tenant ID conflicts by priority', async ({ page }) => {
+    // APIヘッダーとURLパスで異なるテナントIDを指定
+    await page.setExtraHTTPHeaders({
+      'X-Tenant-Id': 'header-tenant-priority'
+    });
+    
+    await page.goto('/tenant/url-tenant-priority/booking');
+    
+    // ヘッダーが優先されることを確認
+    await expect(page.locator('[data-test="resolved-tenant-id"]')).toHaveText('header-tenant-priority');
+    
+    // 競合検出の表示
+    await expect(page.locator('[data-test="tenant-conflict-warning"]')).toBeVisible();
+    await expect(page.locator('[data-test="tenant-conflict-warning"]')).toContainText('複数のテナントIDが検出されました');
+    
+    // 解決ログの確認
+    await expect(page.locator('[data-test="conflict-resolution-log"]')).toContainText('ヘッダー優先で解決');
+  });
+
+  // 管理者でのテナント切り替え
+  test('should handle admin tenant switching', async ({ page }) => {
+    // 管理者ログイン
+    await page.goto('/admin/login');
+    await page.fill('[data-test="admin-email"]', 'admin@test.com');
+    await page.fill('[data-test="admin-password"]', 'admin123');
+    await page.click('[data-test="admin-login"]');
+    
+    // テナント選択
+    await page.click('[data-test="tenant-selector"]');
+    await page.click('[data-test="tenant-option-test-tenant-basic"]');
+    
+    // 基本テナントの管理画面
+    await expect(page.locator('[data-test="current-tenant"]')).toHaveText('基本テスト店舗');
+    await expect(page.locator('[data-test="pricing-config"]')).toContainText('大人: ¥3,000');
+    
+    // テナント切り替え
+    await page.click('[data-test="tenant-selector"]');
+    await page.click('[data-test="tenant-option-test-tenant-custom"]');
+    
+    // カスタムテナントの管理画面
+    await expect(page.locator('[data-test="current-tenant"]')).toHaveText('カスタムテスト店舗');
+    await expect(page.locator('[data-test="pricing-config"]')).toContainText('大人: ¥5,000');
+  });
+
+  // ウィジェット埋め込みテーマ対応
+  test('should support widget theme customization', async ({ page }) => {
+    await page.goto('/widget-test.html');
+    
+    // ダークテーマウィジェット
+    await page.evaluate(() => {
+      const script = document.createElement('script');
+      script.src = '/widget.js';
+      script.setAttribute('data-tenant', 'test-tenant-basic');
+      script.setAttribute('data-theme', 'dark');
+      document.head.appendChild(script);
+    });
+    
+    await page.waitForSelector('[data-test="widget-container"]');
+    
+    // ダークテーマの適用確認
+    await expect(page.locator('[data-test="widget-container"]')).toHaveClass(/theme-dark/);
+    
+    const backgroundColor = await page.locator('[data-test="widget-container"]').evaluate(
+      el => getComputedStyle(el).backgroundColor
+    );
+    expect(backgroundColor).toContain('rgb('); // ダーク色の確認
+  });
+});
--- /dev/null
+++ tests/e2e/admin-management.spec.ts
@@ -0,0 +1,167 @@
+import { test, expect } from '@playwright/test';
+
+test.describe('Admin Management', () => {
+  test.beforeEach(async ({ page }) => {
+    await page.goto('/test/reset-data');
+    
+    // 管理者ログイン
+    await page.goto('/admin/login');
+    await page.fill('[data-test="admin-email"]', 'admin@test.com');
+    await page.fill('[data-test="admin-password"]', 'admin123');
+    await page.click('[data-test="admin-login"]');
+    
+    // テナント選択
+    await page.click('[data-test="tenant-selector"]');
+    await page.click('[data-test="tenant-option-test-tenant-basic"]');
+  });
+
+  // E021: JWT認証による管理画面アクセス
+  test('should authenticate admin with JWT token', async ({ page }) => {
+    // ログイン成功確認
+    await expect(page.locator('[data-test="auth-token"]')).toBeVisible();
+    await expect(page.locator('[data-test="admin-dashboard"]')).toBeVisible();
+    
+    // JWTトークンの存在確認
+    const token = await page.evaluate(() => localStorage.getItem('admin_jwt_token'));
+    expect(token).toBeTruthy();
+    
+    // 認証が必要な機能へのアクセス
+    await page.click('[data-test="admin-settings"]');
+    await expect(page.locator('[data-test="settings-panel"]')).toBeVisible();
+  });
+
+  // E022: 予約一覧表示・フィルタ
+  test('should display and filter booking list', async ({ page }) => {
+    await page.click('[data-test="booking-list"]');
+    
+    // 予約一覧の表示確認
+    await expect(page.locator('[data-test="booking-table"]')).toBeVisible();
+    await expect(page.locator('[data-test="booking-row"]')).toHaveCount(3); // テストデータ3件
+    
+    // 日付フィルタ
+    await page.fill('[data-test="filter-date"]', '2025-01-08');
+    await page.click('[data-test="apply-filter"]');
+    
+    await expect(page.locator('[data-test="booking-row"]')).toHaveCount(2); // 1/8のデータのみ
+    
+    // ステータスフィルタ
+    await page.click('[data-test="filter-status"]');
+    await page.click('[data-test="status-paid"]');
+    await page.click('[data-test="apply-filter"]');
+    
+    await expect(page.locator('[data-test="booking-row"]')).toHaveCount(1); // paidのみ
+    
+    // フィルタクリア
+    await page.click('[data-test="clear-filter"]');
+    await expect(page.locator('[data-test="booking-row"]')).toHaveCount(3); // 全件表示
+  });
+
+  // E023: 定員・公開状態の変更と即時反映
+  test('should update slot capacity and visibility immediately', async ({ page }) => {
+    await page.click('[data-test="inventory-chart"]');
+    
+    // 在庫設定画面
+    await expect(page.locator('[data-test="inventory-settings"]')).toBeVisible();
+    
+    // 特定の時間枠を選択
+    await page.click('[data-test="slot-2025-01-08-14:00-14:30"]');
+    
+    // 定員変更
+    await page.fill('[data-test="capacity-input"]', '25');
+    await page.click('[data-test="save-capacity"]');
+    
+    // 変更の即時反映確認
+    await expect(page.locator('[data-test="capacity-display"]')).toHaveText('25');
+    await expect(page.locator('[data-test="available-display"]')).toHaveText('20'); // 25-5(既存予約)
+    
+    // 公開状態の変更
+    await page.click('[data-test="slot-visibility"]');
+    await page.click('[data-test="set-private"]');
+    
+    // 非公開状態の確認
+    await expect(page.locator('[data-test="slot-status"]')).toHaveText('非公開');
+    
+    // フロントエンドでの非表示確認
+    await page.goto('/tenant/test-tenant-basic/booking');
+    await page.click('[data-test="date-2025-01-08"]');
+    
+    // 非公開にした枠が表示されないことを確認
+    await expect(page.locator('[data-test="slot-14:00-14:30"]')).not.toBeVisible();
+  });
+
+  // E024: 区分別料金の変更と見積への反映
+  test('should update pricing and reflect in estimates', async ({ page }) => {
+    await page.click('[data-test="admin-settings"]');
+    await page.click('[data-test="pricing-config"]');
+    
+    // 料金変更
+    await page.fill('[data-test="price-adult"]', '4000');
+    await page.fill('[data-test="price-child"]', '1500');
+    await page.click('[data-test="save-pricing"]');
+    
+    // 変更確認ダイアログ
+    await expect(page.locator('[data-test="pricing-change-confirmation"]')).toBeVisible();
+    await page.click('[data-test="confirm-pricing-change"]');
+    
+    // 成功メッセージ
+    await expect(page.locator('[data-test="pricing-updated"]')).toBeVisible();
+    
+    // フロントエンドでの料金反映確認
+    await page.goto('/tenant/test-tenant-basic/booking');
+    await page.click('[data-test="date-2025-01-08"]');
+    await page.click('[data-test="slot-14:00-14:30"]');
+    await page.fill('[data-test="count-adult"]', '1');
+    await page.fill('[data-test="count-child"]', '1');
+    
+    // 新料金での計算確認
+    // 大人: 4,000円, 小学生: 1,500円, 合計: 5,500円, 税: 550円, 総計: 6,050円
+    await expect(page.locator('[data-test="price-subtotal"]')).toHaveText('¥5,500');
+    await expect(page.locator('[data-test="price-tax"]')).toHaveText('¥550');
+    await expect(page.locator('[data-test="price-total"]')).toHaveText('¥6,050');
+  });
+
+  // E025: ロゴ・色・サイト名の変更と表示確認
+  test('should update brand settings and display changes', async ({ page }) => {
+    await page.click('[data-test="admin-settings"]');
+    await page.click('[data-test="brand-settings"]');
+    
+    // サイト名変更
+    await page.fill('[data-test="site-name"]', '新しい店舗名');
+    
+    // カラーテーマ変更
+    await page.click('[data-test="color-picker"]');
+    await page.fill('[data-test="color-input"]', '#ff6b35');
+    
+    // 利用規約URL変更
+    await page.fill('[data-test="terms-url"]', 'https://example.com/new-terms');
+    
+    // 変更保存
+    await page.click('[data-test="save-brand-settings"]');
+    
+    // 保存成功確認
+    await expect(page.locator('[data-test="brand-settings-saved"]')).toBeVisible();
+    
+    // プレビュー機能
+    await page.click('[data-test="preview-changes"]');
+    
+    // 新しいタブで予約ページを開いて確認
+    const [newPage] = await Promise.all([
+      page.context().waitForEvent('page'),
+      page.click('[data-test="open-preview"]')
+    ]);
+    
+    await newPage.waitForLoadState();
+    
+    // 変更されたブランド要素の確認
+    await expect(newPage.locator('[data-test="tenant-name"]')).toHaveText('新しい店舗名');
+    
+    const primaryColor = await newPage.locator('[data-test="primary-color"]').evaluate(
+      el => getComputedStyle(el).getPropertyValue('--primary-color')
+    );
+    expect(primaryColor).toBe('#ff6b35');
+    
+    // 利用規約リンクの確認
+    await expect(newPage.locator('[data-test="terms-link"]')).toHaveAttribute(
+      'href', 
+      'https://example.com/new-terms'
+    );
+    
+    await newPage.close();
+  });
+
+  // E035: トークン期限切れ時の自動ログアウト（v1.1追加）
+  test('should handle JWT token expiry correctly', async ({ page }) => {
+    // 正常な管理画面アクセス
+    await expect(page.locator('[data-test="admin-dashboard"]')).toBeVisible();
+    
+    // トークン期限切れをシミュレート
+    await page.evaluate(() => {
+      // 期限切れトークンに差し替え
+      localStorage.setItem('admin_jwt_token', 'eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.expired.token');
+    });
+    
+    // 認証が必要な操作を試行
+    await page.click('[data-test="admin-settings"]');
+    
+    // 自動ログアウト確認
+    await expect(page.locator('[data-test="auth-token-expiry"]')).toBeVisible();
+    await expect(page.locator('[data-test="auth-token-expiry"]')).toHaveText('セッションが期限切れです');
+    
+    // ログイン画面にリダイレクト
+    await expect(page.url()).toContain('/admin/login');
+    await expect(page.locator('[data-test="login-form"]')).toBeVisible();
+    
+    // 再ログイン
+    await page.fill('[data-test="admin-email"]', 'admin@test.com');
+    await page.fill('[data-test="admin-password"]', 'admin123');
+    await page.click('[data-test="admin-login"]');
+    
+    // 管理画面復帰
+    await expect(page.locator('[data-test="admin-dashboard"]')).toBeVisible();
+  });
+});
--- /dev/null
+++ .gitignore
@@ -0,0 +1,25 @@
+# Dependencies
+node_modules/
+
+# Build output
+dist/
+build/
+
+# Environment variables
+.env
+.env.local
+.env.production
+
+# Test results
+coverage/
+test-results/
+playwright-report/
+
+# Logs
+*.log
+logs/
+
+# OS generated files
+.DS_Store
+Thumbs.db
+
+# IDE
+.vscode/
+.idea/
+
+# Temporary files
+*.tmp
+*.temp--- /dev/null
+++ tests/unit/services/booking-service.test.ts
@@ -0,0 +1,187 @@
+import { describe, it, expect, beforeEach, vi } from 'vitest';
+import { BookingService } from '@/services/booking-service';
+import { TestDataManager } from '@tests/setup/test-data-manager';
+
+describe('BookingService', () => {
+  let service: BookingService;
+  const tenantId = 'test-tenant-basic';
+
+  beforeEach(() => {
+    service = new BookingService();
+  });
+
+  describe('createBooking', () => {
+    // U017: 正常な予約作成
+    it('should create booking in draft status', async () => {
+      const bookingData = {
+        tenantId,
+        date: '2025-01-08',
+        timeSlot: '14:00-14:30',
+        guests: { adult: 2, junior: 0, child: 0, infant: 0 },
+        customerInfo: {
+          name: 'テスト太郎',
+          email: 'test@example.com',
+          phone: '090-1234-5678'
+        }
+      };
+
+      const result = await service.createBooking(bookingData);
+
+      expect(result.success).toBe(true);
+      expect(result.booking.status).toBe('draft');
+      expect(result.booking.id).toMatch(/^RES-20250108-\d{4}$/);
+      expect(result.booking.totalAmount).toBe(6600); // 税込
+      expect(result.inventoryLock).toBeDefined();
+    });
+
+    // U018: 在庫不足時のエラー
+    it('should fail when insufficient inventory', async () => {
+      const bookingData = {
+        tenantId,
+        date: '2025-01-08',
+        timeSlot: '14:00-14:30',
+        guests: { adult: 20, junior: 0, child: 0, infant: 0 }, // 15より多い
+        customerInfo: {
+          name: 'テスト太郎',
+          email: 'test@example.com',
+          phone: '090-1234-5678'
+        }
+      };
+
+      const result = await service.createBooking(bookingData);
+
+      expect(result.success).toBe(false);
+      expect(result.error?.code).toBe('fully_booked');
+      expect(result.error?.message).toBe('選択された時間は満席です');
+    });
+
+    // U019: 人数制限超過エラー
+    it('should fail when exceeding guest limit', async () => {
+      const bookingData = {
+        tenantId,
+        date: '2025-01-08',
+        timeSlot: '14:00-14:30',
+        guests: { adult: 21, junior: 0, child: 0, infant: 0 }, // 20名制限超過
+        customerInfo: {
+          name: 'テスト太郎',
+          email: 'test@example.com',
+          phone: '090-1234-5678'
+        }
+      };
+
+      const result = await service.createBooking(bookingData);
+
+      expect(result.success).toBe(false);
+      expect(result.error?.code).toBe('invalid_argument');
+      expect(result.error?.message).toBe('1回の予約は最大20名までです');
+    });
+
+    // U020: 期限切れエラー
+    it('should fail when booking deadline passed', async () => {
+      // 現在時刻を設定（2時間前期限テスト）
+      vi.setSystemTime(new Date('2025-01-08T12:30:00Z')); // 14:00の1.5時間前
+
+      const bookingData = {
+        tenantId,
+        date: '2025-01-08',
+        timeSlot: '14:00-14:30',
+        guests: { adult: 1, junior: 0, child: 0, infant: 0 },
+        customerInfo: {
+          name: 'テスト太郎',
+          email: 'test@example.com',
+          phone: '090-1234-5678'
+        }
+      };
+
+      const result = await service.createBooking(bookingData);
+
+      expect(result.success).toBe(false);
+      expect(result.error?.code).toBe('deadline_passed');
+      expect(result.error?.message).toBe('予約受付期限を過ぎています');
+    });
+  });
+
+  describe('confirmBooking', () => {
+    // U021: 決済成功時の確定
+    it('should confirm booking and update inventory', async () => {
+      // まず予約作成
+      const bookingData = {
+        tenantId,
+        date: '2025-01-08',
+        timeSlot: '14:00-14:30',
+        guests: { adult: 2, junior: 0, child: 0, infant: 0 },
+        customerInfo: {
+          name: 'テスト太郎',
+          email: 'test@example.com',
+          phone: '090-1234-5678'
+        }
+      };
+
+      const createResult = await service.createBooking(bookingData);
+      const bookingId = createResult.booking.id;
+
+      // 決済情報で確定
+      const paymentData = {
+        paymentIntentId: 'pi_fake_123',
+        stripeChargeId: 'ch_fake_123'
+      };
+
+      const result = await service.confirmBooking(bookingId, paymentData);
+
+      expect(result.success).toBe(true);
+      expect(result.booking.status).toBe('paid');
+      expect(result.booking.paymentIntentId).toBe('pi_fake_123');
+      expect(result.inventoryUpdated).toBe(true);
+    });
+
+    it('should fail to confirm non-existent booking', async () => {
+      const result = await service.confirmBooking('RES-20250108-9999', {
+        paymentIntentId: 'pi_fake_123',
+        stripeChargeId: 'ch_fake_123'
+      });
+
+      expect(result.success).toBe(false);
+      expect(result.error?.code).toBe('booking_not_found');
+    });
+
+    it('should fail to confirm already confirmed booking', async () => {
+      // 既に確定済みの予約を使用
+      const result = await service.confirmBooking('RES-20250108-0001', {
+        paymentIntentId: 'pi_fake_123',
+        stripeChargeId: 'ch_fake_123'
+      });
+
+      expect(result.success).toBe(false);
+      expect(result.error?.code).toBe('invalid_state_transition');
+    });
+  });
+
+  describe('cancelBooking', () => {
+    // U022: 正常キャンセル
+    it('should cancel booking and restore inventory', async () => {
+      const bookingId = 'RES-20250108-0001';
+      const reason = 'Customer requested';
+
+      const result = await service.cancelBooking(bookingId, reason);
+
+      expect(result.success).toBe(true);
+      expect(result.booking.status).toBe('cancelled');
+      expect(result.refund).toBeDefined();
+      expect(result.refund.amount).toBe(6930); // 7700 - 770(10%)
+      expect(result.inventoryRestored).toBe(true);
+    });
+
+    // U023: 期限切れキャンセル
+    it('should fail to cancel when deadline passed', async () => {
+      // 期限切れの予約ID
+      const bookingId = 'RES-20250108-0002';
+      const reason = 'Customer requested';
+
+      const result = await service.cancelBooking(bookingId, reason);
+
+      expect(result.success).toBe(false);
+      expect(result.error?.code).toBe('cancel_deadline_passed');
+      expect(result.error?.message).toBe('キャンセル期限を過ぎています');
+    });
+
+    it('should fail to cancel already cancelled booking', async () => {
+      const bookingId = 'RES-20250108-0003'; // 既にキャンセル済み
+      const reason = 'Customer requested';
+
+      const result = await service.cancelBooking(bookingId, reason);
+
+      expect(result.success).toBe(false);
+      expect(result.error?.code).toBe('already_cancelled');
+    });
+  });
+
+  describe('getBooking', () => {
+    it('should retrieve existing booking', async () => {
+      const bookingId = 'RES-20250108-0001';
+
+      const result = await service.getBooking(bookingId);
+
+      expect(result.success).toBe(true);
+      expect(result.booking.id).toBe(bookingId);
+      expect(result.booking.tenantId).toBe(tenantId);
+    });
+
+    it('should fail for non-existent booking', async () => {
+      const bookingId = 'RES-20250108-9999';
+
+      const result = await service.getBooking(bookingId);
+
+      expect(result.success).toBe(false);
+      expect(result.error?.code).toBe('booking_not_found');
+    });
+  });
+});
--- /dev/null
+++ tests/unit/services/stripe-payment-service.test.ts
@@ -0,0 +1,234 @@
+import { describe, it, expect, beforeEach, vi } from 'vitest';
+import { StripePaymentService } from '@/services/stripe-payment-service';
+import { fakeStripe } from '@tests/mocks/fake-stripe-adapter';
+
+describe('StripePaymentService', () => {
+  let service: StripePaymentService;
+  const tenantId = 'test-tenant-basic';
+
+  beforeEach(() => {
+    service = new StripePaymentService(fakeStripe);
+    fakeStripe.clear(); // モックデータクリア
+  });
+
+  describe('createPaymentIntent', () => {
+    // U024: PI正常作成
+    it('should create PaymentIntent with correct parameters', async () => {
+      const amount = 6600; // 税込金額
+      const bookingId = 'RES-20250108-0001';
+      const idempotencyKey = `${bookingId}-attempt-1`;
+
+      const result = await service.createPaymentIntent({
+        tenantId,
+        amount,
+        currency: 'jpy',
+        idempotencyKey,
+        metadata: {
+          bookingId,
+          tenantId
+        }
+      });
+
+      expect(result.success).toBe(true);
+      expect(result.paymentIntent.amount).toBe(amount);
+      expect(result.paymentIntent.currency).toBe('jpy');
+      expect(result.paymentIntent.client_secret).toBeDefined();
+      expect(result.paymentIntent.metadata.bookingId).toBe(bookingId);
+    });
+
+    // U025: 冪等性キー重複
+    it('should return same PaymentIntent for duplicate idempotency key', async () => {
+      const amount = 6600;
+      const idempotencyKey = 'duplicate-test-key';
+
+      // 最初の作成
+      const result1 = await service.createPaymentIntent({
+        tenantId,
+        amount,
+        currency: 'jpy',
+        idempotencyKey
+      });
+
+      // 同じキーで再作成
+      const result2 = await service.createPaymentIntent({
+        tenantId,
+        amount,
+        currency: 'jpy',
+        idempotencyKey
+      });
+
+      expect(result1.paymentIntent.id).toBe(result2.paymentIntent.id);
+      expect(result1.paymentIntent.client_secret).toBe(result2.paymentIntent.client_secret);
+    });
+
+    it('should handle Stripe API errors', async () => {
+      // Stripe APIエラーをシミュレート
+      vi.spyOn(fakeStripe, 'createPaymentIntent').mockRejectedValue(
+        new Error('Invalid API key')
+      );
+
+      const result = await service.createPaymentIntent({
+        tenantId,
+        amount: 6600,
+        currency: 'jpy'
+      });
+
+      expect(result.success).toBe(false);
+      expect(result.error?.code).toBe('stripe_api_error');
+    });
+  });
+
+  describe('processWebhook', () => {
+    // U026: 決済成功Webhook
+    it('should process successful payment webhook', async () => {
+      const webhookPayload = {
+        id: 'evt_test_123',
+        type: 'payment_intent.succeeded',
+        data: {
+          object: {
+            id: 'pi_test_123',
+            amount: 6600,
+            metadata: {
+              bookingId: 'RES-20250108-0001',
+              tenantId
+            }
+          }
+        }
+      };
+
+      const signature = 'test_signature_valid';
+      const secret = 'whsec_test_fake';
+
+      const result = await service.processWebhook(
+        JSON.stringify(webhookPayload),
+        signature,
+        secret
+      );
+
+      expect(result.success).toBe(true);
+      expect(result.eventType).toBe('payment_intent.succeeded');
+      expect(result.bookingId).toBe('RES-20250108-0001');
+      expect(result.action).toBe('confirm_booking');
+    });
+
+    // U027: 決済失敗Webhook
+    it('should process failed payment webhook', async () => {
+      const webhookPayload = {
+        id: 'evt_test_456',
+        type: 'payment_intent.payment_failed',
+        data: {
+          object: {
+            id: 'pi_test_456',
+            amount: 6600,
+            metadata: {
+              bookingId: 'RES-20250108-0001',
+              tenantId
+            }
+          }
+        }
+      };
+
+      const signature = 'test_signature_valid';
+      const secret = 'whsec_test_fake';
+
+      const result = await service.processWebhook(
+        JSON.stringify(webhookPayload),
+        signature,
+        secret
+      );
+
+      expect(result.success).toBe(true);
+      expect(result.eventType).toBe('payment_intent.payment_failed');
+      expect(result.action).toBe('cancel_booking');
+    });
+
+    // U028: 署名検証失敗
+    it('should reject webhook with invalid signature', async () => {
+      const webhookPayload = { id: 'evt_test_789', type: 'payment_intent.succeeded' };
+      const invalidSignature = 'invalid_signature';
+      const secret = 'whsec_test_fake';
+
+      const result = await service.processWebhook(
+        JSON.stringify(webhookPayload),
+        invalidSignature,
+        secret
+      );
+
+      expect(result.success).toBe(false);
+      expect(result.error?.code).toBe('webhook_invalid_signature');
+      expect(result.error?.message).toBe('Webhook署名が無効です');
+    });
+
+    it('should handle duplicate webhook events', async () => {
+      const webhookPayload = {
+        id: 'evt_duplicate_test',
+        type: 'payment_intent.succeeded',
+        data: { object: { id: 'pi_test_duplicate' } }
+      };
+      const signature = 'test_signature_valid';
+      const secret = 'whsec_test_fake';
+
+      // 最初の処理
+      const result1 = await service.processWebhook(
+        JSON.stringify(webhookPayload),
+        signature,
+        secret
+      );
+
+      // 重複処理
+      const result2 = await service.processWebhook(
+        JSON.stringify(webhookPayload),
+        signature,
+        secret
+      );
+
+      expect(result1.success).toBe(true);
+      expect(result2.success).toBe(true);
+      expect(result2.skipped).toBe(true); // 重複のためスキップ
+    });
+  });
+
+  describe('processRefund', () => {
+    // U029: 返金処理成功
+    it('should process refund with cancellation fee', async () => {
+      const refundData = {
+        bookingId: 'RES-20250108-0001',
+        paymentIntentId: 'pi_test_refund',
+        originalAmount: 7700,
+        reason: 'Customer requested cancellation'
+      };
+
+      const result = await service.processRefund(refundData);
+
+      expect(result.success).toBe(true);
+      expect(result.refund.originalAmount).toBe(7700);
+      expect(result.refund.feeAmount).toBe(770); // 10%
+      expect(result.refund.refundAmount).toBe(6930); // 7700 - 770
+      expect(result.refund.stripeRefundId).toBeDefined();
+    });
+
+    it('should handle refund API errors', async () => {
+      vi.spyOn(fakeStripe, 'createRefund').mockRejectedValue(
+        new Error('Charge already refunded')
+      );
+
+      const result = await service.processRefund({
+        bookingId: 'RES-20250108-0001',
+        paymentIntentId: 'pi_already_refunded',
+        originalAmount: 7700,
+        reason: 'Test refund'
+      });
+
+      expect(result.success).toBe(false);
+      expect(result.error?.code).toBe('refund_failed');
+    });
+
+    it('should handle partial refund correctly', async () => {
+      const result = await service.processRefund({
+        bookingId: 'RES-20250108-0001',
+        paymentIntentId: 'pi_partial_test',
+        originalAmount: 10000,
+        partialAmount: 5000, // 半額返金
+        reason: 'Partial cancellation'
+      });
+
+      expect(result.success).toBe(true);
+      expect(result.refund.refundAmount).toBe(5000);
+      expect(result.refund.feeAmount).toBe(0); // 部分返金では手数料なし
+    });
+  });
+
+  describe('getTenantStripeConfig', () => {
+    it('should resolve tenant-specific Stripe configuration', async () => {
+      const config = await service.getTenantStripeConfig(tenantId);
+
+      expect(config.publicKey).toBe('pk_test_fake_basic');
+      expect(config.secretKey).toBe('sk_test_fake_basic');
+      expect(config.webhookSecret).toBe('whsec_test_fake_basic');
+    });
+
+    it('should fail for non-existent tenant', async () => {
+      await expect(
+        service.getTenantStripeConfig('non-existent-tenant')
+      ).rejects.toThrow('tenant_not_found');
+    });
+
+    it('should fail for tenant with incomplete Stripe config', async () => {
+      await expect(
+        service.getTenantStripeConfig('test-tenant-error')
+      ).rejects.toThrow('Incomplete Stripe configuration');
+    });
+  });
+
+  describe('error handling', () => {
+    it('should handle network timeouts', async () => {
+      vi.spyOn(fakeStripe, 'createPaymentIntent').mockImplementation(
+        () => new Promise((_, reject) => {
+          setTimeout(() => reject(new Error('Request timeout')), 1000);
+        })
+      );
+
+      const result = await service.createPaymentIntent({
+        tenantId,
+        amount: 6600,
+        currency: 'jpy'
+      });
+
+      expect(result.success).toBe(false);
+      expect(result.error?.code).toBe('network_timeout');
+    });
+
+    it('should handle rate limiting', async () => {
+      vi.spyOn(fakeStripe, 'simulateRateLimit').mockImplementation(() => {
+        const error = new Error('Too Many Requests');
+        (error as any).statusCode = 429;
+        throw error;
+      });
+
+      const result = await service.createPaymentIntent({
+        tenantId,
+        amount: 6600,
+        currency: 'jpy'
+      });
+
+      expect(result.success).toBe(false);
+      expect(result.error?.code).toBe('rate_limit_exceeded');
+    });
+  });
+});
--- /dev/null
+++ tests/unit/domain/tenant-config-resolver.test.ts
@@ -0,0 +1,156 @@
+import { describe, it, expect, beforeEach } from 'vitest';
+import { TenantConfigResolver } from '@/domain/tenant-config-resolver';
+
+describe('TenantConfigResolver', () => {
+  let resolver: TenantConfigResolver;
+
+  beforeEach(() => {
+    resolver = new TenantConfigResolver();
+    
+    // 環境変数クリア
+    delete process.env.TENANT_TEST_TENANT_BASIC_STRIPE_SECRET_KEY;
+    delete process.env.TENANT_TEST_TENANT_BASIC_PRICING_ADULT;
+  });
+
+  describe('resolveConfig', () => {
+    // U035: 環境変数優先
+    it('should prioritize environment variables', async () => {
+      // 環境変数設定
+      process.env.TENANT_TEST_TENANT_BASIC_STRIPE_SECRET_KEY = 'sk_env_override';
+      process.env.TENANT_TEST_TENANT_BASIC_PRICING_ADULT = '5000';
+
+      const config = await resolver.resolveConfig('test-tenant-basic');
+
+      expect(config.stripe.secretKey).toBe('sk_env_override');
+      expect(config.pricing.adult).toBe(5000);
+    });
+
+    // U036: デフォルト設定適用
+    it('should apply default settings when tenant config missing', async () => {
+      const config = await resolver.resolveConfig('non-existent-tenant');
+
+      // デフォルト値が適用される
+      expect(config.pricing.adult).toBe(3000);
+      expect(config.pricing.taxRate).toBe(0.10);
+      expect(config.settings.bookingDeadlineHours).toBe(2);
+    });
+
+    it('should merge tenant config with defaults', async () => {
+      const config = await resolver.resolveConfig('test-tenant-custom');
+
+      // テナント固有の値
+      expect(config.pricing.adult).toBe(5000);
+      expect(config.pricing.taxRate).toBe(0.08);
+      
+      // デフォルトから継承される値
+      expect(config.settings.maxGuestsPerBooking).toBe(20);
+      expect(config.ui.timezone).toBe('Asia/Tokyo');
+    });
+  });
+
+  describe('resolveTenantId', () => {
+    // U037: ヘッダ優先解決
+    it('should prioritize X-Tenant-Id header', () => {
+      const request = {
+        headers: { 'X-Tenant-Id': 'header-tenant' },
+        url: '/tenant/path-tenant/booking',
+        query: { 'data-tenant': 'widget-tenant' }
+      };
+
+      const tenantId = resolver.resolveTenantId(request);
+
+      expect(tenantId).toBe('header-tenant');
+    });
+
+    it('should use URL path when header missing', () => {
+      const request = {
+        headers: {},
+        url: '/tenant/path-tenant/booking',
+        query: { 'data-tenant': 'widget-tenant' }
+      };
+
+      const tenantId = resolver.resolveTenantId(request);
+
+      expect(tenantId).toBe('path-tenant');
+    });
+
+    it('should use widget data-tenant as fallback', () => {
+      const request = {
+        headers: {},
+        url: '/booking',
+        query: { 'data-tenant': 'widget-tenant' }
+      };
+
+      const tenantId = resolver.resolveTenantId(request);
+
+      expect(tenantId).toBe('widget-tenant');
+    });
+
+    // U038: 不正テナントID
+    it('should reject invalid tenant ID format', () => {
+      const request = {
+        headers: { 'X-Tenant-Id': 'ab' }, // 4文字未満
+        url: '/booking',
+        query: {}
+      };
+
+      expect(() => {
+        resolver.resolveTenantId(request);
+      }).toThrow('tenant_not_found');
+    });
+
+    it('should reject tenant ID with invalid characters', () => {
+      const request = {
+        headers: { 'X-Tenant-Id': 'tenant@invalid' }, // 特殊文字
+        url: '/booking',
+        query: {}
+      };
+
+      expect(() => {
+        resolver.resolveTenantId(request);
+      }).toThrow('Invalid tenant ID format');
+    });
+  });
+
+  // U050: テナントID競合解決（v1.1追加）
+  describe('resolveTenantIdConflict', () => {
+    it('should resolve conflicting tenant IDs by priority', () => {
+      const request = {
+        headers: { 'X-Tenant-Id': 'priority-1' },
+        url: '/tenant/priority-2/booking',
+        query: { 'data-tenant': 'priority-3' }
+      };
+
+      const resolution = resolver.resolveTenantIdConflict(request);
+
+      expect(resolution.selectedTenantId).toBe('priority-1');
+      expect(resolution.sources).toEqual({
+        header: 'priority-1',
+        path: 'priority-2',
+        widget: 'priority-3'
+      });
+      expect(resolution.conflictDetected).toBe(true);
+    });
+
+    it('should handle no conflict when all sources match', () => {
+      const request = {
+        headers: { 'X-Tenant-Id': 'same-tenant' },
+        url: '/tenant/same-tenant/booking',
+        query: { 'data-tenant': 'same-tenant' }
+      };
+
+      const resolution = resolver.resolveTenantIdConflict(request);
+
+      expect(resolution.selectedTenantId).toBe('same-tenant');
+      expect(resolution.conflictDetected).toBe(false);
+    });
+
+    it('should handle missing sources gracefully', () => {
+      const request = {
+        headers: {},
+        url: '/booking', // パスにテナントIDなし
+        query: { 'data-tenant': 'widget-only' }
+      };
+
+      const resolution = resolver.resolveTenantIdConflict(request);
+
+      expect(resolution.selectedTenantId).toBe('widget-only');
+      expect(resolution.sources.header).toBeNull();
+      expect(resolution.sources.path).toBeNull();
+      expect(resolution.sources.widget).toBe('widget-only');
+      expect(resolution.conflictDetected).toBe(false);
+    });
+  });
+
+  describe('validation', () => {
+    it('should validate tenant configuration completeness', async () => {
+      const isValid = await resolver.validateTenantConfig('test-tenant-basic');
+
+      expect(isValid.valid).toBe(true);
+      expect(isValid.missingFields).toHaveLength(0);
+    });
+
+    it('should detect incomplete tenant configuration', async () => {
+      const isValid = await resolver.validateTenantConfig('test-tenant-error');
+
+      expect(isValid.valid).toBe(false);
+      expect(isValid.missingFields).toContain('taxRate');
+      expect(isValid.missingFields).toContain('stripe.secretKey');
+    });
+  });
+});
--- /dev/null
+++ tests/e2e/tenant-multitenant.spec.ts
@@ -0,0 +1,123 @@
+import { test, expect } from '@playwright/test';
+
+test.describe('Multi-tenant Features', () => {
+  test.beforeEach(async ({ page }) => {
+    await page.goto('/test/reset-data');
+  });
+
+  // E017: URLパスによるテナント識別
+  test('should identify tenant from URL path correctly', async ({ page }) => {
+    // 基本テナント
+    await page.goto('/tenant/test-tenant-basic/booking');
+    await expect(page.locator('[data-test="tenant-test-tenant-basic"]')).toBeVisible();
+    await expect(page.locator('[data-test="tenant-name"]')).toHaveText('基本テス  describe('edge cases', () => {
+    it('should handle large guest numbers correctly', () => {
+      const guests = { adult: 100, junior: 50, child: 25, infant: 10 };
+      
+      const result = calculator.calculate(guests);
+      
+      // 100×3000 + 50×2000 + 25×1000 + 10×0 = 300000 + 100000 + 25000 + 0 = 425000
+      // 税10%: 42500
+      // 合計: 467500
+      expect(result.subtotal).toBe(425000);
+      expect(result.tax).toBe(42500);
+      expect(result.total).toBe(467500);
+    });
+
+    it('should handle maximum guest limit validation', () => {
+      const guests = { adult: 21, junior: 0, child: 0, infant: 0 }; // 20名制限超過
+      
+      expect(() => calculator.calculate(guests)).toThrow('Total guests exceed maximum limit');
+    });
+
+    it('should handle tax calculation precision correctly', () => {
+      // 割り切れない金額での税計算
+      const customPricing = { ...defaultPricing, adult: 3333 }; // 3333円
+      const customCalculator = new PricingCalculator(customPricing);
+      const guests = { adult: 1, junior: 0, child: 0, infant: 0 };
+      
+      const result = customCalculator.calculate(guests);
+      
+      // 3333 × 10% = 333.3 → 333円（小数点切り捨て）
+      expect(result.subtotal).toBe(3333);
+      expect(result.tax).toBe(333);
+      expect(result.total).toBe(3666);
+    });
+
+    it('should format currency correctly', () => {
+      const guests = { adult: 1, junior: 0, child: 0, infant: 0 };
+      
+      const formatted = calculator.formatCurrency(calculator.calculate(guests));
+      
+      expect(formatted).toEqual({
+        subtotal: '¥3,000',
+        tax: '¥300',
+        total: '¥3,300',
+        breakdown: {
+          adult: '¥3,000',
+          junior: '¥0',
+          child: '¥0',
+          infant: '¥0'
+        }
+      });
+    });
+  });
+
+  describe('configuration validation', () => {
+    it('should reject invalid pricing configuration', () => {
+      expect(() => {
+        new PricingCalculator({
+          adult: -1000,  // 負の価格
+          junior: 2000,
+          child: 1000,
+          infant: 0,
+          taxRate: 0.10
+        });
+      }).toThrow('Unit price cannot be negative');
+    });
+
+    it('should reject invalid tax rate', () => {
+      expect(() => {
+        new PricingCalculator({
+          ...defaultPricing,
+          taxRate: 1.5  // 150%（異常値）
+        });
+      }).toThrow('Tax rate must be between 0 and 1');
+    });
+
+    it('should reject missing required fields', () => {
+      expect(() => {
+        new PricingCalculator({
+          adult: 3000,
+          // junior, child, infant, taxRate が不足
+        } as any);
+      }).toThrow('Missing required pricing configuration');
+    });
+  });
+});
--- /dev/null
+++ tests/unit/services/inventory-service.test.ts
@@ -0,0 +1,321 @@
+import { describe, it, expect, beforeEach, vi } from 'vitest';
+import { InventoryService } from '@/services/inventory-service';
+import { TestDataManager } from '@tests/setup/test-data-manager';
+
+describe('InventoryService', () => {
+  let service: InventoryService;
+  const tenantId = 'test-tenant-basic';
+  const date = '2025-01-08';
+  const timeSlot = '14:00-14:30';
+
+  beforeEach(() => {
+    service = new InventoryService();
+  });
+
+  describe('checkAvailability', () => {
+    // U011: 在庫充足確認
+    it('should return true when sufficient inventory available', async () => {
+      const requestedCapacity = 5;
+      
+      const result = await service.checkAvailability(tenantId, date, timeSlot, requestedCapacity);
+      
+      expect(result.available).toBe(true);
+      expect(result.availableCapacity).toBe(15);
+      expect(result.requestedCapacity).toBe(5);
+    });
+
+    // U012: 在庫不足確認
+    it('should return false when insufficient inventory', async () => {
+      const requestedCapacity = 20; // 15より多い
+      
+      const result = await service.checkAvailability(tenantId, date, timeSlot, requestedCapacity);
+      
+      expect(result.available).toBe(false);
+      expect(result.availableCapacity).toBe(15);
+      expect(result.requestedCapacity).toBe(20);
+    });
+
+    it('should handle zero inventory slots', async () => {
+      const zeroSlot = '15:00-15:30'; // available: 0
+      const requestedCapacity = 1;
+      
+      const result = await service.checkAvailability(tenantId, date, zeroSlot, requestedCapacity);
+      
+      expect(result.available).toBe(false);
+      expect(result.availableCapacity).toBe(0);
+    });
+
+    it('should throw error for non-existent slot', async () => {
+      const nonExistentSlot = '99:00-99:30';
+      
+      await expect(
+        service.checkAvailability(tenantId, date, nonExistentSlot, 1)
+      ).rejects.toThrow('Inventory slot not found');
+    });
+  });
+
+  describe('lockInventory', () => {
+    // U013: 在庫ロック成功
+    it('should successfully lock inventory with TTL', async () => {
+      const requestedCapacity = 5;
+      const lockId = 'lock_123';
+      
+      const result = await service.lockInventory(tenantId, date, timeSlot, requestedCapacity, lockId);
+      
+      expect(result.success).toBe(true);
+      expect(result.lockId).toBe(lockId);
+      expect(result.expiresAt).toBeInstanceOf(Date);
+      
+      // TTL=15分後であることを確認
+      const expectedExpiry = new Date(Date.now() + 15 * 60 * 1000);
+      expect(Math.abs(result.expiresAt!.getTime() - expectedExpiry.getTime())).toBeLessThan(1000);
+      
+      // 在庫が減っていることを確認
+      const availability = await service.checkAvailability(tenantId, date, timeSlot, 1);
+      expect(availability.availableCapacity).toBe(10); // 15 - 5 = 10
+    });
+
+    // U014: 在庫ロック失敗
+    it('should fail to lock when insufficient inventory', async () => {
+      const requestedCapacity = 20; // 15より多い
+      const lockId = 'lock_456';
+      
+      const result = await service.lockInventory(tenantId, date, timeSlot, requestedCapacity, lockId);
+      
+      expect(result.success).toBe(false);
+      expect(result.error?.code).toBe('fully_booked');
+      expect(result.error?.message).toBe('選択された時間は満席です');
+      expect(result.lockId).toBeUndefined();
+    });
+
+    it('should prevent duplicate locks with same ID', async () => {
+      const requestedCapacity = 5;
+      const lockId = 'duplicate_lock';
+      
+      // 最初のロック
+      await service.lockInventory(tenantId, date, timeSlot, requestedCapacity, lockId);
+      
+      // 重複ロック試行
+      const result = await service.lockInventory(tenantId, date, timeSlot, requestedCapacity, lockId);
+      
+      expect(result.success).toBe(false);
+      expect(result.error?.code).toBe('duplicate_lock');
+    });
+
+    it('should handle concurrent locking attempts', async () => {
+      const lockPromises = Array.from({ length: 5 }, (_, i) => 
+        service.lockInventory(tenantId, date, timeSlot, 5, `lock_${i}`)
+      );
+      
+      const results = await Promise.allSettled(lockPromises);
+      
+      // 最初の3つまでは成功（15 / 5 = 3）
+      const successful = results.filter(r => r.status === 'fulfilled' && r.value.success);
+      expect(successful.length).toBeLessThanOrEqual(3);
+    });
+  });
+
+  describe('releaseInventory', () => {
+    // U015: 在庫開放成功
+    it('should successfully release locked inventory', async () => {
+      const requestedCapacity = 5;
+      const lockId = 'release_test';
+      
+      // まずロック
+      await service.lockInventory(tenantId, date, timeSlot, requestedCapacity, lockId);
+      
+      // 開放
+      const result = await service.releaseInventory(lockId);
+      
+      expect(result.success).toBe(true);
+      expect(result.releasedCapacity).toBe(5);
+      
+      // 在庫が戻っていることを確認
+      const availability = await service.checkAvailability(tenantId, date, timeSlot, 1);
+      expect(availability.availableCapacity).toBe(15); // 元に戻った
+    });
+
+    it('should handle release of non-existent lock', async () => {
+      const result = await service.releaseInventory('non_existent_lock');
+      
+      expect(result.success).toBe(false);
+      expect(result.error?.code).toBe('lock_not_found');
+    });
+
+    it('should handle release of already released lock', async () => {
+      const lockId = 'already_released';
+      
+      // ロック
+      await service.lockInventory(tenantId, date, timeSlot, 5, lockId);
+      
+      // 最初の開放
+      await service.releaseInventory(lockId);
+      
+      // 重複開放
+      const result = await service.releaseInventory(lockId);
+      
+      expect(result.success).toBe(false);
+      expect(result.error?.code).toBe('lock_already_released');
+    });
+  });
+
+  describe('handleLockExpiry', () => {
+    // U016: TTL期限切れ処理
+    it('should automatically release expired locks', async () => {
+      const lockId = 'expiry_test';
+      
+      // ロック
+      await service.lockInventory(tenantId, date, timeSlot, 5, lockId);
+      
+      // 時間を16分進める（TTL=15分を超過）
+      vi.advanceTimersByTime(16 * 60 * 1000);
+      
+      // 期限切れ処理を実行
+      await service.handleLockExpiry();
+      
+      // 在庫が復帰していることを確認
+      const availability = await service.checkAvailability(tenantId, date, timeSlot, 1);
+      expect(availability.availableCapacity).toBe(15);
+    });
+
+    it('should not release locks within TTL', async () => {
+      const lockId = 'not_expired';
+      
+      // ロック
+      await service.lockInventory(tenantId, date, timeSlot, 5, lockId);
+      
+      // 時間を14分進める（TTL内）
+      vi.advanceTimersByTime(14 * 60 * 1000);
+      
+      // 期限切れ処理を実行
+      await service.handleLockExpiry();
+      
+      // 在庫はまだロックされている
+      const availability = await service.checkAvailability(tenantId, date, timeSlot, 1);
+      expect(availability.availableCapacity).toBe(10); // 15 - 5 = 10
+    });
+  });
+
+  describe('updateCapacity', () => {
+    it('should update slot capacity correctly', async () => {
+      const newCapacity = 25;
+      
+      await service.updateCapacity(tenantId, date, timeSlot, newCapacity);
+      
+      const availability = await service.checkAvailability(tenantId, date, timeSlot, 1);
+      expect(availability.totalCapacity).toBe(25);
+      // available も増加（25 - 5(既存予約) = 20）
+      expect(availability.availableCapacity).toBe(20);
+    });
+
+    it('should handle capacity reduction correctly', async () => {
+      const newCapacity = 10; // 現在15より少ない
+      
+      await service.updateCapacity(tenantId, date, timeSlot, newCapacity);
+      
+      const availability = await service.checkAvailability(tenantId, date, timeSlot, 1);
+      expect(availability.totalCapacity).toBe(10);
+      // available は 10 - 5(既存予約) = 5
+      expect(availability.availableCapacity).toBe(5);
+    });
+
+    it('should prevent capacity below existing bookings', async () => {
+      const tooSmallCapacity = 3; // 既存予約5件より少ない
+      
+      await expect(
+        service.updateCapacity(tenantId, date, timeSlot, tooSmallCapacity)
+      ).rejects.toThrow('Cannot reduce capacity below existing bookings');
+    });
+  });
+
+  describe('getAvailableSlots', () => {
+    it('should return slots with available inventory', async () => {
+      const slots = await service.getAvailableSlots(tenantId, date);
+      
+      expect(slots).toHaveLength(1);
+      expect(slots[0]).toEqual({
+        timeSlot: '14:00-14:30',
+        totalCapacity: 20,
+        availableCapacity: 15,
+        bookedCapacity: 5
+      });
+    });
+
+    it('should exclude fully booked slots', async () => {
+      const slots = await service.getAvailableSlots(tenantId, date);
+      
+      // '15:00-15:30' は available: 0 なので含まれない
+      expect(slots.every(slot => slot.timeSlot !== '15:00-15:30')).toBe(true);
+    });
+
+    it('should handle date with no available slots', async () => {
+      const emptyDate = '2025-01-09'; // データなし
+      
+      const slots = await service.getAvailableSlots(tenantId, emptyDate);
+      
+      expect(slots).toHaveLength(0);
+    });
+  });
+
+  describe('error handling', () => {
+    it('should validate input parameters', async () => {
+      await expect(
+        service.checkAvailability('', date, timeSlot, 1)
+      ).rejects.toThrow('Tenant ID is required');
+
+      await expect(
+        service.checkAvailability(tenantId, '', timeSlot, 1)
+      ).rejects.toThrow('Date is required');
+
+      await expect(
+        service.checkAvailability(tenantId, date, '', 1)
+      ).rejects.toThrow('Time slot is required');
+
+      await expect(
+        service.checkAvailability(tenantId, date, timeSlot, 0)
+      ).rejects.toThrow('Requested capacity must be positive');
+    });
+
+    it('should handle invalid date format', async () => {
+      await expect(
+        service.checkAvailability(tenantId, 'invalid-date', timeSlot, 1)
+      ).rejects.toThrow('Invalid date format');
+    });
+
+    it('should handle invalid time slot format', async () => {
+      await expect(
+        service.checkAvailability(tenantId, date, 'invalid-slot', 1)
+      ).rejects.toThrow('Invalid time slot format');
+    });
+  });
+});
--- /dev/null
+++ tests/e2e/booking-flow.spec.ts
@@ -0,0 +1,166 @@
+import { test, expect } from '@playwright/test';
+
+test.describe('Booking Flow', () => {
+  test.beforeEach(async ({ page }) => {
+    // テストデータをリセット
+    await page.goto('/test/reset-data');
+    
+    // 基本テナントの予約ページにアクセス
+    await page.goto('/tenant/test-tenant-basic/booking');
+    
+    // ページロード完了を待機
+    await page.waitForSelector('[data-test="page-load-complete"]');
+  });
+
+  // E001: 大人2名の正常予約完了
+  test('should complete booking flow for 2 adults', async ({ page }) => {
+    // Step 1: 日付選択
+    await page.click('[data-test="date-2025-01-08"]');
+    await expect(page.locator('[data-test="step-1-selected"]')).toBeVisible();
+
+    // Step 2: 時間枠選択
+    await page.click('[data-test="slot-14:00-14:30"]');
+    await expect(page.locator('[data-test="step-2-selected"]')).toBeVisible();
+
+    // Step 3: 人数入力
+    await page.fill('[data-test="count-adult"]', '2');
+    await page.fill('[data-test="count-junior"]', '0');
+    await page.fill('[data-test="count-child"]', '0');
+    await page.fill('[data-test="count-infant"]', '0');
+
+    // Step 4: 見積金額確認
+    await expect(page.locator('[data-test="price-subtotal"]')).toHaveText('¥6,000');
+    await expect(page.locator('[data-test="price-tax"]')).toHaveText('¥600');
+    await expect(page.locator('[data-test="price-total"]')).toHaveText('¥6,600');
+
+    // Step 5: 在庫確認
+    await page.click('[data-test="check-availability"]');
+    await expect(page.locator('[data-test="inventory-check"]')).toHaveText('利用可能');
+
+    // Step 6: お客様情報入力
+    await page.fill('[data-test="customer-name"]', 'テスト太郎');
+    await page.fill('[data-test="customer-email"]', 'test@example.com');
+    await page.fill('[data-test="customer-phone"]', '090-1234-5678');
+
+    // Step 7: 決済画面へ
+    await page.click('[data-test="proceed-to-payment"]');
+    await expect(page.locator('[data-test="payment-form"]')).toBeVisible();
+
+    // Step 8: Stripe決済フォーム
+    await expect(page.locator('[data-test="stripe-form"]')).toBeVisible();
+    
+    // テスト用カード番号入力
+    const cardFrame = page.frameLocator('iframe[name*="__privateStripeFrame"]');
+    await cardFrame.locator('[name="cardnumber"]').fill('4242424242424242');
+    await cardFrame.locator('[name="exp-date"]').fill('12/30');
+    await cardFrame.locator('[name="cvc"]').fill('123');
+    await cardFrame.locator('[name="postal"]').fill('1234567');
+
+    // Step 9: 決済実行
+    await page.click('[data-test="confirm-payment"]');
+    await expect(page.locator('[data-test="payment-processing"]')).toBeVisible();
+
+    // Step 10: 予約完了確認
+    await expect(page.locator('[data-test="payment-success"]')).toBeVisible({ timeout: 30000 });
+    await expect(page.locator('[data-test="booking-confirmed"]')).toBeVisible();
+    
+    // 予約ID確認
+    const bookingId = await page.locator('[data-test="booking-id"]').textContent();
+    expect(bookingId).toMatch(/^RES-20250108-\d{4}$/);
+
+    // 完了メール送信確認
+    await expect(page.locator('[data-test="email-sent"]')).toBeVisible();
+  });
+
+  // E002: 複数区分での予約完了
+  test('should complete booking with mixed categories', async ({ page }) => {
+    // 日付・時間選択
+    await page.click('[data-test="date-2025-01-08"]');
+    await page.click('[data-test="slot-14:00-14:30"]');
+
+    // 混合人数入力
+    await page.fill('[data-test="count-adult"]', '2');
+    await page.fill('[data-test="count-junior"]', '1');
+    await page.fill('[data-test="count-child"]', '1');
+    await page.fill('[data-test="count-infant"]', '1');
+
+    // 料金計算確認
+    // 大人2名: 6,000円, 中学生1名: 2,000円, 小学生1名: 1,000円, 3歳以下1名: 0円
+    // 小計: 9,000円, 税: 900円, 合計: 9,900円
+    await expect(page.locator('[data-test="price-breakdown"]')).toContainText('大人 2名: ¥6,000');
+    await expect(page.locator('[data-test="price-breakdown"]')).toContainText('中学生 1名: ¥2,000');
+    await expect(page.locator('[data-test="price-breakdown"]')).toContainText('小学生 1名: ¥1,000');
+    await expect(page.locator('[data-test="price-breakdown"]')).toContainText('3歳以下 1名: ¥0');
+    
+    await expect(page.locator('[data-test="price-subtotal"]')).toHaveText('¥9,000');
+    await expect(page.locator('[data-test="price-tax"]')).toHaveText('¥900');
+    await expect(page.locator('[data-test="price-total"]')).toHaveText('¥9,900');
+
+    // 予約フロー続行
+    await page.click('[data-test="check-availability"]');
+    await page.fill('[data-test="customer-name"]', 'テスト花子');
+    await page.fill('[data-test="customer-email"]', 'mixed@example.com');
+    await page.fill('[data-test="customer-phone"]', '080-9876-5432');
+
+    await page.click('[data-test="proceed-to-payment"]');
+
+    // 決済処理
+    const cardFrame = page.frameLocator('iframe[name*="__privateStripeFrame"]');
+    await cardFrame.locator('[name="cardnumber"]').fill('4242424242424242');
+    await cardFrame.locator('[name="exp-date"]').fill('12/30');
+    await cardFrame.locator('[name="cvc"]').fill('123');
+    await cardFrame.locator('[name="postal"]').fill('1234567');
+
+    await page.click('[data-test="confirm-payment"]');
+
+    // 完了確認
+    await expect(page.locator('[data-test="booking-confirmed"]')).toBeVisible({ timeout: 30000 });
+    
+    // 予約詳細表示確認
+    await expect(page.locator('[data-test="booking-details"]')).toContainText('合計5名');
+    await expect(page.locator('[data-test="booking-details"]')).toContainText('¥9,900');
+  });
+
+  // 人数制限エラーのテスト
+  test('should show error for exceeding guest limit', async ({ page }) => {
+    await page.click('[data-test="date-2025-01-08"]');
+    await page.click('[data-test="slot-14:00-14:30"]');
+
+    // 21名（制限超過）を入力
+    await page.fill('[data-test="count-adult"]', '21');
+    
+    await expect(page.locator('[data-test="max-capacity-error"]')).toBeVisible();
+    await expect(page.locator('[data-test="max-capacity-error"]')).toHaveText('1回の予約は最大20名までです');
+    
+    // 次のステップに進めないことを確認
+    await expect(page.locator('[data-test="check-availability"]')).toBeDisabled();
+  });
+
+  // 期限切れエラーのテスト
+  test('should show deadline error for past booking', async ({ page }) => {
+    // 過去の日付または直前の時間を選択
+    // テスト環境では2025-01-01 00:00:00 なので、2時間以内の予約は期限切れ
+    
+    await page.goto('/tenant/test-tenant-basic/booking?test-time=2025-01-08T12:30:00Z');
+    
+    await page.click('[data-test="date-2025-01-08"]');
+    await page.click('[data-test="slot-14:00-14:30"]'); // 1.5時間後（2時間以内）
+    
+    await page.fill('[data-test="count-adult"]', '1');
+    await page.click('[data-test="check-availability"]');
+    
+    await expect(page.locator('[data-test="deadline-passed"]')).toBeVisible();
+    await expect(page.locator('[data-test="error-deadline-passed"]')).toHaveText('予約受付期限を過ぎています');
+  });
+
+  test('should handle page refresh during booking process', async ({ page }) => {
+    // 予約途中でページリフレッシュ
+    await page.click('[data-test="date-2025-01-08"]');
+    await page.click('[data-test="slot-14:00-14:30"]');
+    await page.fill('[data-test="count-adult"]', '2');
+    
+    // リフレッシュ
+    await page.reload();
+    
+    // 最初からやり直しになることを確認
+    await expect(page.locator('[data-test="step-1-active"]')).toBeVisible();
+    await expect(page.locator('[data-test="count-adult"]')).toHaveValue('');
+  });
+
+  test('should maintain booking session across navigation', async ({ page }) => {
+    // 予約開始
+    await page.click('[data-test="date-2025-01-08"]');
+    await page.click('[data-test="slot-14:00-14:30"]');
+    await page.fill('[data-test="count-adult"]', '2');
+    
+    // 他のページに移動
+    await page.click('[data-test="nav-about"]');
+    
+    // 予約ページに戻る
+    await page.click('[data-test="nav-booking"]');
+    
+    // セッションが維持されていることを確認（ブラウザ実装による）
+    // await expect(page.locator('[data-test="count-adult"]')).toHaveValue('2');
+  });
+});      totalAmount: 7700,
+      email: 'test@example.com',
+      status: 'paid',
+      createdAt: '2025-01-01T10:00:00Z'
+    });
+
+    this.bookings.set('RES-20250108-0002', {
+      id: 'RES-20250108-0002',
+      tenantId: 'test-tenant-basic',
+      date: '2025-01-07', // 期限切れテスト用（前日）
+      timeSlot: '14:00-14:30',
+      guests: { adult: 1, junior: 0, child: 0, infant: 0 },
+      totalAmount: 3300,
+      email: 'expired@example.com',
+      status: 'paid',
+      createdAt: '2025-01-01T09:00:00Z'
+    });
+
+    this.bookings.set('RES-20250108-0003', {
+      id: 'RES-20250108-0003',
+      tenantId: 'test-tenant-basic',
+      date: '2025-01-08',
+      timeSlot: '14:00-14:30',
+      guests: { adult: 1, junior: 0, child: 0, infant: 0 },
+      totalAmount: 3300,
+      email: 'cancelled@example.com',
+      status: 'cancelled',
+      createdAt: '2025-01-01T08:00:00Z',
+      cancelledAt: '2025-01-01T11:00:00Z'
+    });
+  }
+
+  // データアクセサメソッド
+  static getBooking(id: string) {
+    return this.bookings.get(id);
+  }
+
+  static setBooking(id: string, data: any) {
+    this.bookings.set(id, data);
+  }
+
+  static getInventory(key: string) {
+    return this.inventory.get(key);
+  }
+
+  static setInventory(key: string, data: any) {
+    this.inventory.set(key, data);
+  }
+
+  static getTenantConfig(tenantId: string) {
+    return this.tenantConfigs.get(tenantId);
+  }
+
+  static setTenantConfig(tenantId: string, config: any) {
+    this.tenantConfigs.set(tenantId, config);
+  }
+
+  // テスト終了時のクリーンアップ
+  static cleanup(): void {
+    this.bookings.clear();
+    this.inventory.clear();
+    this.tenantConfigs.clear();
+  }
+}
--- /dev/null
+++ tests/setup/global-setup.ts
@@ -0,0 +1,47 @@
+import { FullConfig } from '@playwright/test';
+
+async function globalSetup(config: FullConfig) {
+  console.log('🚀 Starting E2E test environment setup...');
+
+  // テスト環境の初期化
+  process.env.NODE_ENV = 'test';
+  process.env.TEST_MODE = 'true';
+  
+  // テスト用固定時刻設定
+  process.env.TEST_BASE_TIME = '2025-01-01T00:00:00Z';
+  
+  // テスト用Stripeキー設定
+  process.env.STRIPE_PUBLISHABLE_KEY = 'pk_test_fake_key_for_e2e';
+  process.env.STRIPE_SECRET_KEY = 'sk_test_fake_key_for_e2e';
+  process.env.STRIPE_WEBHOOK_SECRET = 'whsec_test_fake_secret_for_e2e';
+  
+  // テスト用テナント設定
+  process.env.TEST_TENANTS = JSON.stringify([
+    'test-tenant-basic',
+    'test-tenant-custom',
+    'test-tenant-error'
+  ]);
+  
+  // データベース初期化（インメモリ）
+  console.log('📊 Initializing test database...');
+  
+  // テストサーバー起動待機
+  console.log('⏳ Waiting for test server to be ready...');
+  await waitForServer(config.webServer?.url || 'http://localhost:3000');
+  
+  // テストデータ初期化API呼び出し
+  console.log('🔄 Resetting test data...');
+  await fetch('http://localhost:3000/test/reset-data', { method: 'POST' });
+  
+  console.log('✅ E2E test environment setup complete');
+}
+
+async function waitForServer(url: string, timeout = 30000): Promise<void> {
+  const startTime = Date.now();
+  
+  while (Date.now() - startTime < timeout) {
+    try {
+      const response = await fetch(`${url}/health`);
+      if (response.ok) {
+        return;
+      }
+    } catch (error) {
+      // サーバーがまだ起動していない
+    }
+    
+    await new Promise(resolve => setTimeout(resolve, 1000));
+  }
+  
+  throw new Error(`Test server not ready after ${timeout}ms`);
+}
+
+export default globalSetup;
--- /dev/null
+++ tests/setup/global-teardown.ts
@@ -0,0 +1,24 @@
+import { FullConfig } from '@playwright/test';
+
+async function globalTeardown(config: FullConfig) {
+  console.log('🧹 Starting E2E test environment cleanup...');
+  
+  try {
+    // テストデータクリーンアップ
+    console.log('🗑️ Cleaning up test data...');
+    await fetch('http://localhost:3000/test/cleanup', { method: 'POST' });
+    
+    // テスト成果物のクリーンアップ
+    console.log('📁 Cleaning up test artifacts...');
+    
+    // 環境変数クリア
+    delete process.env.TEST_MODE;
+    delete process.env.TEST_BASE_TIME;
+    delete process.env.TEST_TENANTS;
+    
+    console.log('✅ E2E test environment cleanup complete');
+    
+  } catch (error) {
+    console.warn('⚠️ Warning: Cleanup failed:', error);
+    // テスト結果に影響しないよう、エラーは警告として扱う
+  }
+}
+
+export default globalTeardown;
--- /dev/null
+++ tests/mocks/fake-stripe-adapter.ts
@@ -0,0 +1,216 @@
+/**
+ * E2Eテスト用のFake Stripeアダプター
+ * 実際のStripe APIを呼び出さず、決定論的な結果を返す
+ */
+export class FakeStripeAdapter {
+  private paymentIntents = new Map<string, any>();
+  private refunds = new Map<string, any>();
+  private webhookEvents = new Map<string, any>();
+
+  // PaymentIntent作成
+  async createPaymentIntent(params: {
+    amount: number;
+    currency: string;
+    idempotencyKey?: string;
+    metadata?: Record<string, string>;
+  }) {
+    const id = `pi_fake_${Date.now()}_${Math.random().toString(36).substring(7)}`;
+    const clientSecret = `${id}_secret_fake`;
+    
+    const paymentIntent = {
+      id,
+      client_secret: clientSecret,
+      amount: params.amount,
+      currency: params.currency,
+      status: 'requires_payment_method',
+      metadata: params.metadata || {},
+      created: Math.floor(Date.now() / 1000)
+    };
+
+    // 冪等性キーによる重複チェック
+    if (params.idempotencyKey) {
+      const existing = Array.from(this.paymentIntents.values())
+        .find(pi => pi.idempotencyKey === params.idempotencyKey);
+      
+      if (existing) {
+        return existing;
+      }
+      
+      paymentIntent.idempotencyKey = params.idempotencyKey;
+    }
+
+    this.paymentIntents.set(id, paymentIntent);
+    return paymentIntent;
+  }
+
+  // PaymentIntent確認（決済実行）
+  async confirmPaymentIntent(paymentIntentId: string, params: {
+    payment_method: {
+      card: {
+        number: string;
+        exp_month: number;
+        exp_year: number;
+        cvc: string;
+      };
+    };
+  }) {
+    const pi = this.paymentIntents.get(paymentIntentId);
+    if (!pi) {
+      throw new Error('Payment intent not found');
+    }
+
+    const cardNumber = params.payment_method.card.number;
+    
+    // テストカード番号による成功/失敗判定
+    const testResults: Record<string, { status: string; error?: any }> = {
+      '4242424242424242': { status: 'succeeded' },
+      '4000000000000002': { 
+        status: 'requires_payment_method',
+        error: { 
+          code: 'card_declined',
+          decline_code: 'generic_decline',
+          message: 'Your card was declined.'
+        }
+      },
+      '4000000000000069': {
+        status: 'requires_payment_method',
+        error: {
+          code: 'expired_card',
+          message: 'Your card has expired.'
+        }
+      },
+      '4000000000000127': {
+        status: 'requires_payment_method',
+        error: {
+          code: 'incorrect_cvc',
+          message: 'Your card\'s security code is incorrect.'
+        }
+      }
+    };
+
+    const result = testResults[cardNumber] || testResults['4242424242424242'];
+    
+    // PaymentIntentを更新
+    pi.status = result.status;
+    
+    if (result.error) {
+      pi.last_payment_error = result.error;
+      throw result.error;
+    }
+
+    // Webhookイベントを生成（非同期）
+    setTimeout(() => {
+      this.generateWebhookEvent('payment_intent.succeeded', pi);
+    }, 100);
+
+    return pi;
+  }
+
+  // 返金処理
+  async createRefund(params: {
+    payment_intent: string;
+    amount?: number;
+    reason?: string;
+    metadata?: Record<string, string>;
+  }) {
+    const pi = this.paymentIntents.get(params.payment_intent);
+    if (!pi || pi.status !== 'succeeded') {
+      throw new Error('Cannot refund this payment intent');
+    }
+
+    const refundId = `re_fake_${Date.now()}_${Math.random().toString(36).substring(7)}`;
+    const refund = {
+      id: refundId,
+      amount: params.amount || pi.amount,
+      currency: pi.currency,
+      payment_intent: params.payment_intent,
+      reason: params.reason || 'requested_by_customer',
+      status: 'succeeded',
+      metadata: params.metadata || {},
+      created: Math.floor(Date.now() / 1000)
+    };
+
+    this.refunds.set(refundId, refund);
+
+    // Webhookイベントを生成
+    setTimeout(() => {
+      this.generateWebhookEvent('charge.dispute.created', refund);
+    }, 100);
+
+    return refund;
+  }
+
+  // Webhook署名検証
+  validateWebhookSignature(payload: string, signature: string, secret: string): boolean {
+    // テスト環境では簡易的な検証
+    if (process.env.NODE_ENV === 'test') {
+      return signature.includes('test_signature') || signature.includes(secret);
+    }
+    
+    // 実際の検証ロジック（本番環境用）
+    const elements = signature.split(',');
+    const signatureHash = elements.find(el => el.startsWith('v1='))?.split('v1=')[1];
+    
+    return signatureHash === 'valid_test_signature';
+  }
+
+  // Webhookイベント生成
+  private generateWebhookEvent(type: string, data: any) {
+    const eventId = `evt_fake_${Date.now()}_${Math.random().toString(36).substring(7)}`;
+    const event = {
+      id: eventId,
+      object: 'event',
+      type,
+      data: { object: data },
+      created: Math.floor(Date.now() / 1000),
+      livemode: false,
+      pending_webhooks: 1,
+      request: {
+        id: `req_fake_${Date.now()}`,
+        idempotency_key: null
+      }
+    };
+
+    this.webhookEvents.set(eventId, event);
+
+    // テスト環境でのWebhook配信シミュレーション
+    if (typeof window !== 'undefined' && window.dispatchEvent) {
+      window.dispatchEvent(new CustomEvent('stripe:webhook', {
+        detail: event
+      }));
+    }
+
+    return event;
+  }
+
+  // テスト用ヘルパーメソッド
+  getPaymentIntent(id: string) {
+    return this.paymentIntents.get(id);
+  }
+
+  getRefund(id: string) {
+    return this.refunds.get(id);
+  }
+
+  getWebhookEvent(id: string) {
+    return this.webhookEvents.get(id);
+  }
+
+  // 全データクリア（テスト間のクリーンアップ）
+  clear() {
+    this.paymentIntents.clear();
+    this.refunds.clear();
+    this.webhookEvents.clear();
+  }
+
+  // 遅延処理のシミュレーション
+  async simulateDelay(ms: number = 1000) {
+    await new Promise(resolve => setTimeout(resolve, ms));
+  }
+
+  // ネットワークエラーのシミュレーション
+  simulateNetworkError() {
+    throw new Error('Network request failed');
+  }
+
+  // APIレート制限のシミュレーション
+  simulateRateLimit() {
+    const error = new Error('Too Many Requests');
+    (error as any).statusCode = 429;
+    throw error;
+  }
+}
+
+// シングルトンインスタンス
+export const fakeStripe = new FakeStripeAdapter();
+
+// テスト環境でのグローバル設定
+if (typeof global !== 'undefined' && process.env.NODE_ENV === 'test') {
+  (global as any).fakeStripe = fakeStripe;
+}
--- /dev/null
+++ tests/unit/domain/booking-id-generator.test.ts
@@ -0,0 +1,102 @@
+import { describe, it, expect, beforeEach } from 'vitest';
+import { BookingIdGenerator } from '@/domain/booking-id-generator';
+
+describe('BookingIdGenerator', () => {
+  let generator: BookingIdGenerator;
+
+  beforeEach(() => {
+    generator = new BookingIdGenerator();
+  });
+
+  describe('generateBookingId', () => {
+    // U001: 正常な予約ID生成
+    it('should generate booking ID in correct format', () => {
+      const tenantId = 'test-tenant-basic';
+      const bookingDate = new Date('2025-01-15');
+      
+      const bookingId = generator.generateBookingId(tenantId, bookingDate);
+      
+      expect(bookingId).toMatch(/^RES-20250115-\d{4}$/);
+      expect(bookingId.length).toBe(17);
+    });
+
+    // U002: 同日連番採番
+    it('should generate sequential booking IDs for same date', () => {
+      const tenantId = 'test-tenant-basic';
+      const bookingDate = new Date('2025-01-15');
+      
+      const bookingId1 = generator.generateBookingId(tenantId, bookingDate);
+      const bookingId2 = generator.generateBookingId(tenantId, bookingDate);
+      
+      expect(bookingId1).toBe('RES-20250115-0001');
+      expect(bookingId2).toBe('RES-20250115-0002');
+    });
+
+    // U003: テナント別採番
+    it('should generate independent sequences per tenant', () => {
+      const bookingDate = new Date('2025-01-15');
+      
+      const bookingId1 = generator.generateBookingId('tenant-a', bookingDate);
+      const bookingId2 = generator.generateBookingId('tenant-b', bookingDate);
+      const bookingId3 = generator.generateBookingId('tenant-a', bookingDate);
+      
+      expect(bookingId1).toBe('RES-20250115-0001');
+      expect(bookingId2).toBe('RES-20250115-0001');
+      expect(bookingId3).toBe('RES-20250115-0002');
+    });
+  });
+
+  describe('validateBookingId', () => {
+    // U004: 正常ID検証
+    it('should validate correct booking ID format', () => {
+      const validIds = [
+        'RES-20250115-0001',
+        'RES-20251231-9999',
+        'RES-20250101-0123'
+      ];
+
+      validIds.forEach(id => {
+        expect(generator.validateBookingId(id)).toBe(true);
+      });
+    });
+
+    // U005: 異常ID検証
+    it('should reject invalid booking ID formats', () => {
+      const invalidIds = [
+        'RES-202501150001',      // ハイフン不足
+        'RES-20250115-001',      // 連番桁数不足
+        'RES-20250115-00001',    // 連番桁数過多
+        'ABC-20250115-0001',     // 接頭辞違い
+        'RES-2025011A-0001',     // 日付に文字
+        'RES-20250115-000A',     // 連番に文字
+        'RES-20250115',          // 連番なし
+        '',                      // 空文字
+        'invalid-format'         // 完全に違う形式
+      ];
+
+      invalidIds.forEach(id => {
+        expect(generator.validateBookingId(id)).toBe(false);
+      });
+    });
+  });
+
+  describe('parseBookingId', () => {
+    it('should parse valid booking ID into components', () => {
+      const bookingId = 'RES-20250115-0123';
+      
+      const parsed = generator.parseBookingId(bookingId);
+      
+      expect(parsed).toEqual({
+        prefix: 'RES',
+        date: '20250115',
+        sequence: '0123',
+        valid: true
+      });
+    });
+
+    it('should return invalid flag for malformed ID', () => {
+      const bookingId = 'invalid-id';
+      
+      const parsed = generator.parseBookingId(bookingId);
+      
+      expect(parsed.valid).toBe(false);
+    });
+  });
+
+  describe('edge cases', () => {
+    it('should handle year boundary correctly', () => {
+      const date1 = new Date('2024-12-31');
+      const date2 = new Date('2025-01-01');
+      
+      const id1 = generator.generateBookingId('test', date1);
+      const id2 = generator.generateBookingId('test', date2);
+      
+      expect(id1).toBe('RES-20241231-0001');
+      expect(id2).toBe('RES-20250101-0001');
+    });
+
+    it('should handle leap year correctly', () => {
+      const leapDate = new Date('2024-02-29');
+      
+      const bookingId = generator.generateBookingId('test', leapDate);
+      
+      expect(bookingId).toBe('RES-20240229-0001');
+    });
+
+    it('should handle sequence number overflow', () => {
+      const tenantId = 'test-tenant-basic';
+      const bookingDate = new Date('2025-01-15');
+      
+      // 9999まで生成
+      for (let i = 1; i <= 9999; i++) {
+        generator.generateBookingId(tenantId, bookingDate);
+      }
+      
+      // 10000件目はエラーになることを確認
+      expect(() => {
+        generator.generateBookingId(tenantId, bookingDate);
+      }).toThrow('Daily booking limit exceeded');
+    });
+  });
+});
--- /dev/null
+++ tests/unit/domain/pricing-calculator.test.ts
@@ -0,0 +1,243 @@
+import { describe, it, expect, beforeEach } from 'vitest';
+import { PricingCalculator } from '@/domain/pricing-calculator';
+
+describe('PricingCalculator', () => {
+  let calculator: PricingCalculator;
+  const defaultPricing = {
+    adult: 3000,    // 税別
+    junior: 2000,   // 税別
+    child: 1000,    // 税別
+    infant: 0,      // 税別
+    taxRate: 0.10
+  };
+
+  beforeEach(() => {
+    calculator = new PricingCalculator(defaultPricing);
+  });
+
+  describe('calculate', () => {
+    // U006: 基本料金計算
+    it('should calculate basic pricing correctly', () => {
+      const guests = { adult: 2, junior: 0, child: 0, infant: 0 };
+      
+      const result = calculator.calculate(guests);
+      
+      expect(result).toEqual({
+        breakdown: {
+          adult: { count: 2, unitPrice: 3000, subtotal: 6000 },
+          junior: { count: 0, unitPrice: 2000, subtotal: 0 },
+          child: { count: 0, unitPrice: 1000, subtotal: 0 },
+          infant: { count: 0, unitPrice: 0, subtotal: 0 }
+        },
+        subtotal: 6000,        // 税別合計
+        tax: 600,             // 消費税
+        total: 6600           // 税込合計
+      });
+    });
+
+    // U007: 混合料金計算
+    it('should calculate mixed category pricing correctly', () => {
+      const guests = { adult: 2, junior: 0, child: 1, infant: 0 };
+      
+      const result = calculator.calculate(guests);
+      
+      // 大人2名: 2 × 3,000 = 6,000円
+      // 小学生1名: 1 × 1,000 = 1,000円
+      // 小計: 7,000円
+      // 消費税: 700円
+      // 合計: 7,700円
+      expect(result).toEqual({
+        breakdown: {
+          adult: { count: 2, unitPrice: 3000, subtotal: 6000 },
+          junior: { count: 0, unitPrice: 2000, subtotal: 0 },
+          child: { count: 1, unitPrice: 1000, subtotal: 1000 },
+          infant: { count: 0, unitPrice: 0, subtotal: 0 }
+        },
+        subtotal: 7000,
+        tax: 700,
+        total: 7700
+      });
+    });
+
+    // U008: 無料区分含む計算
+    it('should handle free category correctly', () => {
+      const guests = { adult: 1, junior: 0, child: 0, infant: 1 };
+      
+      const result = calculator.calculate(guests);
+      
+      // 大人1名: 1 × 3,000 = 3,000円
+      // 3歳以下1名: 1 × 0 = 0円
+      // 小計: 3,000円
+      // 消費税: 300円
+      // 合計: 3,300円
+      expect(result).toEqual({
+        breakdown: {
+          adult: { count: 1, unitPrice: 3000, subtotal: 3000 },
+          junior: { count: 0, unitPrice: 2000, subtotal: 0 },
+          child: { count: 0, unitPrice: 1000, subtotal: 0 },
+          infant: { count: 1, unitPrice: 0, subtotal: 0 }
+        },
+        subtotal: 3000,
+        tax: 300,
+        total: 3300
+      });
+    });
+
+    // U009: ゼロ人数処理
+    it('should handle zero guests correctly', () => {
+      const guests = { adult: 0, junior: 0, child: 0, infant: 0 };
+      
+      const result = calculator.calculate(guests);
+      
+      expect(result).toEqual({
+        breakdown: {
+          adult: { count: 0, unitPrice: 3000, subtotal: 0 },
+          junior: { count: 0, unitPrice: 2000, subtotal: 0 },
+          child: { count: 0, unitPrice: 1000, subtotal: 0 },
+          infant: { count: 0, unitPrice: 0, subtotal: 0 }
+        },
+        subtotal: 0,
+        tax: 0,
+        total: 0
+      });
+    });
+
+    // U010: 税率変更対応
+    it('should handle different tax rates correctly', () => {
+      const customPricing = { ...defaultPricing, taxRate: 0.08 }; // 8%
+      const customCalculator = new PricingCalculator(customPricing);
+      const guests = { adult: 1, junior: 0, child: 0, infant: 0 };
+      
+      const result = customCalculator.calculate(guests);
+      
+      // 大人1名: 3,000円
+      // 消費税8%: 240円
+      // 合計: 3,240円
+      expect(result.subtotal).toBe(3000);
+      expect(result.tax).toBe(240);
+      expect(result.total).toBe(3240);
+    });
+  });
+
+  describe('validateGuests', () => {
+    it('should validate positive guest counts', () => {
+      const validGuests = { adult: 1, junior: 2, child: 1, infant: 0 };
+      
+      expect(() => calculator.calculate(validGuests)).not.toThrow();
+    });
+
+    it('should reject negative guest counts', () => {
+      const invalidGuests = { adult: -1, junior: 0, child: 0, infant: 0 };
+      
+      expect(() => calculator.calculate(invalidGuests)).toThrow('Guest count cannot be negative');
+    });
+
+    it('should reject non-integer guest counts', () => {
+      const invalidGuests = { adult: 1.5, junior: 0, child: 0, infant: 0 };
+      
+      expect(() => calculator.calculate(invalidGuests)).toThrow('Guest count must be integer');
+    });
+  });
+
+  describe('pricing configuration', () => {
+    it('should handle custom pricing configuration', () => {
+      const customPricing = {
+        adult: 5000,
+        junior: 3000,
+        child: 1500,
+        infant: 500,  // 有料設定
+        taxRate: 0.08
+      };
+      const customCalculator = new PricingCalculator(customPricing);
+      const guests = { adult: 1, junior: 1, child: 1, infant: 1 };
+      
+      const result = customCalculator.calculate(guests);
+      
+      // 5000 + 3000 + 1500 + 500 = 10000円
+      // 消費税8%: 800円
+      // 合計: 10800円
+      expect(result.subtotal).toBe(10000);
+      expect(result.tax).toBe(800);
+      expect(result.total).toBe(10800);
+    });
+
+    it('should handle zero tax rate', () => {
+      const noTaxPricing = { ...defaultPricing, taxRate: 0 };
+      const noTaxCalculator = new PricingCalculator(noTaxPricing);
+      const guests = { adult: 1, junior: 0, child: 0, infant: 0 };
+      
+      const result = noTaxCalculator.calculate(guests);
+      
+      expect(result.subtotal).toBe(3000);
+      expect(result.tax).toBe(0);
+      expect(result.total).toBe(3000);
+    });
+  });
+
+  describe('edge cases', () => {| U057 | ErrorCodeValidator | validateAllErrorCodes | 全エラーコード検証 | 付録B | Medium | 13種類全てのエラーコード生成 |
+| U058 | ConfigFileResolver | resolveEnvironmentConfig | 環境別設定解決 | 付録D | High | env > json > default の優先順位 |
+| U059 | TestDataValidator | validateRelativeDateCalc | 相対日付計算検証 | REQ-040 | Medium | テスト実行日+7日の正確な計算 |
+
+## テストデータ設定
+
+### 固定テスト値
+```javascript
+const TEST_DATA = {
+  // 日時設定（相対日付）
+  baseDate: '2025-01-01T00:00:00Z',
+  bookingDate: '2025-01-08T14:00:00Z', // baseDate + 7日
+  
+  // テナント設定
+  testTenant: 'test-tenant-basic',
+  pricing: {
+    adult: 3000,     // 税別
+    junior: 2000,    // 税別
+    child: 1000,     // 税別
+    infant: 0,       // 税別
+    taxRate: 0.10
+  },
+  
+  // 在庫設定
+  inventory: {
+    '2025-01-08': {
+      '14:00-14:30': { capacity: 20, available: 15 },
+      '15:00-15:30': { capacity: 30, available: 0 }
+    }
+  },
+  
+  // 予約ID範囲
+  bookingIdRange: 'RES-20250108-0001 ~ RES-20250108-0100',
+  
+  // v1.1追加: セキュリティ設定
+  encryption: {
+    algorithm: 'AES-256-GCM',
+    testEmail: 'test@example.com',
+    testEncrypted: 'encrypted_test_data_base64'
+  },
+  
+  // v1.1追加: パフォーマンス設定
+  performance: {
+    apiTimeoutMs: 500,
+    measurementSamples: 100
+  }
+};
+```
+
+### モック設定
+- **時刻制御**: `vi.useFakeTimers()` で固定時刻
+- **UUID生成**: 決定論的なseed値使用
+- **Stripe API**: 完全モック（FakeStripeAdapter）
+- **メール送信**: コンソール出力のみ
+- **暗号化処理**: テスト用固定キーでのモック実装
+
+## 実行環境設定
+- **Node.js**: 20.x
+- **TypeScript**: 5.x  
+- **Vitest**: 最新版
+- **カバレッジ**: c8
+- **メモリ制限**: 256MB
+- **タイムアウト**: テストあたり5秒
+
+## カバレッジ目標（v1.1）
+- **行カバレッジ**: 85%以上（v1.0から5%向上）
+- **分岐カバレッジ**: 85%以上
+- **関数カバレッジ**: 90%以上
+- **未テストファイル**: 0件
--- /dev/null
+++ docs/testcases.e2e.v1.1.md
@@ -0,0 +1,394 @@
+# E2Eテストケース設計 v1.1（統合版）
+
+## 改訂履歴
+- v1.0 → v1.1: 未カバーシナリオへの対応として7件のテストケースを追加（E034～E040）
+
+## テストシナリオ分類
+
+### 1. ユーザージャーニー（メインフロー）
+- 予約作成から決済完了まで
+- キャンセル処理
+- 管理者での設定変更
+
+### 2. エラーケース
+- 在庫不足、決済エラー、期限切れ等
+- ネットワーク障害時の動作
+
+### 3. マルチテナント
+- テナント切り替え動作
+- 埋め込みウィジェット
+
+### 4. レスポンシブ・クロスブラウザ
+- 各ブラウザでの動作確認
+- モバイル表示対応
+
+### 5. セキュリティ・システム管理（v1.1新設）
+- 認証・認可のセキュリティ検証
+- システム監視・復旧機能
+
+## E2Eテストケース一覧
+
+| No. | シナリオ | テストケース名 | 要件ID | 優先度 | ブラウザ | 実行時間目安 |
+|-----|---------|---------------|--------|--------|----------|--------------|
+| **1. 予約作成フロー（正常系）** |
+| E001 | 基本予約フロー | 大人2名の正常予約完了 | REQ-003 | Critical | All | 120s |
+| E002 | 混合予約フロー | 複数区分での予約完了 | REQ-004 | High | Chromium | 90s |
+| E003 | 料金確認フロー | 見積金額の正確性確認 | REQ-012 | High | Chromium | 60s |
+| E004 | 在庫確認フロー | 在庫残数リアルタイム表示 | REQ-014 | Medium | Chromium | 45s |
+| **2. 決済処理フロー** |
+| E005 | 正常決済 | Stripe決済成功パターン | REQ-007 | Critical | All | 150s |
+| E006 | 決済エラー | カード拒否時のエラー表示 | REQ-009 | High | Chromium | 90s |
+| E007 | 決済タイムアウト | 15分経過時の自動キャンセル | REQ-009 | Medium | Chromium | 180s |
+| E008 | Webhook遅延 | Webhook未受信時の手動確認 | REQ-008 | Medium | Chromium | 120s |
+| **3. キャンセル処理フロー** |
+| E009 | 正常キャンセル | 予約IDでのキャンセル成功 | REQ-010 | High | All | 90s |
+| E010 | キャンセル期限切れ | 24時間前過ぎのエラー表示 | REQ-011 | High | Chromium | 45s |
+| E011 | 返金処理 | キャンセル時の手数料差引返金 | REQ-010 | Medium | Chromium | 120s |
+| **4. エラーケース（異常系）** |
+| E012 | 在庫不足エラー | 満席時のエラー表示と代替提案 | REQ-030 | High | Chromium | 60s |
+| E013 | 期限切れエラー | 2時間前期限のエラー表示 | REQ-005 | High | Chromium | 30s |
+| E014 | 入力値エラー | 不正人数入力時のバリデーション | REQ-030 | Medium | Chromium | 45s |
+| E015 | 重複予約エラー | 同メール同日時の重複予約防止 | REQ-005 | Medium | Chromium | 75s |
+| E016 | ネットワークエラー | 接続切断時のリトライ機能 | REQ-030 | Low | Chromium | 90s |
+| **5. マルチテナント** |
+| E017 | テナント切り替え | URLパスによるテナント識別 | REQ-018 | High | All | 60s |
+| E018 | カスタムブランド | テナント別ロゴ・色の表示 | REQ-017 | Medium | Chromium | 45s |
+| E019 | 料金設定差異 | テナント別料金表の適用 | REQ-019 | High | Chromium | 75s |
+| E020 | 埋め込みウィジェット | data-tenant属性でのテナント識別 | REQ-020 | Medium | Chromium | 90s |
+| **6. 管理機能** |
+| E021 | 管理者ログイン | JWT認証による管理画面アクセス | REQ-024 | High | Chromium | 60s |
+| E022 | 予約一覧表示 | 管理者での予約リスト表示・フィルタ | REQ-016 | Medium | Chromium | 90s |
+| E023 | 在庫設定変更 | 定員・公開状態の変更と即時反映 | REQ-015 | Medium | Chromium | 120s |
+| E024 | 料金設定変更 | 区分別料金の変更と見積への反映 | REQ-019 | Medium | Chromium | 90s |
+| E025 | ブランド設定変更 | ロゴ・色・サイト名の変更と表示確認 | REQ-017 | Low | Chromium | 120s |
+| **7. パフォーマンス・UX** |
+| E026 | レスポンス時間 | 各画面の3秒以内表示 | REQ-021 | Medium | All | 180s |
+| E027 | 動的更新 | 人数変更時の即座な金額更新 | REQ-013 | Medium | Chromium | 45s |
+| E028 | ローディング表示 | 非同期処理中のローディング表示 | REQ-003 | Low | Chromium | 60s |
+| **8. モバイル対応** |
+| E029 | モバイル表示 | スマホサイズでの表示・操作性 | - | Low | WebKit | 90s |
+| E030 | タッチ操作 | タップ・スワイプでの操作確認 | - | Low | WebKit | 75s |
+| **9. データ整合性** |
+| E031 | 同時予約競合 | 複数ユーザーでの同時予約処理 | REQ-031 | High | Chromium | 180s |
+| E032 | 在庫整合性 | 予約・キャンセル後の在庫数整合性 | REQ-031 | High | Chromium | 120s |
+| E033 | 決済状態同期 | Stripe決済状態と予約状態の一致 | REQ-031 | Medium | Chromium | 150s |
+| **10. セキュリティ・システム管理（v1.1新設）** |
+| E034 | テナント競合解決 | 複数経路テナントID競合時の解決確認 | REQ-018 | High | Chromium | 90s |
+| E035 | JWT認証セキュリティ | トークン期限切れ時の自動ログアウト | REQ-024 | High | Chromium | 75s |
+| E036 | 状態遷移網羅 | 全予約状態遷移パターンの確認 | 付録A | Medium | Chromium | 180s |
+| E037 | 時刻制御検証 | 固定時刻でのテスト動作確認 | REQ-041 | Medium | Chromium | 60s |
+| E038 | データ復旧 | バックアップからのデータ復旧確認 | REQ-027 | Low | Chromium | 120s |
+| E039 | 設定切替動作 | 環境別設定ファイルの切替確認 | 付録D | Medium | Chromium | 90s |
+| E040 | 可用性監視 | サービス稼働率監視機能の動作確認 | REQ-023 | Low | Chromium | 150s |
+
+## テストセレクタ設計
+
+### data-test属性命名規約
+```javascript
+// カテゴリ別セレクタ設計
+const SELECTORS = {
+  // 日付・時間選択
+  datePicker: '[data-test="date-picker"]',
+  dateUnavailable: '[data-test="date-unavailable"]',
+  timeSlot: '[data-test="time-slot"]',
+  slotUnavailable: '[data-test="slot-unavailable"]',
+  
+  // 人数入力
+  countAdult: '[data-test="count-adult"]',
+  countJunior: '[data-test="count-junior"]',
+  countChild: '[data-test="count-child"]',
+  countInfant: '[data-test="count-infant"]',
+  
+  // 料金表示
+  priceBreakdown: '[data-test="price-breakdown"]',
+  priceSubtotal: '[data-test="price-subtotal"]',
+  priceTax: '[data-test="price-tax"]',
+  priceTotal: '[data-test="price-total"]',
+  
+  // 決済
+  paymentForm: '[data-test="payment-form"]',
+  stripeForm: '[data-test="stripe-form"]',
+  paymentProcessing: '[data-test="payment-processing"]',
+  paymentSuccess: '[data-test="payment-success"]',
+  
+  // 予約確認
+  bookingConfirmed: '[data-test="booking-confirmed"]',
+  bookingId: '[data-test="booking-id"]',
+  
+  // キャンセル
+  bookingSearch: '[data-test="booking-search"]',
+  cancelEligible: '[data-test="cancel-eligible"]',
+  cancelButton: '[data-test="cancel-button"]',
+  
+  // エラー表示
+  errorMessage: '[data-test="error-message"]',
+  errorFullyBooked: '[data-test="error-fully-booked"]',
+  errorDeadlinePassed: '[data-test="error-deadline-passed"]',
+  errorPaymentDeclined: '[data-test="error-payment-declined"]',
+  
+  // ローディング状態
+  loadingSpinner: '[data-test="loading-spinner"]',
+  loadingPayment: '[data-test="loading-payment"]',
+  
+  // 管理機能
+  adminLogin: '[data-test="admin-login"]',
+  bookingList: '[data-test="booking-list"]',
+  inventoryChart: '[data-test="inventory-chart"]',
+  settingsPanel: '[data-test="settings-panel"]',
+  
+  // テナント識別
+  tenantLogo: '[data-test="tenant-logo"]',
+  tenantName: '[data-test="tenant-name"]',
+  widgetContainer: '[data-test="widget-container"]',
+  
+  // v1.1追加: セキュリティ・システム
+  authTokenExpiry: '[data-test="auth-token-expiry"]',
+  systemHealth: '[data-test="system-health"]',
+  backupStatus: '[data-test="backup-status"]',
+  configEnv: '[data-test="config-env"]'
+};
+```
+
+### 動的セレクタ
+```javascript
+// 日付・時間指定
+const dateSlot = (date) => `[data-test="date-${date}"]`;
+const timeSlot = (time) => `[data-test="slot-${time}"]`;
+const tenantElement = (tenantId) => `[data-test="tenant-${tenantId}"]`;
+
+// 状態指定
+const stepStatus = (step, status) => `[data-test="step-${step}-${status}"]`;
+const errorType = (type) => `[data-test="error-${type}"]`;
+
+// v1.1追加: 状態遷移指定
+const bookingState = (state) => `[data-test="booking-state-${state}"]`;
+const systemStatus = (status) => `[data-test="system-status-${status}"]`;
+```
+
+## テスト環境設定
+
+### ブラウザ設定
+```javascript
+// playwright.config.ts
+export default {
+  projects: [
+    { name: 'chromium', use: { ...devices['Desktop Chrome'] } },
+    { name: 'firefox', use: { ...devices['Desktop Firefox'] } },
+    { name: 'webkit', use: { ...devices['Desktop Safari'] } }
+  ],
+  use: {
+    baseURL: 'http://localhost:3000',
+    trace: 'on-first-retry',
+    screenshot: 'only-on-failure',
+    video: 'retain-on-failure',
+    // v1.1追加: セキュリティテスト設定
+    extraHTTPHeaders: {
+      'X-Test-Mode': 'true',
+      'X-Security-Test': 'enabled'
+    }
+  }
+};
+```
+
+### テストデータ設定
+```javascript
+// テスト用固定データ
+const E2E_TEST_DATA = {
+  // 基準日時
+  testDate: '2025-01-01T00:00:00Z',
+  bookingDate: '2025-01-08T14:00:00Z',
+  
+  // テストテナント
+  tenants: {
+    basic: 'test-tenant-basic',
+    custom: 'test-tenant-custom',
+    error: 'test-tenant-error'
+  },
+  
+  // テスト予約
+  bookings: {
+    valid: 'RES-20250108-0001',
+    expired: 'RES-20250108-0002',
+    cancelled: 'RES-20250108-0003'
+  },
+  
+  // テストユーザー
+  users: {
+    customer: { email: 'test@example.com', name: 'テスト太郎' },
+    admin: { email: 'admin@test.com', password: 'admin123' }
+  },
+  
+  // Stripe テストカード
+  cards: {
+    valid: '4242424242424242',
+    declined: '4000000000000002',
+    expired: '4000000000000069'
+  },
+  
+  // v1.1追加: セキュリティ・システムテストデータ
+  security: {
+    jwtTokenValid: 'eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9...',
+    jwtTokenExpired: 'eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9...',
+    encryptionKey: 'test-encryption-key-32-chars-long'
+  },
+  
+  system: {
+    backupPath: '/tmp/test-backup',
+    configFiles: ['test-tenant-basic.json', 'test-tenant-custom.json'],
+    healthCheckEndpoint: '/api/health'
+  }
+};
+```
+
+### FakeStripeAdapter設定
+```javascript
+class FakeStripeAdapter {
+  createPaymentIntent(amount, currency = 'jpy') {
+    return Promise.resolve({
+      id: 'pi_fake_' + Date.now(),
+      client_secret: 'pi_fake_secret_' + Date.now(),
+      amount,
+      currency,
+      status: 'requires_payment_method'
+    });
+  }
+  
+  confirmCardPayment(clientSecret, cardNumber) {
+    // テストカード番号に基づく成功/失敗判定
+    if (cardNumber === '4242424242424242') {
+      return Promise.resolve({ status: 'succeeded' });
+    } else {
+      return Promise.reject({ code: 'card_declined' });
+    }
+  }
+  
+  // v1.1追加: Webhook署名検証のモック
+  validateWebhookSignature(payload, signature, secret) {
+    // テスト環境での署名検証ロジック
+    return signature.includes('test_signature');
+  }
+}
+```
+
+## 実行戦略
+
+### 並列実行設定
+- **Critical テスト**: 全ブラウザで並列実行
+- **High テスト**: Chromiumのみで実行
+- **Medium/Low テスト**: 必要時のみ実行
+
+### リトライ設定
+- **ネットワーク系**: 3回までリトライ
+- **タイミング系**: 2回までリトライ
+- **UI操作系**: 1回のみ（安定性重視）
+
+### タイムアウト設定
+- **ページ遷移**: 10秒
+- **決済処理**: 30秒
+- **API レスポンス**: 5秒
+- **全体シナリオ**: 300秒（5分）
+
+### v1.1追加: セキュリティテスト設定
+- **認証タイムアウト**: JWT期限切れを15分で強制発生
+- **暗号化テスト**: テスト用固定キーでの暗号化検証
+- **署名検証**: Webhook署名の境界値テスト
+
+## 成功基準（v1.1更新）
+- **全シナリオ PASS**: 100%成功率（40件 → 40件）
+- **実行時間**: 6分以内（v1.0から1分延長）
+- **スクリーンショット**: 失敗時のみ自動保存
+- **メモリ使用量**: 1.2GB以内（v1.0から200MB増加）
+- **セキュリティテスト**: 全てのセキュリティシナリオでPASS
+
+## v1.1で強化された検証項目
+1. **テナント識別の競合解決**: 複数経路での一意な解決確認
+2. **JWT認証のセキュリティ**: トークン期限・改ざんへの適切な対応
+3. **状態遷移の網羅性**: 全予約状態パターンの動作確認
+4. **システム監視**: バックアップ・復旧・稼働率監視の動作
+5. **設定管理の柔軟性**: 環境別設定ファイルの適切な切替
+6. **時刻制御の正確性**: テスト実行時の固定時刻動作
+7. **データ復旧の信頼性**: 障害からの自動復旧機能
--- /dev/null
+++ tests/setup/vitest.setup.ts
@@ -0,0 +1,57 @@
+import { beforeEach, afterEach, vi } from 'vitest';
+import { MockDate } from './mock-date';
+import { TestDataManager } from './test-data-manager';
+
+// テスト用固定データ
+export const TEST_DATA = {
+  baseDate: '2025-01-01T00:00:00Z',
+  bookingDate: '2025-01-08T14:00:00Z',
+  testTenant: 'test-tenant-basic',
+  pricing: {
+    adult: 3000,
+    junior: 2000,
+    child: 1000,
+    infant: 0,
+    taxRate: 0.10
+  },
+  inventory: {
+    '2025-01-08': {
+      '14:00-14:30': { capacity: 20, available: 15 },
+      '15:00-15:30': { capacity: 30, available: 0 }
+    }
+  },
+  bookingIdRange: 'RES-20250108-0001 ~ RES-20250108-0100',
+  encryption: {
+    algorithm: 'AES-256-GCM',
+    testEmail: 'test@example.com',
+    testEncrypted: 'encrypted_test_data_base64'
+  },
+  performance: {
+    apiTimeoutMs: 500,
+    measurementSamples: 100
+  }
+};
+
+// グローバルセットアップ
+beforeEach(async () => {
+  // 時刻を固定
+  vi.useFakeTimers();
+  vi.setSystemTime(new Date(TEST_DATA.baseDate));
+  
+  // テストデータをリセット
+  await TestDataManager.reset();
+  
+  // 環境変数設定
+  process.env.NODE_ENV = 'test';
+  process.env.TEST_TENANT = TEST_DATA.testTenant;
+  
+  // コンソール出力を抑制（必要に応じて）
+  vi.spyOn(console, 'log').mockImplementation(() => {});
+  vi.spyOn(console, 'warn').mockImplementation(() => {});
+});
+
+afterEach(() => {
+  // タイマーをクリア
+  vi.useRealTimers();
+  
+  // モックをクリア
+  vi.clearAllMocks();
+  vi.resetAllMocks();
+  
+  // 環境変数をクリア
+  delete process.env.TEST_TENANT;
+});
+
+// グローバル型定義の拡張
+declare global {
+  var testData: typeof TEST_DATA;
+}
+
+globalThis.testData = TEST_DATA;
--- /dev/null
+++ tests/setup/test-data-manager.ts
@@ -0,0 +1,166 @@
+/**
+ * テストデータ管理クラス
+ * 各テスト実行前にデータを初期状態にリセット
+ */
+export class TestDataManager {
+  private static bookings = new Map();
+  private static inventory = new Map();
+  private static tenantConfigs = new Map();
+
+  static async reset(): Promise<void> {
+    this.bookings.clear();
+    this.inventory.clear();
+    this.tenantConfigs.clear();
+    
+    // 初期データを設定
+    await this.initializeTestData();
+  }
+
+  private static async initializeTestData(): Promise<void> {
+    // テストテナント設定
+    this.tenantConfigs.set('test-tenant-basic', {
+      tenantId: 'test-tenant-basic',
+      name: '基本テスト店舗',
+      pricing: {
+        adult: 3000,
+        junior: 2000,
+        child: 1000,
+        infant: 0,
+        taxRate: 0.10
+      },
+      stripe: {
+        publicKey: 'pk_test_fake',
+        secretKey: 'sk_test_fake',
+        webhookSecret: 'whsec_test_fake'
+      },
+      settings: {
+        bookingDeadlineHours: 2,
+        cancelDeadlineHours: 24,
+        cancelFeeRate: 0.10,
+        inventoryLockTtlMinutes: 15
+      }
+    });
+
+    this.tenantConfigs.set('test-tenant-custom', {
+      tenantId: 'test-tenant-custom',
+      name: 'カスタムテスト店舗',
+      pricing: {
+        adult: 5000,
+        junior: 3000,
+        child: 1500,
+        infant: 0,
+        taxRate: 0.08
+      }
+    });
+
+    this.tenantConfigs.set('test-tenant-error', {
+      tenantId: 'test-tenant-error',
+      name: 'エラーテスト店舗',
+      // 意図的に不完全な設定
+    });
+
+    // 初期在庫データ
+    this.inventory.set('test-tenant-basic:2025-01-08:14:00-14:30', {
+      capacity: 20,
+      available: 15,
+      locked: 0
+    });
+
+    this.inventory.set('test-tenant-basic:2025-01-08:15:00-15:30', {
+      capacity: 30,
+      available: 0,
+      locked: 0
+    });
+
+    // テスト用予約データ
+    this.bookings.set('RES-20250108-0001', {
+      id: 'RES-20250108-0001',
+      tenantId: 'test-tenant-basic',
+      date: '2025-01-08',
+      timeSlot: '14:00-14:30',
+      guests: {
+        adult: 2,
+        junior: 0,
+        child: 1,
+        infant: 0
+      },
+      totalAmount: 7700### REQ-033: スコープ外機能（明確化）
+以下の機能は明確に初期スコープから除外：
+- **多通貨対応**: JPY以外の通貨
+- **税計算**: 軽減税率・複数税率
+- **請求書・領収書**: PDF生成機能
+- **座席指定**: 具体的座席の指定機能
+- **グループ予約**: 複数予約の関連付け
+- **リマインダー**: 予約前日の自動通知
+- **レビュー機能**: 利用後の評価機能
+
+## 7. 受け入れ基準（GREEN基準）
+
+### REQ-034: 単体テスト受け入れ基準
+**コマンド**: `npm run test:unit`
+- **テスト成功率**: 100% PASS（0件の失敗）
+- **カバレッジ**: 80%以上（Lines, Branches, Functions, Statements）
+- **実行時間**: 30秒以内
+- **メモリ使用量**: 256MB以内
+
+**GREEN判定条件:**
+```
+✓ All tests passed (xxx tests)
+✓ Coverage: Lines 80%+ | Branches 80%+ | Functions 80%+ | Statements 80%+
+✓ Duration: < 30s
+✓ Memory: < 256MB
+```
+
+### REQ-035: E2Eテスト受け入れ基準
+**コマンド**: `npm run test:e2e`
+- **シナリオ成功率**: 100% PASS（0件の失敗）
+- **実行時間**: 5分以内
+- **ブラウザ**: Chromium, Firefox, WebKit（3ブラウザ対応）
+- **スクリーンショット**: 失敗時のみ自動保存
+
+**GREEN判定条件:**
+```
+✓ All scenarios passed (xxx scenarios)
+✓ Duration: < 5min
+✓ Browsers: Chromium ✓ | Firefox ✓ | WebKit ✓
+✓ No failed screenshots
+```
+
+### REQ-036: 統合テスト受け入れ基準
+**決済統合テスト** (`npm run test:integration:stripe`)
+- **Stripe Test環境**: 決済成功・失敗・返金の各パターンでテスト
+- **Webhook受信**: 正常なWebhook受信・処理確認
+- **データ整合性**: 決済状態と予約状態の一致確認
+
+**GREEN判定条件:**
+```
+✓ Payment success test passed
+✓ Payment failure test passed  
+✓ Refund test passed
+✓ Webhook processing test passed
+✓ Data consistency verified
+```
+
+### REQ-037: パフォーマンステスト受け入れ基準
+**コマンド**: `npm run test:performance`
+- **API応答時間**: 95%のリクエストが500ms以内
+- **同時接続**: 100セッション同時処理で応答時間劣化10%以内
+- **メモリリーク**: 1時間連続実行でメモリ使用量が初期値の120%以内
+
+**GREEN判定条件:**
+```
+✓ API Response Time P95: < 500ms
+✓ Concurrent Load: 100 sessions, response degradation < 10%
+✓ Memory Usage: < 120% of initial after 1h
+```
+
+### REQ-038: 総合受け入れ基準
+**フルテストスイート** (`npm run test:all`)
+- **実行順序**: Unit → E2E → Integration → Performance
+- **前提条件**: ローカル環境でStripe Test Keys設定済み
+- **データ初期化**: 各テストカテゴリ実行前にテストデータリセット
+
+**最終GREEN判定条件:**
+```
+✓ Unit Tests: 100% PASS
+✓ E2E Tests: 100% PASS  
+✓ Integration Tests: 100% PASS
+✓ Performance Tests: 100% PASS
+✓ Total Duration: < 10min
+✓ No memory leaks detected
+✓ All test artifacts cleaned up
+```
+
+## 8. テスト容易性のための設計ガイドライン
+
+### REQ-039: セレクタ設計規約
+- **data-test属性**: 全ての重要なUI要素に付与
+- **命名規約**: `{category}-{element}-{state?}` 形式
+- **動的要素**: `data-test-id="{dynamic-value}"` で個別識別
+- **状態表現**: `data-test-status="{loading|success|error}"` で状態管理
+
+### REQ-040: テストデータ固定化
+- **日付固定**: テスト実行日を基準とした相対日付計算（+7日後等）
+- **料金固定**: テスト環境専用の料金表（変更されない固定値）
+- **在庫固定**: 各テストケース開始時の在庫状態を保証
+- **予約ID**: テスト用の固定予約ID範囲（RES-20250101-0001 〜 RES-20250101-0100）
+
+### REQ-041: モック・スタブ設計
+- **Stripe FakeAdapter**: 決済APIの完全なモック実装
+- **メール送信**: テスト時はコンソール出力のみ
+- **時刻制御**: テスト時は固定時刻（2025-01-01T00:00:00Z）に設定可能
+- **ランダム値**: テスト時は決定論的なseed値を使用
+
+---
+
+## 付録
+
+### 付録A: 予約状態遷移表
+
+| 状態 | 説明 | 遷移条件 | 次状態 | TTL |
+|-----|-----|---------|-------|-----|
+| `draft` | 予約作成中（仮押さえ） | 在庫確認完了 | pending-payment | 15分 |
+| `pending-payment` | 決済処理中 | 決済成功 | paid | - |
+| `pending-payment` | 決済処理中 | 決済失敗 | cancelled | - |
+| `pending-payment` | 決済処理中 | TTL期限切れ | expired | - |
+| `paid` | 決済完了・予約確定 | キャンセル要求 | cancelled | - |
+| `cancelled` | キャンセル済み | - | - | - |
+| `expired` | 期限切れ | - | - | - |
+
+**状態遷移イベント:**
+- 在庫ロック: `draft` 状態で15分間在庫を仮押さえ
+- 決済タイムアウト: 15分経過で自動的に `expired` に遷移、在庫開放
+- キャンセル: `paid` 状態からのみ可能、利用日24時間前まで
+
+### 付録B: エラーコード対照表
+
+| エラーコード | HTTPステータス | メッセージ | 詳細 |
+|------------|---------------|-----------|------|
+| `fully_booked` | 409 | 選択された時間は満席です | 在庫不足 |
+| `invalid_argument` | 400 | 入力値が正しくありません | バリデーションエラー |
+| `payment_declined` | 402 | カードが拒否されました | Stripe決済エラー |
+| `webhook_invalid_signature` | 401 | Webhook署名が無効です | Stripe署名検証失敗 |
+| `duplicate_payment` | 409 | 既に処理済みです | 重複決済防止 |
+| `deadline_passed` | 410 | 予約受付期限を過ぎています | 2時間前期限切れ |
+| `booking_not_found` | 404 | 予約が見つかりません | 予約ID不正 |
+| `cancel_deadline_passed` | 410 | キャンセル期限を過ぎています | 24時間前期限切れ |
+| `already_cancelled` | 409 | 既にキャンセル済みです | 重複キャンセル |
+| `tenant_not_found` | 404 | テナントが見つかりません | テナントID不正 |
+| `inventory_conflict` | 409 | 在庫の整合性エラー | 同時予約競合 |
+| `payment_timeout` | 408 | 決済がタイムアウトしました | 15分制限超過 |
+| `webhook_timeout` | 408 | Webhook処理がタイムアウト | 10秒制限超過 |
+| `internal_server_error` | 500 | システムエラーが発生しました | 予期しないエラー |
+
+**APIレスポンス形式:**
+```json
+{
+  "error": {
+    "code": "fully_booked",
+    "message": "選択された時間は満席です",
+    "details": {
+      "requested_capacity": 5,
+      "available_capacity": 2,
+      "slot": "2025-01-15T14:00:00Z"
+    }
+  }
+}
+```
+
+### 付録C: テナント設定解決の優先順位
+
+システムは以下の順序でテナント設定を解決する：
+
+#### 1. テナントID解決（優先順位順）
+1. **APIヘッダ**: `X-Tenant-Id: shop001`
+2. **URLパス**: `/tenant/shop001/booking`
+3. **ウィジェット**: `<script data-tenant="shop001">`
+
+#### 2. 設定値解決（優先順位順）
+1. **環境変数**: `TENANT_SHOP001_STRIPE_SECRET_KEY`
+2. **テナントJSONファイル**: `config/tenants/shop001.json`
+3. **デフォルト値**: `config/defaults.json`
+
+#### 3. 設定適用例
+```javascript
+// 1. 環境変数から取得を試行
+const stripeKey = process.env[`TENANT_${tenantId.toUpperCase()}_STRIPE_SECRET_KEY`]
+  // 2. テナント固有JSONから取得
+  || tenantConfig?.stripe?.secretKey
+  // 3. デフォルト値を適用
+  || defaultConfig.stripe.secretKey;
+```
+
+#### 4. 競合時の動作
+- 複数経路でテナントIDが異なる場合、最優先のものを採用
+- 設定値が見つからない場合、エラー `tenant_not_found` を返す
+- テスト環境では専用のテナント設定を優先適用
+
+### 付録D: 固定データの場所と切替手順
+
+#### 1. テスト用固定データファイル構成
+```
+config/
+├── defaults.json              # デフォルト設定
+├── tenants/
+│   ├── test-tenant-basic.json      # 基本テスト用
+│   ├── test-tenant-custom.json     # カスタマイズテスト用
+│   ├── test-tenant-error.json      # エラーテスト用
+│   └── production-tenant-xxx.json  # 本番テナント設定
+└── test-data/
+    ├── inventory.json         # テスト用在庫データ
+    ├── bookings.json         # テスト用予約データ
+    └── pricing.json          # テスト用料金データ
+```
+
+#### 2. テスト環境用テナント設定例（test-tenant-basic.json）
+```json
+{
+  "tenantId": "test-tenant-basic",
+  "name": "基本テスト店舗",
+  "pricing": {
+    "adult": 3000,
+    "junior": 2000, 
+    "child": 1000,
+    "infant": 0,
+    "taxRate": 0.10
+  },
+  "inventory": {
+    "2025-01-15": {
+      "14:00-14:30": { "capacity": 20, "available": 15 },
+      "15:00-15:30": { "capacity": 30, "available": 0 }
+    }
+  },
+  "stripe": {
+    "publicKey": "pk_test_...",
+    "secretKey": "sk_test_...",
+    "webhookSecret": "whsec_test_..."
+  },
+  "settings": {
+    "bookingDeadlineHours": 2,
+    "cancelDeadlineHours": 24,
+    "cancelFeeRate": 0.10,
+    "inventoryLockTtlMinutes": 15
+  }
+}
+```
+
+#### 3. 環境別設定切替方法
+
+**テスト環境起動:**
+```bash
+NODE_ENV=test npm run test:e2e
+# → config/tenants/test-*.json を自動読み込み
+```
+
+**本番環境起動:**
+```bash
+NODE_ENV=production npm start
+# → 環境変数 > config/tenants/*.json > defaults.json の順で解決
+```
+
+**開発環境での設定確認:**
+```bash
+npm run config:show --tenant=test-tenant-basic
+# → 解決された設定値を表示（デバッグ用）
+```
+
+#### 4. テストデータリセット手順
+
+**各テスト実行前の自動リセット:**
+```javascript
+// tests/setup.ts
+beforeEach(async () => {
+  // テストデータを初期状態にリセット
+  await resetTestData();
+  // 固定日時に設定（2025-01-01T00:00:00Z）
+  MockDate.set(new Date('2025-01-01T00:00:00Z'));
+});
+```
+
+**手動リセット:**
+```bash
+npm run test:reset-data
+# → config/test-data/ の内容でインメモリデータを初期化
+```
+
+#### 5. 本番データとの分離保証
+
+- テスト実行時は `NODE_ENV=test` 必須
+- テスト用テナントIDは `test-` プレフィックス必須
+- 本番Stripeキーは環境変数のみで管理（JSONファイルに含めない）
+- テスト用予約IDは `RES-202501XX-XXXX` 範囲で発番（本番との重複回避）
+
+---
+
+## まとめ
+
+本要件定義書v3.1では、テスト容易性の向上と実装時の曖昧さ排除を目的とし、以下の点を明確化しました：
+
+- **予約ID**: 17文字固定フォーマット `RES-YYYYMMDD-####`
+- **税計算**: 単価=税別、表示=税込の一意化  
+- **テナント識別**: 3経路の優先順位明文化
+- **在庫管理**: TTL=15分固定、状態遷移表での明確化
+- **Stripe連携**: 冪等性キーとWebhook検証の詳細仕様
+- **エラーハンドリング**: 標準化されたエラーコードとHTTPステータス対応
+- **テストデータ**: 固定ファイル構成と環境別切替手順
+
+これにより、実装フェーズでの仕様解釈の揺れを最小限に抑え、テストの安定性と保守性を確保できます。
--- /dev/null
+++ docs/testcases.unit.v1.1.md
@@ -0,0 +1,313 @@
+# 単体テストケース設計 v1.1（統合版）
+
+## 改訂履歴
+- v1.0 → v1.1: 未カバー要件への対応として10件のテストケースを追加（U050～U059）
+
+## テスト対象コンポーネント分類
+
+### 1. ドメインロジック
+- 予約管理 (BookingService)
+- 在庫管理 (InventoryService)
+- 料金計算 (PricingCalculator)
+- 予約ID生成 (BookingIdGenerator)
+
+### 2. 外部連携
+- Stripe連携 (StripePaymentService)
+- メール送信 (NotificationService)
+
+### 3. データ操作
+- テナント設定 (TenantConfigResolver)
+- 予約リポジトリ (BookingRepository)
+- 在庫リポジトリ (InventoryRepository)
+
+### 4. バリデーション
+- 入力値検証 (InputValidator)
+- ビジネスルール検証 (BusinessRuleValidator)
+
+### 5. セキュリティ・監視（v1.1新設）
+- 暗号化サービス (CryptographyService)
+- パフォーマンス監視 (PerformanceMonitor)
+- データ整合性チェック (DataConsistencyChecker)
+
+### 6. 障害復旧・設定管理（v1.1新設）
+- 復旧サービス (RecoveryService)
+- 設定ファイル解決 (ConfigFileResolver)
+
+## テストケース一覧
+
+| No. | カテゴリ | テスト対象 | テストケース名 | 要件ID | 優先度 | 期待結果 |
+|-----|---------|-----------|---------------|--------|--------|----------|
+| **1. 予約ID生成** |
+| U001 | BookingIdGenerator | generateBookingId | 正常な予約ID生成 | REQ-006 | High | `RES-20250115-0001` 形式で生成される |
+| U002 | BookingIdGenerator | generateBookingId | 同日連番採番 | REQ-006 | High | 同日2件目は `RES-20250115-0002` |
+| U003 | BookingIdGenerator | generateBookingId | テナント別採番 | REQ-006 | High | テナントごとに独立した連番 |
+| U004 | BookingIdGenerator | validateBookingId | 正常ID検証 | REQ-006 | Medium | `RES-20250115-0001` が true |
+| U005 | BookingIdGenerator | validateBookingId | 異常ID検証 | REQ-006 | Medium | `RES-202501150001` が false |
+| **2. 料金計算** |
+| U006 | PricingCalculator | calculate | 基本料金計算 | REQ-012 | High | 大人2名=¥6,000(税別) |
+| U007 | PricingCalculator | calculate | 混合料金計算 | REQ-012 | High | 大人2+小学生1=¥7,000+税¥700=¥7,700 |
+| U008 | PricingCalculator | calculate | 無料区分含む計算 | REQ-012 | Medium | 大人1+3歳以下1=¥3,000+税¥300=¥3,300 |
+| U009 | PricingCalculator | calculate | ゼロ人数処理 | REQ-012 | Low | 全区分0名=¥0 |
+| U010 | PricingCalculator | calculate | 税率変更対応 | REQ-012 | Medium | 税率8%設定時の正確な計算 |
+| **3. 在庫管理** |
+| U011 | InventoryService | checkAvailability | 在庫充足確認 | REQ-014 | High | 要求5名、在庫10名で true |
+| U012 | InventoryService | checkAvailability | 在庫不足確認 | REQ-014 | High | 要求15名、在庫10名で false |
+| U013 | InventoryService | lockInventory | 在庫ロック成功 | REQ-014 | High | TTL=15分でロック状態になる |
+| U014 | InventoryService | lockInventory | 在庫ロック失敗 | REQ-014 | High | 不足時に `fully_booked` エラー |
+| U015 | InventoryService | releaseInventory | 在庫開放成功 | REQ-014 | High | ロック解除され利用可能に戻る |
+| U016 | InventoryService | handleLockExpiry | TTL期限切れ処理 | REQ-014 | Medium | 15分経過で自動開放される |
+| **4. 予約サービス** |
+| U017 | BookingService | createBooking | 正常な予約作成 | REQ-003 | High | draft状態の予約が作成される |
+| U018 | BookingService | createBooking | 在庫不足時のエラー | REQ-005 | High | `fully_booked` エラーが発生 |
+| U019 | BookingService | createBooking | 人数制限超過エラー | REQ-005 | High | 21名で `invalid_argument` エラー |
+| U020 | BookingService | createBooking | 期限切れエラー | REQ-005 | High | 2時間前過ぎで `deadline_passed` エラー |
+| U021 | BookingService | confirmBooking | 決済成功時の確定 | REQ-003 | High | paid状態に遷移、在庫減算 |
+| U022 | BookingService | cancelBooking | 正常キャンセル | REQ-010 | High | cancelled状態、在庫復帰 |
+| U023 | BookingService | cancelBooking | 期限切れキャンセル | REQ-011 | High | `cancel_deadline_passed` エラー |
+| **5. Stripe連携** |
+| U024 | StripePaymentService | createPaymentIntent | PI正常作成 | REQ-007 | High | client_secret付きPIが返る |
+| U025 | StripePaymentService | createPaymentIntent | 冪等性キー重複 | REQ-007 | Medium | 同じキーで同じPIが返る |
+| U026 | StripePaymentService | processWebhook | 決済成功Webhook | REQ-008 | High | succeeded時に予約確定 |
+| U027 | StripePaymentService | processWebhook | 決済失敗Webhook | REQ-008 | High | failed時にキャンセル処理 |
+| U028 | StripePaymentService | processWebhook | 署名検証失敗 | REQ-008 | High | `webhook_invalid_signature` エラー |
+| U029 | StripePaymentService | processRefund | 返金処理成功 | REQ-010 | High | 手数料10%差引で返金実行 |
+| **6. バリデーション** |
+| U030 | InputValidator | validateBookingInput | 正常入力検証 | REQ-004 | High | 適正な人数・区分でtrue |
+| U031 | InputValidator | validateBookingInput | 負数入力検証 | REQ-004 | High | 人数-1で `invalid_argument` |
+| U032 | InputValidator | validateBookingInput | 総人数ゼロ検証 | REQ-005 | Medium | 全区分0で `invalid_argument` |
+| U033 | BusinessRuleValidator | validateBookingRules | 重複予約検証 | REQ-005 | High | 同メール同日時で false |
+| U034 | BusinessRuleValidator | validateCancelRules | キャンセル可能性検証 | REQ-011 | High | 24時間前で true |
+| **7. テナント設定** |
+| U035 | TenantConfigResolver | resolveConfig | 環境変数優先 | REQ-019 | High | env > tenant.json > default順 |
+| U036 | TenantConfigResolver | resolveConfig | デフォルト設定適用 | REQ-019 | Medium | 設定なし時にデフォルト値 |
+| U037 | TenantConfigResolver | resolveTenantId | ヘッダ優先解決 | REQ-018 | High | X-Tenant-Id > path > widget |
+| U038 | TenantConfigResolver | resolveTenantId | 不正テナントID | REQ-018 | Medium | `tenant_not_found` エラー |
+| **8. リポジトリ** |
+| U039 | BookingRepository | save | 予約保存成功 | REQ-003 | High | 予約データが永続化される |
+| U040 | BookingRepository | findById | ID検索成功 | REQ-010 | High | 正しい予約が取得される |
+| U041 | BookingRepository | findById | 存在しないID | REQ-010 | Medium | `booking_not_found` エラー |
+| U042 | InventoryRepository | updateCapacity | 在庫更新成功 | REQ-014 | High | 在庫数が正しく更新される |
+| U043 | InventoryRepository | getAvailableSlots | 利用可能枠取得 | REQ-015 | Medium | 在庫>0の枠のみ返る |
+| **9. エラーハンドリング** |
+| U044 | ErrorHandler | handleBusinessError | ビジネスエラー変換 | REQ-030 | High | 適切なエラーコードとメッセージ |
+| U045 | ErrorHandler | handleSystemError | システムエラー変換 | REQ-030 | High | 500エラーで汎用メッセージ |
+| U046 | ErrorHandler | handleStripeError | Stripeエラー変換 | REQ-030 | High | Stripe固有エラーの適切な変換 |
+| **10. 状態遷移** |
+| U047 | BookingStateMachine | transitionState | 正常状態遷移 | 付録A | High | draft→pending-payment→paid |
+| U048 | BookingStateMachine | transitionState | 不正遷移防止 | 付録A | High | paid→draft は不可 |
+| U049 | BookingStateMachine | handleTimeout | TTL期限切れ処理 | 付録A | Medium | pending→expired、在庫開放 |
+| **11. テナント設定拡張（v1.1新設）** |
+| U050 | TenantConfigResolver | resolveTenantIdConflict | テナントID競合解決 | REQ-018 | High | ヘッダ > パス > ウィジェットの順で解決 |
+| U051 | StripeWebhookValidator | validateSignatureTimeout | Webhook署名タイムアウト境界 | REQ-008 | Medium | tolerance=300秒の境界値で正確な判定 |
+| **12. データ整合性・復旧（v1.1新設）** |
+| U052 | DataConsistencyChecker | checkBookingInventory | 予約在庫整合性チェック | REQ-031 | High | 不整合データの検出と修正提案 |
+| U053 | RecoveryService | recoverInterruptedPayment | 決済中断復旧処理 | REQ-032 | High | 中断状態からの適切な復旧 |
+| **13. パフォーマンス・セキュリティ（v1.1新設）** |
+| U054 | PerformanceMonitor | measureApiResponseTime | API応答時間測定 | REQ-021 | Medium | 500ms境界での正確な測定 |
+| U055 | CryptographyService | encryptPersonalData | 個人情報暗号化 | REQ-025 | High | メールアドレスの安全な暗号化 |
+| U056 | CryptographyService | decryptPersonalData | 個人情報復号化 | REQ-025 | High | 暗号化データの正確な復号化 |
+| **14. 設定・検証（v1.1新設）** |
+| U057 | ErrorCodeValidator | validateAllErrorCodes | 全エラーコード検証 | 付録B | Medium | 13種類全てのエラーコード生--- /dev/null
+++ vitest.config.ts
@@ -0,0 +1,31 @@
+import { defineConfig } from 'vitest/config';
+import path from 'path';
+
+export default defineConfig({
+  test: {
+    globals: true,
+    environment: 'node',
+    setupFiles: ['./tests/setup/vitest.setup.ts'],
+    coverage: {
+      provider: 'c8',
+      reporter: ['text', 'json', 'html'],
+      thresholds: {
+        lines: 85,
+        branches: 85,
+        functions: 90,
+        statements: 85
+      },
+      exclude: [
+        'tests/**',
+        'dist/**',
+        '**/*.d.ts',
+        '**/*.config.*',
+        '**/node_modules/**'
+      ]
+    },
+    timeout: 5000,
+    testTimeout: 5000,
+    hookTimeout: 10000,
+    teardownTimeout: 5000,
+    maxConcurrency: 8,
+    pool: 'threads',
+    isolate: true
+  },
+  resolve: {
+    alias: {
+      '@': path.resolve(__dirname, './src'),
+      '@tests': path.resolve(__dirname, './tests')
+    }
+  },
+  define: {
+    'process.env.NODE_ENV': '"test"',
+    'process.env.VITEST': 'true'
+  }
+});
--- /dev/null
+++ playwright.config.ts
@@ -0,0 +1,67 @@
+import { defineConfig, devices } from '@playwright/test';
+
+export default defineConfig({
+  testDir: './tests/e2e',
+  fullyParallel: true,
+  forbidOnly: !!process.env.CI,
+  retries: process.env.CI ? 2 : 1,
+  workers: process.env.CI ? 2 : undefined,
+  reporter: [
+    ['html'],
+    ['json', { outputFile: 'test-results/e2e-results.json' }],
+    ['list']
+  ],
+  use: {
+    baseURL: 'http://localhost:3000',
+    trace: 'on-first-retry',
+    screenshot: 'only-on-failure',
+    video: 'retain-on-failure',
+    extraHTTPHeaders: {
+      'X-Test-Mode': 'true',
+      'X-Security-Test': 'enabled'
+    }
+  },
+  projects: [
+    {
+      name: 'chromium',
+      use: { 
+        ...devices['Desktop Chrome'],
+        viewport: { width: 1280, height: 720 }
+      },
+    },
+    {
+      name: 'firefox',
+      use: { 
+        ...devices['Desktop Firefox'],
+        viewport: { width: 1280, height: 720 }
+      },
+    },
+    {
+      name: 'webkit',
+      use: { 
+        ...devices['Desktop Safari'],
+        viewport: { width: 1280, height: 720 }
+      },
+    },
+    {
+      name: 'mobile-chrome',
+      use: { ...devices['Pixel 5'] },
+    },
+    {
+      name: 'mobile-safari',
+      use: { ...devices['iPhone 12'] },
+    },
+  ],
+  webServer: {
+    command: 'npm run dev',
+    port: 3000,
+    reuseExistingServer: !process.env.CI,
+    timeout: 120000
+  },
+  globalSetup: './tests/setup/global-setup.ts',
+  globalTeardown: './tests/setup/global-teardown.ts',
+  timeout: 300000, // 5分
+  expect: {
+    timeout: 10000
+  },
+  outputDir: 'test-results/e2e-artifacts'
+});
--- /dev/null
+++ package.json
@@ -0,0 +1,38 @@
+{
+  "name": "booking-system",
+  "version": "1.0.0",
+  "scripts": {
+    "dev": "tsx watch src/server.ts",
+    "build": "tsc && tsc-alias",
+    "start": "node dist/server.js",
+    
+    "test:unit": "vitest run",
+    "test:unit:watch": "vitest",
+    "test:unit:coverage": "vitest run --coverage",
+    
+    "test:e2e": "playwright test",
+    "test:e2e:ui": "playwright test --ui",
+    "test:e2e:debug": "playwright test --debug",
+    "test:e2e:headed": "playwright test --headed",
+    "test:e2e:chromium": "playwright test --project=chromium",
+    "test:e2e:firefox": "playwright test --project=firefox",
+    "test:e2e:webkit": "playwright test --project=webkit",
+    
+    "test:integration:stripe": "vitest run tests/integration/stripe",
+    "test:performance": "vitest run tests/performance",
+    
+    "test:all": "npm run test:unit && npm run test:e2e && npm run test:integration:stripe && npm run test:performance",
+    "test:ci": "npm run test:unit:coverage && npm run test:e2e && npm run test:integration:stripe",
+    
+    "test:reset-data": "tsx scripts/reset-test-data.ts",
+    "config:show": "tsx scripts/show-tenant-config.ts"
+  },
+  "devDependencies": {
+    "@playwright/test": "^1.40.0",
+    "@types/node": "^20.10.0",
+    "c8": "^8.0.1",
+    "tsx": "^4.6.0",
+    "typescript": "^5.3.0",
+    "vitest": "^1.0.0"
+  }
+}
--- /dev/null
+++ docs/requirements.v3.1.md
@@ -0,0 +1,805 @@
+# 要件定義書 v3.1（最終修正版）
+Web予約システム マルチテナント対応
+
+## v3→v3.1 差分サマリ
+- 予約IDフォーマットを「RES-YYYYMMDD-####」（17文字固定）に統一
+- 税の扱いを「単価=税別、最終金額=税込」で一意化し、計算式を明確化
+- テナント識別の経路別優先順位を明文化（ヘッダ > パス > ウィジェット）
+- 在庫ロック状態遷移表とTTL=15分固定を追加
+- Stripeの冪等性キーとWebhook署名検証仕様を明記
+- E2EテストブラウザをWebKitに統一（Safari→WebKit）
+- エラーコード表とHTTPステータス対応を追加
+- テスト用固定データの出所（tenant JSON）と設定優先順位を明文化
+
+---
+
+## 1. プロジェクト概要
+
+### REQ-001: プロジェクト目的
+小規模（50席以下）〜中規模（500席以下）のイベントや店舗で使えるWeb予約システムを構築し、複数のクライアント（テナント）が独立した設定で利用できるマルチテナント対応システムとして提供する。
+
+### REQ-002: 主な利用者
+- **一般ユーザー（予約者）**: 予約作成、キャンセル要求を行う
+- **管理者**: 枠設定、在庫管理、キャンセル承認、料金設定を行う
+
+## 2. 機能要件
+
+### 2.1 予約機能
+
+#### REQ-003: 予約フロー
+システムは以下の順序で予約処理を実行し、各ステップでバリデーションエラー時は前ステップに戻る：
+1. **日付選択**: 利用可能日付のみ選択可能（在庫0の日付は `data-test="date-unavailable"` 属性で非活性表示）
+2. **時間枠選択**: 選択日付で利用可能な時間枠のみ表示（在庫0の枠は `data-test="slot-unavailable"` で非活性）
+3. **人数・区分入力**: 各区分の人数を0以上の整数で入力（`data-test="count-{category}"` で識別）
+4. **見積表示**: リアルタイム金額計算結果を `data-test="price-total"` に表示
+5. **在庫確認**: 入力人数が在庫数以下であることを確認（`data-test="inventory-check"` で状態表示）
+6. **決済画面**: Stripe PaymentIntentを作成し `data-test="payment-form"` で決済フォーム表示
+7. **予約確定**: 決済成功時のみ在庫減算・予約ID発行（`data-test="booking-confirmed"` に予約ID表示）
+
+**テスト容易性のための設計:**
+- 各ステップの状態を `data-test="step-{number}-{status}"` 属性で表現
+- エラー状態は `data-test="error-{error-type}"` で識別可能
+- ローディング状態は `data-test="loading-{action}"` で表現
+
+#### REQ-004: 人数区分と料金
+システムは以下の人数区分を提供し、各区分の料金は管理者が設定可能：
+- **大人**: 13歳以上、デフォルト料金3000円（税別）（`data-test="category-adult"`）
+- **中学生**: 13-15歳、デフォルト料金2000円（税別）（`data-test="category-junior"`）
+- **小学生〜4歳**: 4-12歳、デフォルト料金1000円（税別）（`data-test="category-child"`）
+- **3歳以下**: 0-3歳、デフォルト料金0円（税別）（`data-test="category-infant"`）
+
+**テストデータ固定:**
+- テスト環境では料金表を固定値で提供
+- 料金変更テスト用に専用のテストテナント（`test-tenant-pricing`）を用意
+
+#### REQ-005: 予約制限
+- **同時予約数制限**: 1回の予約で最大20名まで（`data-test="max-capacity-error"` でエラー表示）
+- **予約受付期限**: 利用日の2時間前まで受付（`data-test="deadline-passed"` でエラー表示）
+- **重複予約制限**: 同一メールアドレスでの同一日時重複予約は禁止（`data-test="duplicate-booking-error"`）
+
+#### REQ-006: 予約ID仕様
+システムは以下の仕様で予約IDを生成・管理する：
+- **フォーマット**: `RES-YYYYMMDD-####`（例：RES-20250115-0001）
+- **構成**: 接頭辞（3文字）+ ハイフン + 日付（8文字）+ ハイフン + 連番（4桁ゼロパディング）
+- **文字数**: 17文字固定
+- **バリデーション条件**:
+  - 接頭辞は "RES" 固定
+  - 日付は予約対象日（利用日）のYYYYMMDD形式
+  - 連番は1から開始、テナント×日付単位で採番
+  - 使用文字は英数字とハイフンのみ
+
+### 2.2 決済機能
+
+#### REQ-007: Stripe決済フロー詳細
+システムはStripe PaymentIntent APIを使用し以下の手順で決済処理：
+1. **PaymentIntent作成**: サーバー側で金額・通貨（JPY）を指定してPI作成（`data-test="payment-intent-created"`）
+   - Idempotency-Key必須（予約draft ID基準）
+2. **クライアント秘密鍵送信**: client_secretをフロントエンドに送信
+3. **決済フォーム表示**: Stripe Elementsで決済フォーム表示（`data-test="stripe-form"`）
+4. **決済実行**: confirmCardPayment()で決済処理（`data-test="payment-processing"`）
+5. **結果確認**: Webhookで決済完了を確認し予約確定（`data-test="payment-success"`）
+
+**冪等性保証:**
+- **POST /reservations**: Idempotency-Key必須（クライアント生成UUID）
+- **POST /payments/intent**: Idempotency-Key必須（予約ID+決済試行回数）
+
+**テスト環境対応:**
+- E2Eテスト用FakeStripeAdapter実装
+- テストカード番号（4242424242424242）での決済成功パターン
+- エラーカード番号（4000000000000002）での決済失敗パターン
+
+#### REQ-008: Webhook処理仕様
+- **署名検証**: `stripe-signature` ヘッダーの検証（tolerance=300秒）
+- **重複処理防止**: イベントIDによる冪等性保証
+- **処理対象イベント**: `payment_intent.succeeded`, `payment_intent.payment_failed`
+- **タイムアウト**: Webhook処理は10秒以内に完了、それ以外は手動確認フロー
+
+#### REQ-009: 決済エラーハンドリング
+- **カード拒否**: `data-test="payment-error-declined"` でエラーメッセージ表示
+- **ネットワークエラー**: `data-test="payment-error-network"` で3回まで自動リトライ
+- **Webhook遅延**: `data-test="payment-pending"` で10秒以内にWebhook未受信時は手動確認フローへ誘導
+- **決済タイムアウト**: `data-test="payment-timeout"` で15分で決済セッション無効化
+
+### 2.3 キャンセル機能
+
+#### REQ-010: キャンセル処理フロー
+システムは以下の手順でキャンセル処理を実行：
+1. **予約ID検索**: 17文字の予約ID（RES-YYYYMMDD-#### 形式）で予約検索（`data-test="booking-search"`）
+2. **キャンセル可能性確認**: 利用日の24時間前まで、未キャンセル状態（`data-test="cancel-eligible"`）
+3. **在庫復帰**: キャンセル実行時に該当枠の在庫数を増加（`data-test="inventory-restored"`）
+4. **返金処理**: Stripe Refund APIで自動返金実行（`data-test="refund-processed"`）
+5. **通知送信**: キャンセル完了メールを送信（`data-test="cancel-notification"`）
+
+**テスト環境での固定データ:**
+- テスト用予約ID: `RES-20250115-0001`（キャンセル可能）, `RES-20250115-0002`（期限切れ）
+- 固定日時: 2025-01-15 14:00（テスト実行日+7日で調整）
+
+#### REQ-011: キャンセル制限
+- **期限制限**: 利用日の24時間前まで（`data-test="cancel-deadline-passed"`）
+- **返金手数料**: キャンセル手数料として決済金額の10%を差し引き（`data-test="refund-fee"`）
+- **部分キャンセル**: 人数減のみの部分キャンセルは不可（`data-test="partial-cancel-disabled"`）
+
+### 2.4 見積・料金機能
+
+#### REQ-012: 料金計算ロジック
+システムは以下のロジックで料金を算出（**単価=税別、最終金額=税込**）：
+```
+小計（税別） = Σ(各区分人数 × 各区分単価（税別）)
+消費税額 = 小計 × 税率（デフォルト10%）
+合計金額（税込） = 小計 + 消費税額
+```
+
+**計算例（大人2名、小学生1名の場合）:**
+```
+大人: 2名 × 3,000円 = 6,000円
+小学生: 1名 × 1,000円 = 1,000円
+小計（税別）: 7,000円
+消費税（10%）: 700円  
+合計（税込）: 7,700円
+```
+
+**計算結果の表示:**
+- `data-test="price-breakdown"`: 各区分の小計表示
+- `data-test="price-subtotal"`: 税別合計
+- `data-test="price-tax"`: 消費税額
+- `data-test="price-total"`: 最終金額（税込）
+
+#### REQ-013: 動的料金表示
+- **リアルタイム更新**: 人数変更時に即座に金額更新（debounce 300ms）
+- **内訳表示**: 各区分の小計と合計を分けて表示
+- **通貨表示**: 日本円（¥）表記、3桁区切りカンマ付き（`data-test="currency-jpy"`）
+
+### 2.5 在庫・枠管理機能
+
+#### REQ-014: 在庫管理
+- **在庫単位**: 日付×時間枠×総定員数で管理（`data-test="inventory-{date}-{slot}"`）
+- **在庫確認**: 予約確定前に在庫不足チェック（同時アクセス考慮、楽観的ロック使用）
+- **在庫ロック**: 決済開始から完了まで一時的に在庫を仮押さえ（TTL=15分固定、`data-test="inventory-locked"`）
+- **在庫復帰**: キャンセル時、決済失敗時、タイムアウト時に自動復帰（`data-test="inventory-released"`）
+
+**テスト用固定在庫:**
+- 2025-01-15 14:00-14:30: 定員20名（テスト開始時在庫15名）
+- 2025-01-15 15:00-15:30: 定員30名（テスト開始時在庫0名）
+
+#### REQ-015: 時間枠設定
+- **枠管理**: 30分単位で時間枠を設定可能（`data-test="slot-duration-30"`）
+- **定員設定**: 各時間枠に個別の定員数設定可能（1-500名、`data-test="capacity-input"`）
+- **公開制御**: 管理者が枠ごとに公開/非公開を切り替え可能（`data-test="slot-visibility"`）
+
+### 2.6 管理機能
+
+#### REQ-016: 管理者ダッシュボード
+システムは管理者に以下の管理機能を提供：
+- **予約一覧**: 日付・時間・ステータスでフィルタリング可能（`data-test="booking-list"`）
+- **在庫状況**: リアルタイムの在庫状況をグラフ表示（`data-test="inventory-chart"`）
+- **売上レポート**: 日別・月別売上集計（`data-test="sales-report"`）
+- **設定管理**: 料金・枠・ブランド設定の変更（`data-test="admin-settings"`）
+
+#### REQ-017: ブランド設定
+各テナントが以下をカスタマイズ可能（`data-test="brand-settings"`）：
+- **ロゴ画像**: 200x100px以下のPNG/JPGファイル（`data-test="logo-upload"`）
+- **カラーテーマ**: プライマリ色（16進数カラーコード、`data-test="color-picker"`）
+- **サイト名称**: 50文字以内の文字列（`data-test="site-name"`）
+- **利用規約URL**: 有効なHTTPS URL（`data-test="terms-url"`）
+
+## 3. マルチテナント要件
+
+### REQ-018: テナント識別方式
+システムは以下の3つの経路でテナントIDを取得し、競合時は優先順位に従う：
+
+**識別経路（優先順位順）:**
+1. **APIヘッダ**: `X-Tenant-Id: {tenantId}` （最優先）
+2. **URLパス**: `/tenant/{tenantId}/booking` （2番目）
+3. **ウィジェット属性**: `data-tenant="{tenantId}"` （最後）
+
+**テナントID仕様:**
+- **形式**: 英数字4-20文字の一意識別子（例：shop001, event_abc）
+- **使用場面**: URL構造 `/tenant/{tenantId}/booking` でアクセス（`data-test="tenant-{tenantId}"`）
+- **データ分離**: 全データをtenantIdで論理分離
+
+**テスト用テナント:**
+- `test-tenant-basic`: 基本機能テスト用
+- `test-tenant-custom`: カスタマイズ機能テスト用
+- `test-tenant-error`: エラーケーステスト用
+
+### REQ-019: テナント別設定管理
+システムは各テナント独立で以下を管理：
+- **料金表**: 4区分の単価設定（0-50000円の範囲、税別、`data-test="pricing-config"`）
+- **営業時間**: 開始時刻・終了時刻・休業日設定（`data-test="hours-config"`）
+- **キャンセル規定**: キャンセル期限・手数料率（0-50%、`data-test="cancel-policy"`）
+- **言語設定**: ja/en切り替え（`data-test="language-selector"`）
+- **タイムゾーン**: Asia/Tokyo固定（将来拡張可能）
+- **Stripeキー**: テナント別のStripe秘密鍵・公開鍵
+
+### REQ-020: 埋め込みウィジェット
+フロントエンドは以下の形式でWebサイトに埋め込み可能：
+```html
+<div id="booking-widget" data-test="widget-container"></div>
+<script src="https://example.com/widget.js" 
+        data-tenant="tenant001"
+        data-theme="light"
+        data-test="widget-script"></script>
+```
+
+## 4. 非機能要件
+
+### 4.1 パフォーマンス要件
+
+#### REQ-021: レスポンス時間
+- **API応答時間**: 95%のリクエストが500ms以内（`performance.now()` で測定）
+- **ページ表示時間**: 初回ロードが3秒以内（`data-test="page-load-complete"` で完了判定）
+- **決済処理時間**: PaymentIntent作成が2秒以内（`data-test="payment-intent-ready"`）
+
+#### REQ-022: 同時利用者数
+- **同時接続数**: テナントあたり100セッション
+- **同時予約処理**: テナントあたり10件/秒の予約処理が可能
+
+### 4.2 可用性要件
+
+#### REQ-023: サービス稼働率
+- **稼働率**: 99.5%以上（月間ダウンタイム3.6時間以下）
+- **メンテナンス時間**: 計画メンテナンスは深夜2-4時のみ
+
+### 4.3 セキュリティ要件
+
+#### REQ-024: 認証・認可
+- **管理者認証**: JWT トークンベース認証（`data-test="auth-token"`）
+- **API アクセス制御**: テナントID による API アクセス制限
+- **HTTPS通信**: 全通信をHTTPS暗号化
+
+#### REQ-025: データ保護
+- **個人情報保護**: 予約者のメールアドレス・決済情報の暗号化保存
+- **Stripe鍵管理**: 環境変数での秘密鍵管理、ログ出力除外
+- **SQL インジェクション対策**: パラメータ化クエリの使用
+
+### 4.4 運用・保守要件
+
+#### REQ-026: ログ・監視
+- **アクセスログ**: 全APIアクセスをJSONフォーマットで記録
+- **エラーログ**: エラー発生時のスタックトレース記録
+- **決済ログ**: Stripe Webhook受信・返金処理の詳細ログ
+
+#### REQ-027: バックアップ
+- **データバックアップ**: 日次で全予約・設定データをバックアップ
+- **復旧時間**: 障害発生から1時間以内の復旧
+
+### 4.5 技術要件
+
+#### REQ-028: 開発環境
+- **実装言語**: Node.js 20.x + TypeScript 5.x
+- **フレームワーク**: Express.js (API), React (フロントエンド)
+- **データストレージ**: 初期はインメモリ（Map/Set）、DB移行可能な抽象化
+- **決済連携**: Stripe API v2023-10-16
+
+#### REQ-029: テスト要件
+- **単体テスト**: Vitest、カバレッジ80%以上
+- **E2Eテスト**: Playwright、主要フロー網羅
+- **決済テスト**: E2EはFakeAdapter、統合テストはStripe Test環境
+
+## 5. 異常系・例外処理
+
+### REQ-030: システムエラー処理
+- **API エラー**: 500エラー時は汎用エラーメッセージ表示（`data-test="error-500"`）
+- **Stripe エラー**: カード拒否、限度額超過等の具体的エラー表示（`data-test="stripe-error-{type}"`）
+- **ネットワーク障害**: オフライン検知時は再試行ボタン表示（`data-test="retry-button"`）
+
+### REQ-031: データ整合性
+- **在庫不足**: 決済直前の在庫再チェックで不足時は決済中止（`data-test="inventory-conflict"`）
+- **重複決済**: 同一PaymentIntentの重複処理を防止（`data-test="duplicate-payment"`）
+- **データ破損**: 予約・在庫データの整合性チェック機能
+
+### REQ-032: 障害復旧
+- **決済中断**: 決済途中でのブラウザ終了・ネットワーク切断からの復旧
+- **Webhook遅延**: Webhook未受信時の手動同期機能（`data-test="manual-sync"`）
+- **在庫ロック開放**: タイムアウト時の自動ロック開放（`data-test="lock-expired"`）
+
+## 6. 制約・除外事項
+
+### REQ-033: スコープ外機能（明確化）
+以下の機能は明確に初期スコープから除外：
+- **多通貨対応**: JPY以外の通貨
+- **税
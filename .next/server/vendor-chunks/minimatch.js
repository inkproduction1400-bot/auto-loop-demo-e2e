"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/minimatch";
exports.ids = ["vendor-chunks/minimatch"];
exports.modules = {

/***/ "(ssr)/./node_modules/minimatch/dist/commonjs/assert-valid-pattern.js":
/*!**********************************************************************!*\
  !*** ./node_modules/minimatch/dist/commonjs/assert-valid-pattern.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.assertValidPattern = void 0;\nconst MAX_PATTERN_LENGTH = 1024 * 64;\nconst assertValidPattern = (pattern) => {\n    if (typeof pattern !== 'string') {\n        throw new TypeError('invalid pattern');\n    }\n    if (pattern.length > MAX_PATTERN_LENGTH) {\n        throw new TypeError('pattern is too long');\n    }\n};\nexports.assertValidPattern = assertValidPattern;\n//# sourceMappingURL=assert-valid-pattern.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbWluaW1hdGNoL2Rpc3QvY29tbW9uanMvYXNzZXJ0LXZhbGlkLXBhdHRlcm4uanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQiIsInNvdXJjZXMiOlsid2VicGFjazovL2F1dG8tbG9vcC1kZW1vLy4vbm9kZV9tb2R1bGVzL21pbmltYXRjaC9kaXN0L2NvbW1vbmpzL2Fzc2VydC12YWxpZC1wYXR0ZXJuLmpzP2JkYTEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmFzc2VydFZhbGlkUGF0dGVybiA9IHZvaWQgMDtcbmNvbnN0IE1BWF9QQVRURVJOX0xFTkdUSCA9IDEwMjQgKiA2NDtcbmNvbnN0IGFzc2VydFZhbGlkUGF0dGVybiA9IChwYXR0ZXJuKSA9PiB7XG4gICAgaWYgKHR5cGVvZiBwYXR0ZXJuICE9PSAnc3RyaW5nJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHBhdHRlcm4nKTtcbiAgICB9XG4gICAgaWYgKHBhdHRlcm4ubGVuZ3RoID4gTUFYX1BBVFRFUk5fTEVOR1RIKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3BhdHRlcm4gaXMgdG9vIGxvbmcnKTtcbiAgICB9XG59O1xuZXhwb3J0cy5hc3NlcnRWYWxpZFBhdHRlcm4gPSBhc3NlcnRWYWxpZFBhdHRlcm47XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hc3NlcnQtdmFsaWQtcGF0dGVybi5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/minimatch/dist/commonjs/assert-valid-pattern.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/minimatch/dist/commonjs/ast.js":
/*!*****************************************************!*\
  !*** ./node_modules/minimatch/dist/commonjs/ast.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n// parse a single path portion\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.AST = void 0;\nconst brace_expressions_js_1 = __webpack_require__(/*! ./brace-expressions.js */ \"(ssr)/./node_modules/minimatch/dist/commonjs/brace-expressions.js\");\nconst unescape_js_1 = __webpack_require__(/*! ./unescape.js */ \"(ssr)/./node_modules/minimatch/dist/commonjs/unescape.js\");\nconst types = new Set(['!', '?', '+', '*', '@']);\nconst isExtglobType = (c) => types.has(c);\n// Patterns that get prepended to bind to the start of either the\n// entire string, or just a single path portion, to prevent dots\n// and/or traversal patterns, when needed.\n// Exts don't need the ^ or / bit, because the root binds that already.\nconst startNoTraversal = '(?!(?:^|/)\\\\.\\\\.?(?:$|/))';\nconst startNoDot = '(?!\\\\.)';\n// characters that indicate a start of pattern needs the \"no dots\" bit,\n// because a dot *might* be matched. ( is not in the list, because in\n// the case of a child extglob, it will handle the prevention itself.\nconst addPatternStart = new Set(['[', '.']);\n// cases where traversal is A-OK, no dot prevention needed\nconst justDots = new Set(['..', '.']);\nconst reSpecials = new Set('().*{}+?[]^$\\\\!');\nconst regExpEscape = (s) => s.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, '\\\\$&');\n// any single thing other than /\nconst qmark = '[^/]';\n// * => any number of characters\nconst star = qmark + '*?';\n// use + when we need to ensure that *something* matches, because the * is\n// the only thing in the path portion.\nconst starNoEmpty = qmark + '+?';\n// remove the \\ chars that we added if we end up doing a nonmagic compare\n// const deslash = (s: string) => s.replace(/\\\\(.)/g, '$1')\nclass AST {\n    type;\n    #root;\n    #hasMagic;\n    #uflag = false;\n    #parts = [];\n    #parent;\n    #parentIndex;\n    #negs;\n    #filledNegs = false;\n    #options;\n    #toString;\n    // set to true if it's an extglob with no children\n    // (which really means one child of '')\n    #emptyExt = false;\n    constructor(type, parent, options = {}) {\n        this.type = type;\n        // extglobs are inherently magical\n        if (type)\n            this.#hasMagic = true;\n        this.#parent = parent;\n        this.#root = this.#parent ? this.#parent.#root : this;\n        this.#options = this.#root === this ? options : this.#root.#options;\n        this.#negs = this.#root === this ? [] : this.#root.#negs;\n        if (type === '!' && !this.#root.#filledNegs)\n            this.#negs.push(this);\n        this.#parentIndex = this.#parent ? this.#parent.#parts.length : 0;\n    }\n    get hasMagic() {\n        /* c8 ignore start */\n        if (this.#hasMagic !== undefined)\n            return this.#hasMagic;\n        /* c8 ignore stop */\n        for (const p of this.#parts) {\n            if (typeof p === 'string')\n                continue;\n            if (p.type || p.hasMagic)\n                return (this.#hasMagic = true);\n        }\n        // note: will be undefined until we generate the regexp src and find out\n        return this.#hasMagic;\n    }\n    // reconstructs the pattern\n    toString() {\n        if (this.#toString !== undefined)\n            return this.#toString;\n        if (!this.type) {\n            return (this.#toString = this.#parts.map(p => String(p)).join(''));\n        }\n        else {\n            return (this.#toString =\n                this.type + '(' + this.#parts.map(p => String(p)).join('|') + ')');\n        }\n    }\n    #fillNegs() {\n        /* c8 ignore start */\n        if (this !== this.#root)\n            throw new Error('should only call on root');\n        if (this.#filledNegs)\n            return this;\n        /* c8 ignore stop */\n        // call toString() once to fill this out\n        this.toString();\n        this.#filledNegs = true;\n        let n;\n        while ((n = this.#negs.pop())) {\n            if (n.type !== '!')\n                continue;\n            // walk up the tree, appending everthing that comes AFTER parentIndex\n            let p = n;\n            let pp = p.#parent;\n            while (pp) {\n                for (let i = p.#parentIndex + 1; !pp.type && i < pp.#parts.length; i++) {\n                    for (const part of n.#parts) {\n                        /* c8 ignore start */\n                        if (typeof part === 'string') {\n                            throw new Error('string part in extglob AST??');\n                        }\n                        /* c8 ignore stop */\n                        part.copyIn(pp.#parts[i]);\n                    }\n                }\n                p = pp;\n                pp = p.#parent;\n            }\n        }\n        return this;\n    }\n    push(...parts) {\n        for (const p of parts) {\n            if (p === '')\n                continue;\n            /* c8 ignore start */\n            if (typeof p !== 'string' && !(p instanceof AST && p.#parent === this)) {\n                throw new Error('invalid part: ' + p);\n            }\n            /* c8 ignore stop */\n            this.#parts.push(p);\n        }\n    }\n    toJSON() {\n        const ret = this.type === null\n            ? this.#parts.slice().map(p => (typeof p === 'string' ? p : p.toJSON()))\n            : [this.type, ...this.#parts.map(p => p.toJSON())];\n        if (this.isStart() && !this.type)\n            ret.unshift([]);\n        if (this.isEnd() &&\n            (this === this.#root ||\n                (this.#root.#filledNegs && this.#parent?.type === '!'))) {\n            ret.push({});\n        }\n        return ret;\n    }\n    isStart() {\n        if (this.#root === this)\n            return true;\n        // if (this.type) return !!this.#parent?.isStart()\n        if (!this.#parent?.isStart())\n            return false;\n        if (this.#parentIndex === 0)\n            return true;\n        // if everything AHEAD of this is a negation, then it's still the \"start\"\n        const p = this.#parent;\n        for (let i = 0; i < this.#parentIndex; i++) {\n            const pp = p.#parts[i];\n            if (!(pp instanceof AST && pp.type === '!')) {\n                return false;\n            }\n        }\n        return true;\n    }\n    isEnd() {\n        if (this.#root === this)\n            return true;\n        if (this.#parent?.type === '!')\n            return true;\n        if (!this.#parent?.isEnd())\n            return false;\n        if (!this.type)\n            return this.#parent?.isEnd();\n        // if not root, it'll always have a parent\n        /* c8 ignore start */\n        const pl = this.#parent ? this.#parent.#parts.length : 0;\n        /* c8 ignore stop */\n        return this.#parentIndex === pl - 1;\n    }\n    copyIn(part) {\n        if (typeof part === 'string')\n            this.push(part);\n        else\n            this.push(part.clone(this));\n    }\n    clone(parent) {\n        const c = new AST(this.type, parent);\n        for (const p of this.#parts) {\n            c.copyIn(p);\n        }\n        return c;\n    }\n    static #parseAST(str, ast, pos, opt) {\n        let escaping = false;\n        let inBrace = false;\n        let braceStart = -1;\n        let braceNeg = false;\n        if (ast.type === null) {\n            // outside of a extglob, append until we find a start\n            let i = pos;\n            let acc = '';\n            while (i < str.length) {\n                const c = str.charAt(i++);\n                // still accumulate escapes at this point, but we do ignore\n                // starts that are escaped\n                if (escaping || c === '\\\\') {\n                    escaping = !escaping;\n                    acc += c;\n                    continue;\n                }\n                if (inBrace) {\n                    if (i === braceStart + 1) {\n                        if (c === '^' || c === '!') {\n                            braceNeg = true;\n                        }\n                    }\n                    else if (c === ']' && !(i === braceStart + 2 && braceNeg)) {\n                        inBrace = false;\n                    }\n                    acc += c;\n                    continue;\n                }\n                else if (c === '[') {\n                    inBrace = true;\n                    braceStart = i;\n                    braceNeg = false;\n                    acc += c;\n                    continue;\n                }\n                if (!opt.noext && isExtglobType(c) && str.charAt(i) === '(') {\n                    ast.push(acc);\n                    acc = '';\n                    const ext = new AST(c, ast);\n                    i = AST.#parseAST(str, ext, i, opt);\n                    ast.push(ext);\n                    continue;\n                }\n                acc += c;\n            }\n            ast.push(acc);\n            return i;\n        }\n        // some kind of extglob, pos is at the (\n        // find the next | or )\n        let i = pos + 1;\n        let part = new AST(null, ast);\n        const parts = [];\n        let acc = '';\n        while (i < str.length) {\n            const c = str.charAt(i++);\n            // still accumulate escapes at this point, but we do ignore\n            // starts that are escaped\n            if (escaping || c === '\\\\') {\n                escaping = !escaping;\n                acc += c;\n                continue;\n            }\n            if (inBrace) {\n                if (i === braceStart + 1) {\n                    if (c === '^' || c === '!') {\n                        braceNeg = true;\n                    }\n                }\n                else if (c === ']' && !(i === braceStart + 2 && braceNeg)) {\n                    inBrace = false;\n                }\n                acc += c;\n                continue;\n            }\n            else if (c === '[') {\n                inBrace = true;\n                braceStart = i;\n                braceNeg = false;\n                acc += c;\n                continue;\n            }\n            if (isExtglobType(c) && str.charAt(i) === '(') {\n                part.push(acc);\n                acc = '';\n                const ext = new AST(c, part);\n                part.push(ext);\n                i = AST.#parseAST(str, ext, i, opt);\n                continue;\n            }\n            if (c === '|') {\n                part.push(acc);\n                acc = '';\n                parts.push(part);\n                part = new AST(null, ast);\n                continue;\n            }\n            if (c === ')') {\n                if (acc === '' && ast.#parts.length === 0) {\n                    ast.#emptyExt = true;\n                }\n                part.push(acc);\n                acc = '';\n                ast.push(...parts, part);\n                return i;\n            }\n            acc += c;\n        }\n        // unfinished extglob\n        // if we got here, it was a malformed extglob! not an extglob, but\n        // maybe something else in there.\n        ast.type = null;\n        ast.#hasMagic = undefined;\n        ast.#parts = [str.substring(pos - 1)];\n        return i;\n    }\n    static fromGlob(pattern, options = {}) {\n        const ast = new AST(null, undefined, options);\n        AST.#parseAST(pattern, ast, 0, options);\n        return ast;\n    }\n    // returns the regular expression if there's magic, or the unescaped\n    // string if not.\n    toMMPattern() {\n        // should only be called on root\n        /* c8 ignore start */\n        if (this !== this.#root)\n            return this.#root.toMMPattern();\n        /* c8 ignore stop */\n        const glob = this.toString();\n        const [re, body, hasMagic, uflag] = this.toRegExpSource();\n        // if we're in nocase mode, and not nocaseMagicOnly, then we do\n        // still need a regular expression if we have to case-insensitively\n        // match capital/lowercase characters.\n        const anyMagic = hasMagic ||\n            this.#hasMagic ||\n            (this.#options.nocase &&\n                !this.#options.nocaseMagicOnly &&\n                glob.toUpperCase() !== glob.toLowerCase());\n        if (!anyMagic) {\n            return body;\n        }\n        const flags = (this.#options.nocase ? 'i' : '') + (uflag ? 'u' : '');\n        return Object.assign(new RegExp(`^${re}$`, flags), {\n            _src: re,\n            _glob: glob,\n        });\n    }\n    get options() {\n        return this.#options;\n    }\n    // returns the string match, the regexp source, whether there's magic\n    // in the regexp (so a regular expression is required) and whether or\n    // not the uflag is needed for the regular expression (for posix classes)\n    // TODO: instead of injecting the start/end at this point, just return\n    // the BODY of the regexp, along with the start/end portions suitable\n    // for binding the start/end in either a joined full-path makeRe context\n    // (where we bind to (^|/), or a standalone matchPart context (where\n    // we bind to ^, and not /).  Otherwise slashes get duped!\n    //\n    // In part-matching mode, the start is:\n    // - if not isStart: nothing\n    // - if traversal possible, but not allowed: ^(?!\\.\\.?$)\n    // - if dots allowed or not possible: ^\n    // - if dots possible and not allowed: ^(?!\\.)\n    // end is:\n    // - if not isEnd(): nothing\n    // - else: $\n    //\n    // In full-path matching mode, we put the slash at the START of the\n    // pattern, so start is:\n    // - if first pattern: same as part-matching mode\n    // - if not isStart(): nothing\n    // - if traversal possible, but not allowed: /(?!\\.\\.?(?:$|/))\n    // - if dots allowed or not possible: /\n    // - if dots possible and not allowed: /(?!\\.)\n    // end is:\n    // - if last pattern, same as part-matching mode\n    // - else nothing\n    //\n    // Always put the (?:$|/) on negated tails, though, because that has to be\n    // there to bind the end of the negated pattern portion, and it's easier to\n    // just stick it in now rather than try to inject it later in the middle of\n    // the pattern.\n    //\n    // We can just always return the same end, and leave it up to the caller\n    // to know whether it's going to be used joined or in parts.\n    // And, if the start is adjusted slightly, can do the same there:\n    // - if not isStart: nothing\n    // - if traversal possible, but not allowed: (?:/|^)(?!\\.\\.?$)\n    // - if dots allowed or not possible: (?:/|^)\n    // - if dots possible and not allowed: (?:/|^)(?!\\.)\n    //\n    // But it's better to have a simpler binding without a conditional, for\n    // performance, so probably better to return both start options.\n    //\n    // Then the caller just ignores the end if it's not the first pattern,\n    // and the start always gets applied.\n    //\n    // But that's always going to be $ if it's the ending pattern, or nothing,\n    // so the caller can just attach $ at the end of the pattern when building.\n    //\n    // So the todo is:\n    // - better detect what kind of start is needed\n    // - return both flavors of starting pattern\n    // - attach $ at the end of the pattern when creating the actual RegExp\n    //\n    // Ah, but wait, no, that all only applies to the root when the first pattern\n    // is not an extglob. If the first pattern IS an extglob, then we need all\n    // that dot prevention biz to live in the extglob portions, because eg\n    // +(*|.x*) can match .xy but not .yx.\n    //\n    // So, return the two flavors if it's #root and the first child is not an\n    // AST, otherwise leave it to the child AST to handle it, and there,\n    // use the (?:^|/) style of start binding.\n    //\n    // Even simplified further:\n    // - Since the start for a join is eg /(?!\\.) and the start for a part\n    // is ^(?!\\.), we can just prepend (?!\\.) to the pattern (either root\n    // or start or whatever) and prepend ^ or / at the Regexp construction.\n    toRegExpSource(allowDot) {\n        const dot = allowDot ?? !!this.#options.dot;\n        if (this.#root === this)\n            this.#fillNegs();\n        if (!this.type) {\n            const noEmpty = this.isStart() && this.isEnd();\n            const src = this.#parts\n                .map(p => {\n                const [re, _, hasMagic, uflag] = typeof p === 'string'\n                    ? AST.#parseGlob(p, this.#hasMagic, noEmpty)\n                    : p.toRegExpSource(allowDot);\n                this.#hasMagic = this.#hasMagic || hasMagic;\n                this.#uflag = this.#uflag || uflag;\n                return re;\n            })\n                .join('');\n            let start = '';\n            if (this.isStart()) {\n                if (typeof this.#parts[0] === 'string') {\n                    // this is the string that will match the start of the pattern,\n                    // so we need to protect against dots and such.\n                    // '.' and '..' cannot match unless the pattern is that exactly,\n                    // even if it starts with . or dot:true is set.\n                    const dotTravAllowed = this.#parts.length === 1 && justDots.has(this.#parts[0]);\n                    if (!dotTravAllowed) {\n                        const aps = addPatternStart;\n                        // check if we have a possibility of matching . or ..,\n                        // and prevent that.\n                        const needNoTrav = \n                        // dots are allowed, and the pattern starts with [ or .\n                        (dot && aps.has(src.charAt(0))) ||\n                            // the pattern starts with \\., and then [ or .\n                            (src.startsWith('\\\\.') && aps.has(src.charAt(2))) ||\n                            // the pattern starts with \\.\\., and then [ or .\n                            (src.startsWith('\\\\.\\\\.') && aps.has(src.charAt(4)));\n                        // no need to prevent dots if it can't match a dot, or if a\n                        // sub-pattern will be preventing it anyway.\n                        const needNoDot = !dot && !allowDot && aps.has(src.charAt(0));\n                        start = needNoTrav ? startNoTraversal : needNoDot ? startNoDot : '';\n                    }\n                }\n            }\n            // append the \"end of path portion\" pattern to negation tails\n            let end = '';\n            if (this.isEnd() &&\n                this.#root.#filledNegs &&\n                this.#parent?.type === '!') {\n                end = '(?:$|\\\\/)';\n            }\n            const final = start + src + end;\n            return [\n                final,\n                (0, unescape_js_1.unescape)(src),\n                (this.#hasMagic = !!this.#hasMagic),\n                this.#uflag,\n            ];\n        }\n        // We need to calculate the body *twice* if it's a repeat pattern\n        // at the start, once in nodot mode, then again in dot mode, so a\n        // pattern like *(?) can match 'x.y'\n        const repeated = this.type === '*' || this.type === '+';\n        // some kind of extglob\n        const start = this.type === '!' ? '(?:(?!(?:' : '(?:';\n        let body = this.#partsToRegExp(dot);\n        if (this.isStart() && this.isEnd() && !body && this.type !== '!') {\n            // invalid extglob, has to at least be *something* present, if it's\n            // the entire path portion.\n            const s = this.toString();\n            this.#parts = [s];\n            this.type = null;\n            this.#hasMagic = undefined;\n            return [s, (0, unescape_js_1.unescape)(this.toString()), false, false];\n        }\n        // XXX abstract out this map method\n        let bodyDotAllowed = !repeated || allowDot || dot || !startNoDot\n            ? ''\n            : this.#partsToRegExp(true);\n        if (bodyDotAllowed === body) {\n            bodyDotAllowed = '';\n        }\n        if (bodyDotAllowed) {\n            body = `(?:${body})(?:${bodyDotAllowed})*?`;\n        }\n        // an empty !() is exactly equivalent to a starNoEmpty\n        let final = '';\n        if (this.type === '!' && this.#emptyExt) {\n            final = (this.isStart() && !dot ? startNoDot : '') + starNoEmpty;\n        }\n        else {\n            const close = this.type === '!'\n                ? // !() must match something,but !(x) can match ''\n                    '))' +\n                        (this.isStart() && !dot && !allowDot ? startNoDot : '') +\n                        star +\n                        ')'\n                : this.type === '@'\n                    ? ')'\n                    : this.type === '?'\n                        ? ')?'\n                        : this.type === '+' && bodyDotAllowed\n                            ? ')'\n                            : this.type === '*' && bodyDotAllowed\n                                ? `)?`\n                                : `)${this.type}`;\n            final = start + body + close;\n        }\n        return [\n            final,\n            (0, unescape_js_1.unescape)(body),\n            (this.#hasMagic = !!this.#hasMagic),\n            this.#uflag,\n        ];\n    }\n    #partsToRegExp(dot) {\n        return this.#parts\n            .map(p => {\n            // extglob ASTs should only contain parent ASTs\n            /* c8 ignore start */\n            if (typeof p === 'string') {\n                throw new Error('string type in extglob ast??');\n            }\n            /* c8 ignore stop */\n            // can ignore hasMagic, because extglobs are already always magic\n            const [re, _, _hasMagic, uflag] = p.toRegExpSource(dot);\n            this.#uflag = this.#uflag || uflag;\n            return re;\n        })\n            .filter(p => !(this.isStart() && this.isEnd()) || !!p)\n            .join('|');\n    }\n    static #parseGlob(glob, hasMagic, noEmpty = false) {\n        let escaping = false;\n        let re = '';\n        let uflag = false;\n        for (let i = 0; i < glob.length; i++) {\n            const c = glob.charAt(i);\n            if (escaping) {\n                escaping = false;\n                re += (reSpecials.has(c) ? '\\\\' : '') + c;\n                continue;\n            }\n            if (c === '\\\\') {\n                if (i === glob.length - 1) {\n                    re += '\\\\\\\\';\n                }\n                else {\n                    escaping = true;\n                }\n                continue;\n            }\n            if (c === '[') {\n                const [src, needUflag, consumed, magic] = (0, brace_expressions_js_1.parseClass)(glob, i);\n                if (consumed) {\n                    re += src;\n                    uflag = uflag || needUflag;\n                    i += consumed - 1;\n                    hasMagic = hasMagic || magic;\n                    continue;\n                }\n            }\n            if (c === '*') {\n                if (noEmpty && glob === '*')\n                    re += starNoEmpty;\n                else\n                    re += star;\n                hasMagic = true;\n                continue;\n            }\n            if (c === '?') {\n                re += qmark;\n                hasMagic = true;\n                continue;\n            }\n            re += regExpEscape(c);\n        }\n        return [re, (0, unescape_js_1.unescape)(glob), !!hasMagic, uflag];\n    }\n}\nexports.AST = AST;\n//# sourceMappingURL=ast.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbWluaW1hdGNoL2Rpc3QvY29tbW9uanMvYXN0LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsV0FBVztBQUNYLCtCQUErQixtQkFBTyxDQUFDLGlHQUF3QjtBQUMvRCxzQkFBc0IsbUJBQU8sQ0FBQywrRUFBZTtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDLDhDQUE4QztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxrQ0FBa0M7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHVCQUF1QjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxHQUFHO0FBQy9DO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixLQUFLLE1BQU0sZUFBZTtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsVUFBVTtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixpQkFBaUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1giLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hdXRvLWxvb3AtZGVtby8uL25vZGVfbW9kdWxlcy9taW5pbWF0Y2gvZGlzdC9jb21tb25qcy9hc3QuanM/NzhiNiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8vIHBhcnNlIGEgc2luZ2xlIHBhdGggcG9ydGlvblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5BU1QgPSB2b2lkIDA7XG5jb25zdCBicmFjZV9leHByZXNzaW9uc19qc18xID0gcmVxdWlyZShcIi4vYnJhY2UtZXhwcmVzc2lvbnMuanNcIik7XG5jb25zdCB1bmVzY2FwZV9qc18xID0gcmVxdWlyZShcIi4vdW5lc2NhcGUuanNcIik7XG5jb25zdCB0eXBlcyA9IG5ldyBTZXQoWychJywgJz8nLCAnKycsICcqJywgJ0AnXSk7XG5jb25zdCBpc0V4dGdsb2JUeXBlID0gKGMpID0+IHR5cGVzLmhhcyhjKTtcbi8vIFBhdHRlcm5zIHRoYXQgZ2V0IHByZXBlbmRlZCB0byBiaW5kIHRvIHRoZSBzdGFydCBvZiBlaXRoZXIgdGhlXG4vLyBlbnRpcmUgc3RyaW5nLCBvciBqdXN0IGEgc2luZ2xlIHBhdGggcG9ydGlvbiwgdG8gcHJldmVudCBkb3RzXG4vLyBhbmQvb3IgdHJhdmVyc2FsIHBhdHRlcm5zLCB3aGVuIG5lZWRlZC5cbi8vIEV4dHMgZG9uJ3QgbmVlZCB0aGUgXiBvciAvIGJpdCwgYmVjYXVzZSB0aGUgcm9vdCBiaW5kcyB0aGF0IGFscmVhZHkuXG5jb25zdCBzdGFydE5vVHJhdmVyc2FsID0gJyg/ISg/Ol58LylcXFxcLlxcXFwuPyg/OiR8LykpJztcbmNvbnN0IHN0YXJ0Tm9Eb3QgPSAnKD8hXFxcXC4pJztcbi8vIGNoYXJhY3RlcnMgdGhhdCBpbmRpY2F0ZSBhIHN0YXJ0IG9mIHBhdHRlcm4gbmVlZHMgdGhlIFwibm8gZG90c1wiIGJpdCxcbi8vIGJlY2F1c2UgYSBkb3QgKm1pZ2h0KiBiZSBtYXRjaGVkLiAoIGlzIG5vdCBpbiB0aGUgbGlzdCwgYmVjYXVzZSBpblxuLy8gdGhlIGNhc2Ugb2YgYSBjaGlsZCBleHRnbG9iLCBpdCB3aWxsIGhhbmRsZSB0aGUgcHJldmVudGlvbiBpdHNlbGYuXG5jb25zdCBhZGRQYXR0ZXJuU3RhcnQgPSBuZXcgU2V0KFsnWycsICcuJ10pO1xuLy8gY2FzZXMgd2hlcmUgdHJhdmVyc2FsIGlzIEEtT0ssIG5vIGRvdCBwcmV2ZW50aW9uIG5lZWRlZFxuY29uc3QganVzdERvdHMgPSBuZXcgU2V0KFsnLi4nLCAnLiddKTtcbmNvbnN0IHJlU3BlY2lhbHMgPSBuZXcgU2V0KCcoKS4qe30rP1tdXiRcXFxcIScpO1xuY29uc3QgcmVnRXhwRXNjYXBlID0gKHMpID0+IHMucmVwbGFjZSgvWy1bXFxde30oKSorPy4sXFxcXF4kfCNcXHNdL2csICdcXFxcJCYnKTtcbi8vIGFueSBzaW5nbGUgdGhpbmcgb3RoZXIgdGhhbiAvXG5jb25zdCBxbWFyayA9ICdbXi9dJztcbi8vICogPT4gYW55IG51bWJlciBvZiBjaGFyYWN0ZXJzXG5jb25zdCBzdGFyID0gcW1hcmsgKyAnKj8nO1xuLy8gdXNlICsgd2hlbiB3ZSBuZWVkIHRvIGVuc3VyZSB0aGF0ICpzb21ldGhpbmcqIG1hdGNoZXMsIGJlY2F1c2UgdGhlICogaXNcbi8vIHRoZSBvbmx5IHRoaW5nIGluIHRoZSBwYXRoIHBvcnRpb24uXG5jb25zdCBzdGFyTm9FbXB0eSA9IHFtYXJrICsgJys/Jztcbi8vIHJlbW92ZSB0aGUgXFwgY2hhcnMgdGhhdCB3ZSBhZGRlZCBpZiB3ZSBlbmQgdXAgZG9pbmcgYSBub25tYWdpYyBjb21wYXJlXG4vLyBjb25zdCBkZXNsYXNoID0gKHM6IHN0cmluZykgPT4gcy5yZXBsYWNlKC9cXFxcKC4pL2csICckMScpXG5jbGFzcyBBU1Qge1xuICAgIHR5cGU7XG4gICAgI3Jvb3Q7XG4gICAgI2hhc01hZ2ljO1xuICAgICN1ZmxhZyA9IGZhbHNlO1xuICAgICNwYXJ0cyA9IFtdO1xuICAgICNwYXJlbnQ7XG4gICAgI3BhcmVudEluZGV4O1xuICAgICNuZWdzO1xuICAgICNmaWxsZWROZWdzID0gZmFsc2U7XG4gICAgI29wdGlvbnM7XG4gICAgI3RvU3RyaW5nO1xuICAgIC8vIHNldCB0byB0cnVlIGlmIGl0J3MgYW4gZXh0Z2xvYiB3aXRoIG5vIGNoaWxkcmVuXG4gICAgLy8gKHdoaWNoIHJlYWxseSBtZWFucyBvbmUgY2hpbGQgb2YgJycpXG4gICAgI2VtcHR5RXh0ID0gZmFsc2U7XG4gICAgY29uc3RydWN0b3IodHlwZSwgcGFyZW50LCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICAgICAgLy8gZXh0Z2xvYnMgYXJlIGluaGVyZW50bHkgbWFnaWNhbFxuICAgICAgICBpZiAodHlwZSlcbiAgICAgICAgICAgIHRoaXMuI2hhc01hZ2ljID0gdHJ1ZTtcbiAgICAgICAgdGhpcy4jcGFyZW50ID0gcGFyZW50O1xuICAgICAgICB0aGlzLiNyb290ID0gdGhpcy4jcGFyZW50ID8gdGhpcy4jcGFyZW50LiNyb290IDogdGhpcztcbiAgICAgICAgdGhpcy4jb3B0aW9ucyA9IHRoaXMuI3Jvb3QgPT09IHRoaXMgPyBvcHRpb25zIDogdGhpcy4jcm9vdC4jb3B0aW9ucztcbiAgICAgICAgdGhpcy4jbmVncyA9IHRoaXMuI3Jvb3QgPT09IHRoaXMgPyBbXSA6IHRoaXMuI3Jvb3QuI25lZ3M7XG4gICAgICAgIGlmICh0eXBlID09PSAnIScgJiYgIXRoaXMuI3Jvb3QuI2ZpbGxlZE5lZ3MpXG4gICAgICAgICAgICB0aGlzLiNuZWdzLnB1c2godGhpcyk7XG4gICAgICAgIHRoaXMuI3BhcmVudEluZGV4ID0gdGhpcy4jcGFyZW50ID8gdGhpcy4jcGFyZW50LiNwYXJ0cy5sZW5ndGggOiAwO1xuICAgIH1cbiAgICBnZXQgaGFzTWFnaWMoKSB7XG4gICAgICAgIC8qIGM4IGlnbm9yZSBzdGFydCAqL1xuICAgICAgICBpZiAodGhpcy4jaGFzTWFnaWMgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHJldHVybiB0aGlzLiNoYXNNYWdpYztcbiAgICAgICAgLyogYzggaWdub3JlIHN0b3AgKi9cbiAgICAgICAgZm9yIChjb25zdCBwIG9mIHRoaXMuI3BhcnRzKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHAgPT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgaWYgKHAudHlwZSB8fCBwLmhhc01hZ2ljKVxuICAgICAgICAgICAgICAgIHJldHVybiAodGhpcy4jaGFzTWFnaWMgPSB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBub3RlOiB3aWxsIGJlIHVuZGVmaW5lZCB1bnRpbCB3ZSBnZW5lcmF0ZSB0aGUgcmVnZXhwIHNyYyBhbmQgZmluZCBvdXRcbiAgICAgICAgcmV0dXJuIHRoaXMuI2hhc01hZ2ljO1xuICAgIH1cbiAgICAvLyByZWNvbnN0cnVjdHMgdGhlIHBhdHRlcm5cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgaWYgKHRoaXMuI3RvU3RyaW5nICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy4jdG9TdHJpbmc7XG4gICAgICAgIGlmICghdGhpcy50eXBlKSB7XG4gICAgICAgICAgICByZXR1cm4gKHRoaXMuI3RvU3RyaW5nID0gdGhpcy4jcGFydHMubWFwKHAgPT4gU3RyaW5nKHApKS5qb2luKCcnKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gKHRoaXMuI3RvU3RyaW5nID1cbiAgICAgICAgICAgICAgICB0aGlzLnR5cGUgKyAnKCcgKyB0aGlzLiNwYXJ0cy5tYXAocCA9PiBTdHJpbmcocCkpLmpvaW4oJ3wnKSArICcpJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgI2ZpbGxOZWdzKCkge1xuICAgICAgICAvKiBjOCBpZ25vcmUgc3RhcnQgKi9cbiAgICAgICAgaWYgKHRoaXMgIT09IHRoaXMuI3Jvb3QpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Nob3VsZCBvbmx5IGNhbGwgb24gcm9vdCcpO1xuICAgICAgICBpZiAodGhpcy4jZmlsbGVkTmVncylcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAvKiBjOCBpZ25vcmUgc3RvcCAqL1xuICAgICAgICAvLyBjYWxsIHRvU3RyaW5nKCkgb25jZSB0byBmaWxsIHRoaXMgb3V0XG4gICAgICAgIHRoaXMudG9TdHJpbmcoKTtcbiAgICAgICAgdGhpcy4jZmlsbGVkTmVncyA9IHRydWU7XG4gICAgICAgIGxldCBuO1xuICAgICAgICB3aGlsZSAoKG4gPSB0aGlzLiNuZWdzLnBvcCgpKSkge1xuICAgICAgICAgICAgaWYgKG4udHlwZSAhPT0gJyEnKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgLy8gd2FsayB1cCB0aGUgdHJlZSwgYXBwZW5kaW5nIGV2ZXJ0aGluZyB0aGF0IGNvbWVzIEFGVEVSIHBhcmVudEluZGV4XG4gICAgICAgICAgICBsZXQgcCA9IG47XG4gICAgICAgICAgICBsZXQgcHAgPSBwLiNwYXJlbnQ7XG4gICAgICAgICAgICB3aGlsZSAocHApIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gcC4jcGFyZW50SW5kZXggKyAxOyAhcHAudHlwZSAmJiBpIDwgcHAuI3BhcnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgcGFydCBvZiBuLiNwYXJ0cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLyogYzggaWdub3JlIHN0YXJ0ICovXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHBhcnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzdHJpbmcgcGFydCBpbiBleHRnbG9iIEFTVD8/Jyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvKiBjOCBpZ25vcmUgc3RvcCAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFydC5jb3B5SW4ocHAuI3BhcnRzW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwID0gcHA7XG4gICAgICAgICAgICAgICAgcHAgPSBwLiNwYXJlbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHB1c2goLi4ucGFydHMpIHtcbiAgICAgICAgZm9yIChjb25zdCBwIG9mIHBhcnRzKSB7XG4gICAgICAgICAgICBpZiAocCA9PT0gJycpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAvKiBjOCBpZ25vcmUgc3RhcnQgKi9cbiAgICAgICAgICAgIGlmICh0eXBlb2YgcCAhPT0gJ3N0cmluZycgJiYgIShwIGluc3RhbmNlb2YgQVNUICYmIHAuI3BhcmVudCA9PT0gdGhpcykpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgcGFydDogJyArIHApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLyogYzggaWdub3JlIHN0b3AgKi9cbiAgICAgICAgICAgIHRoaXMuI3BhcnRzLnB1c2gocCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdG9KU09OKCkge1xuICAgICAgICBjb25zdCByZXQgPSB0aGlzLnR5cGUgPT09IG51bGxcbiAgICAgICAgICAgID8gdGhpcy4jcGFydHMuc2xpY2UoKS5tYXAocCA9PiAodHlwZW9mIHAgPT09ICdzdHJpbmcnID8gcCA6IHAudG9KU09OKCkpKVxuICAgICAgICAgICAgOiBbdGhpcy50eXBlLCAuLi50aGlzLiNwYXJ0cy5tYXAocCA9PiBwLnRvSlNPTigpKV07XG4gICAgICAgIGlmICh0aGlzLmlzU3RhcnQoKSAmJiAhdGhpcy50eXBlKVxuICAgICAgICAgICAgcmV0LnVuc2hpZnQoW10pO1xuICAgICAgICBpZiAodGhpcy5pc0VuZCgpICYmXG4gICAgICAgICAgICAodGhpcyA9PT0gdGhpcy4jcm9vdCB8fFxuICAgICAgICAgICAgICAgICh0aGlzLiNyb290LiNmaWxsZWROZWdzICYmIHRoaXMuI3BhcmVudD8udHlwZSA9PT0gJyEnKSkpIHtcbiAgICAgICAgICAgIHJldC5wdXNoKHt9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgICBpc1N0YXJ0KCkge1xuICAgICAgICBpZiAodGhpcy4jcm9vdCA9PT0gdGhpcylcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAvLyBpZiAodGhpcy50eXBlKSByZXR1cm4gISF0aGlzLiNwYXJlbnQ/LmlzU3RhcnQoKVxuICAgICAgICBpZiAoIXRoaXMuI3BhcmVudD8uaXNTdGFydCgpKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAodGhpcy4jcGFyZW50SW5kZXggPT09IDApXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgLy8gaWYgZXZlcnl0aGluZyBBSEVBRCBvZiB0aGlzIGlzIGEgbmVnYXRpb24sIHRoZW4gaXQncyBzdGlsbCB0aGUgXCJzdGFydFwiXG4gICAgICAgIGNvbnN0IHAgPSB0aGlzLiNwYXJlbnQ7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy4jcGFyZW50SW5kZXg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgcHAgPSBwLiNwYXJ0c1tpXTtcbiAgICAgICAgICAgIGlmICghKHBwIGluc3RhbmNlb2YgQVNUICYmIHBwLnR5cGUgPT09ICchJykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlzRW5kKCkge1xuICAgICAgICBpZiAodGhpcy4jcm9vdCA9PT0gdGhpcylcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBpZiAodGhpcy4jcGFyZW50Py50eXBlID09PSAnIScpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgaWYgKCF0aGlzLiNwYXJlbnQ/LmlzRW5kKCkpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmICghdGhpcy50eXBlKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuI3BhcmVudD8uaXNFbmQoKTtcbiAgICAgICAgLy8gaWYgbm90IHJvb3QsIGl0J2xsIGFsd2F5cyBoYXZlIGEgcGFyZW50XG4gICAgICAgIC8qIGM4IGlnbm9yZSBzdGFydCAqL1xuICAgICAgICBjb25zdCBwbCA9IHRoaXMuI3BhcmVudCA/IHRoaXMuI3BhcmVudC4jcGFydHMubGVuZ3RoIDogMDtcbiAgICAgICAgLyogYzggaWdub3JlIHN0b3AgKi9cbiAgICAgICAgcmV0dXJuIHRoaXMuI3BhcmVudEluZGV4ID09PSBwbCAtIDE7XG4gICAgfVxuICAgIGNvcHlJbihwYXJ0KSB7XG4gICAgICAgIGlmICh0eXBlb2YgcGFydCA9PT0gJ3N0cmluZycpXG4gICAgICAgICAgICB0aGlzLnB1c2gocGFydCk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRoaXMucHVzaChwYXJ0LmNsb25lKHRoaXMpKTtcbiAgICB9XG4gICAgY2xvbmUocGFyZW50KSB7XG4gICAgICAgIGNvbnN0IGMgPSBuZXcgQVNUKHRoaXMudHlwZSwgcGFyZW50KTtcbiAgICAgICAgZm9yIChjb25zdCBwIG9mIHRoaXMuI3BhcnRzKSB7XG4gICAgICAgICAgICBjLmNvcHlJbihwKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYztcbiAgICB9XG4gICAgc3RhdGljICNwYXJzZUFTVChzdHIsIGFzdCwgcG9zLCBvcHQpIHtcbiAgICAgICAgbGV0IGVzY2FwaW5nID0gZmFsc2U7XG4gICAgICAgIGxldCBpbkJyYWNlID0gZmFsc2U7XG4gICAgICAgIGxldCBicmFjZVN0YXJ0ID0gLTE7XG4gICAgICAgIGxldCBicmFjZU5lZyA9IGZhbHNlO1xuICAgICAgICBpZiAoYXN0LnR5cGUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIG91dHNpZGUgb2YgYSBleHRnbG9iLCBhcHBlbmQgdW50aWwgd2UgZmluZCBhIHN0YXJ0XG4gICAgICAgICAgICBsZXQgaSA9IHBvcztcbiAgICAgICAgICAgIGxldCBhY2MgPSAnJztcbiAgICAgICAgICAgIHdoaWxlIChpIDwgc3RyLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGMgPSBzdHIuY2hhckF0KGkrKyk7XG4gICAgICAgICAgICAgICAgLy8gc3RpbGwgYWNjdW11bGF0ZSBlc2NhcGVzIGF0IHRoaXMgcG9pbnQsIGJ1dCB3ZSBkbyBpZ25vcmVcbiAgICAgICAgICAgICAgICAvLyBzdGFydHMgdGhhdCBhcmUgZXNjYXBlZFxuICAgICAgICAgICAgICAgIGlmIChlc2NhcGluZyB8fCBjID09PSAnXFxcXCcpIHtcbiAgICAgICAgICAgICAgICAgICAgZXNjYXBpbmcgPSAhZXNjYXBpbmc7XG4gICAgICAgICAgICAgICAgICAgIGFjYyArPSBjO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGluQnJhY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGkgPT09IGJyYWNlU3RhcnQgKyAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYyA9PT0gJ14nIHx8IGMgPT09ICchJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyYWNlTmVnID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChjID09PSAnXScgJiYgIShpID09PSBicmFjZVN0YXJ0ICsgMiAmJiBicmFjZU5lZykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluQnJhY2UgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBhY2MgKz0gYztcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGMgPT09ICdbJykge1xuICAgICAgICAgICAgICAgICAgICBpbkJyYWNlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgYnJhY2VTdGFydCA9IGk7XG4gICAgICAgICAgICAgICAgICAgIGJyYWNlTmVnID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGFjYyArPSBjO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFvcHQubm9leHQgJiYgaXNFeHRnbG9iVHlwZShjKSAmJiBzdHIuY2hhckF0KGkpID09PSAnKCcpIHtcbiAgICAgICAgICAgICAgICAgICAgYXN0LnB1c2goYWNjKTtcbiAgICAgICAgICAgICAgICAgICAgYWNjID0gJyc7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGV4dCA9IG5ldyBBU1QoYywgYXN0KTtcbiAgICAgICAgICAgICAgICAgICAgaSA9IEFTVC4jcGFyc2VBU1Qoc3RyLCBleHQsIGksIG9wdCk7XG4gICAgICAgICAgICAgICAgICAgIGFzdC5wdXNoKGV4dCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhY2MgKz0gYztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFzdC5wdXNoKGFjYyk7XG4gICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgfVxuICAgICAgICAvLyBzb21lIGtpbmQgb2YgZXh0Z2xvYiwgcG9zIGlzIGF0IHRoZSAoXG4gICAgICAgIC8vIGZpbmQgdGhlIG5leHQgfCBvciApXG4gICAgICAgIGxldCBpID0gcG9zICsgMTtcbiAgICAgICAgbGV0IHBhcnQgPSBuZXcgQVNUKG51bGwsIGFzdCk7XG4gICAgICAgIGNvbnN0IHBhcnRzID0gW107XG4gICAgICAgIGxldCBhY2MgPSAnJztcbiAgICAgICAgd2hpbGUgKGkgPCBzdHIubGVuZ3RoKSB7XG4gICAgICAgICAgICBjb25zdCBjID0gc3RyLmNoYXJBdChpKyspO1xuICAgICAgICAgICAgLy8gc3RpbGwgYWNjdW11bGF0ZSBlc2NhcGVzIGF0IHRoaXMgcG9pbnQsIGJ1dCB3ZSBkbyBpZ25vcmVcbiAgICAgICAgICAgIC8vIHN0YXJ0cyB0aGF0IGFyZSBlc2NhcGVkXG4gICAgICAgICAgICBpZiAoZXNjYXBpbmcgfHwgYyA9PT0gJ1xcXFwnKSB7XG4gICAgICAgICAgICAgICAgZXNjYXBpbmcgPSAhZXNjYXBpbmc7XG4gICAgICAgICAgICAgICAgYWNjICs9IGM7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaW5CcmFjZSkge1xuICAgICAgICAgICAgICAgIGlmIChpID09PSBicmFjZVN0YXJ0ICsgMSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYyA9PT0gJ14nIHx8IGMgPT09ICchJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJhY2VOZWcgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGMgPT09ICddJyAmJiAhKGkgPT09IGJyYWNlU3RhcnQgKyAyICYmIGJyYWNlTmVnKSkge1xuICAgICAgICAgICAgICAgICAgICBpbkJyYWNlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGFjYyArPSBjO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYyA9PT0gJ1snKSB7XG4gICAgICAgICAgICAgICAgaW5CcmFjZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgYnJhY2VTdGFydCA9IGk7XG4gICAgICAgICAgICAgICAgYnJhY2VOZWcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBhY2MgKz0gYztcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc0V4dGdsb2JUeXBlKGMpICYmIHN0ci5jaGFyQXQoaSkgPT09ICcoJykge1xuICAgICAgICAgICAgICAgIHBhcnQucHVzaChhY2MpO1xuICAgICAgICAgICAgICAgIGFjYyA9ICcnO1xuICAgICAgICAgICAgICAgIGNvbnN0IGV4dCA9IG5ldyBBU1QoYywgcGFydCk7XG4gICAgICAgICAgICAgICAgcGFydC5wdXNoKGV4dCk7XG4gICAgICAgICAgICAgICAgaSA9IEFTVC4jcGFyc2VBU1Qoc3RyLCBleHQsIGksIG9wdCk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYyA9PT0gJ3wnKSB7XG4gICAgICAgICAgICAgICAgcGFydC5wdXNoKGFjYyk7XG4gICAgICAgICAgICAgICAgYWNjID0gJyc7XG4gICAgICAgICAgICAgICAgcGFydHMucHVzaChwYXJ0KTtcbiAgICAgICAgICAgICAgICBwYXJ0ID0gbmV3IEFTVChudWxsLCBhc3QpO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGMgPT09ICcpJykge1xuICAgICAgICAgICAgICAgIGlmIChhY2MgPT09ICcnICYmIGFzdC4jcGFydHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGFzdC4jZW1wdHlFeHQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwYXJ0LnB1c2goYWNjKTtcbiAgICAgICAgICAgICAgICBhY2MgPSAnJztcbiAgICAgICAgICAgICAgICBhc3QucHVzaCguLi5wYXJ0cywgcGFydCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhY2MgKz0gYztcbiAgICAgICAgfVxuICAgICAgICAvLyB1bmZpbmlzaGVkIGV4dGdsb2JcbiAgICAgICAgLy8gaWYgd2UgZ290IGhlcmUsIGl0IHdhcyBhIG1hbGZvcm1lZCBleHRnbG9iISBub3QgYW4gZXh0Z2xvYiwgYnV0XG4gICAgICAgIC8vIG1heWJlIHNvbWV0aGluZyBlbHNlIGluIHRoZXJlLlxuICAgICAgICBhc3QudHlwZSA9IG51bGw7XG4gICAgICAgIGFzdC4jaGFzTWFnaWMgPSB1bmRlZmluZWQ7XG4gICAgICAgIGFzdC4jcGFydHMgPSBbc3RyLnN1YnN0cmluZyhwb3MgLSAxKV07XG4gICAgICAgIHJldHVybiBpO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbUdsb2IocGF0dGVybiwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIGNvbnN0IGFzdCA9IG5ldyBBU1QobnVsbCwgdW5kZWZpbmVkLCBvcHRpb25zKTtcbiAgICAgICAgQVNULiNwYXJzZUFTVChwYXR0ZXJuLCBhc3QsIDAsIG9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gYXN0O1xuICAgIH1cbiAgICAvLyByZXR1cm5zIHRoZSByZWd1bGFyIGV4cHJlc3Npb24gaWYgdGhlcmUncyBtYWdpYywgb3IgdGhlIHVuZXNjYXBlZFxuICAgIC8vIHN0cmluZyBpZiBub3QuXG4gICAgdG9NTVBhdHRlcm4oKSB7XG4gICAgICAgIC8vIHNob3VsZCBvbmx5IGJlIGNhbGxlZCBvbiByb290XG4gICAgICAgIC8qIGM4IGlnbm9yZSBzdGFydCAqL1xuICAgICAgICBpZiAodGhpcyAhPT0gdGhpcy4jcm9vdClcbiAgICAgICAgICAgIHJldHVybiB0aGlzLiNyb290LnRvTU1QYXR0ZXJuKCk7XG4gICAgICAgIC8qIGM4IGlnbm9yZSBzdG9wICovXG4gICAgICAgIGNvbnN0IGdsb2IgPSB0aGlzLnRvU3RyaW5nKCk7XG4gICAgICAgIGNvbnN0IFtyZSwgYm9keSwgaGFzTWFnaWMsIHVmbGFnXSA9IHRoaXMudG9SZWdFeHBTb3VyY2UoKTtcbiAgICAgICAgLy8gaWYgd2UncmUgaW4gbm9jYXNlIG1vZGUsIGFuZCBub3Qgbm9jYXNlTWFnaWNPbmx5LCB0aGVuIHdlIGRvXG4gICAgICAgIC8vIHN0aWxsIG5lZWQgYSByZWd1bGFyIGV4cHJlc3Npb24gaWYgd2UgaGF2ZSB0byBjYXNlLWluc2Vuc2l0aXZlbHlcbiAgICAgICAgLy8gbWF0Y2ggY2FwaXRhbC9sb3dlcmNhc2UgY2hhcmFjdGVycy5cbiAgICAgICAgY29uc3QgYW55TWFnaWMgPSBoYXNNYWdpYyB8fFxuICAgICAgICAgICAgdGhpcy4jaGFzTWFnaWMgfHxcbiAgICAgICAgICAgICh0aGlzLiNvcHRpb25zLm5vY2FzZSAmJlxuICAgICAgICAgICAgICAgICF0aGlzLiNvcHRpb25zLm5vY2FzZU1hZ2ljT25seSAmJlxuICAgICAgICAgICAgICAgIGdsb2IudG9VcHBlckNhc2UoKSAhPT0gZ2xvYi50b0xvd2VyQ2FzZSgpKTtcbiAgICAgICAgaWYgKCFhbnlNYWdpYykge1xuICAgICAgICAgICAgcmV0dXJuIGJvZHk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZmxhZ3MgPSAodGhpcy4jb3B0aW9ucy5ub2Nhc2UgPyAnaScgOiAnJykgKyAodWZsYWcgPyAndScgOiAnJyk7XG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKG5ldyBSZWdFeHAoYF4ke3JlfSRgLCBmbGFncyksIHtcbiAgICAgICAgICAgIF9zcmM6IHJlLFxuICAgICAgICAgICAgX2dsb2I6IGdsb2IsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXQgb3B0aW9ucygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI29wdGlvbnM7XG4gICAgfVxuICAgIC8vIHJldHVybnMgdGhlIHN0cmluZyBtYXRjaCwgdGhlIHJlZ2V4cCBzb3VyY2UsIHdoZXRoZXIgdGhlcmUncyBtYWdpY1xuICAgIC8vIGluIHRoZSByZWdleHAgKHNvIGEgcmVndWxhciBleHByZXNzaW9uIGlzIHJlcXVpcmVkKSBhbmQgd2hldGhlciBvclxuICAgIC8vIG5vdCB0aGUgdWZsYWcgaXMgbmVlZGVkIGZvciB0aGUgcmVndWxhciBleHByZXNzaW9uIChmb3IgcG9zaXggY2xhc3NlcylcbiAgICAvLyBUT0RPOiBpbnN0ZWFkIG9mIGluamVjdGluZyB0aGUgc3RhcnQvZW5kIGF0IHRoaXMgcG9pbnQsIGp1c3QgcmV0dXJuXG4gICAgLy8gdGhlIEJPRFkgb2YgdGhlIHJlZ2V4cCwgYWxvbmcgd2l0aCB0aGUgc3RhcnQvZW5kIHBvcnRpb25zIHN1aXRhYmxlXG4gICAgLy8gZm9yIGJpbmRpbmcgdGhlIHN0YXJ0L2VuZCBpbiBlaXRoZXIgYSBqb2luZWQgZnVsbC1wYXRoIG1ha2VSZSBjb250ZXh0XG4gICAgLy8gKHdoZXJlIHdlIGJpbmQgdG8gKF58LyksIG9yIGEgc3RhbmRhbG9uZSBtYXRjaFBhcnQgY29udGV4dCAod2hlcmVcbiAgICAvLyB3ZSBiaW5kIHRvIF4sIGFuZCBub3QgLykuICBPdGhlcndpc2Ugc2xhc2hlcyBnZXQgZHVwZWQhXG4gICAgLy9cbiAgICAvLyBJbiBwYXJ0LW1hdGNoaW5nIG1vZGUsIHRoZSBzdGFydCBpczpcbiAgICAvLyAtIGlmIG5vdCBpc1N0YXJ0OiBub3RoaW5nXG4gICAgLy8gLSBpZiB0cmF2ZXJzYWwgcG9zc2libGUsIGJ1dCBub3QgYWxsb3dlZDogXig/IVxcLlxcLj8kKVxuICAgIC8vIC0gaWYgZG90cyBhbGxvd2VkIG9yIG5vdCBwb3NzaWJsZTogXlxuICAgIC8vIC0gaWYgZG90cyBwb3NzaWJsZSBhbmQgbm90IGFsbG93ZWQ6IF4oPyFcXC4pXG4gICAgLy8gZW5kIGlzOlxuICAgIC8vIC0gaWYgbm90IGlzRW5kKCk6IG5vdGhpbmdcbiAgICAvLyAtIGVsc2U6ICRcbiAgICAvL1xuICAgIC8vIEluIGZ1bGwtcGF0aCBtYXRjaGluZyBtb2RlLCB3ZSBwdXQgdGhlIHNsYXNoIGF0IHRoZSBTVEFSVCBvZiB0aGVcbiAgICAvLyBwYXR0ZXJuLCBzbyBzdGFydCBpczpcbiAgICAvLyAtIGlmIGZpcnN0IHBhdHRlcm46IHNhbWUgYXMgcGFydC1tYXRjaGluZyBtb2RlXG4gICAgLy8gLSBpZiBub3QgaXNTdGFydCgpOiBub3RoaW5nXG4gICAgLy8gLSBpZiB0cmF2ZXJzYWwgcG9zc2libGUsIGJ1dCBub3QgYWxsb3dlZDogLyg/IVxcLlxcLj8oPzokfC8pKVxuICAgIC8vIC0gaWYgZG90cyBhbGxvd2VkIG9yIG5vdCBwb3NzaWJsZTogL1xuICAgIC8vIC0gaWYgZG90cyBwb3NzaWJsZSBhbmQgbm90IGFsbG93ZWQ6IC8oPyFcXC4pXG4gICAgLy8gZW5kIGlzOlxuICAgIC8vIC0gaWYgbGFzdCBwYXR0ZXJuLCBzYW1lIGFzIHBhcnQtbWF0Y2hpbmcgbW9kZVxuICAgIC8vIC0gZWxzZSBub3RoaW5nXG4gICAgLy9cbiAgICAvLyBBbHdheXMgcHV0IHRoZSAoPzokfC8pIG9uIG5lZ2F0ZWQgdGFpbHMsIHRob3VnaCwgYmVjYXVzZSB0aGF0IGhhcyB0byBiZVxuICAgIC8vIHRoZXJlIHRvIGJpbmQgdGhlIGVuZCBvZiB0aGUgbmVnYXRlZCBwYXR0ZXJuIHBvcnRpb24sIGFuZCBpdCdzIGVhc2llciB0b1xuICAgIC8vIGp1c3Qgc3RpY2sgaXQgaW4gbm93IHJhdGhlciB0aGFuIHRyeSB0byBpbmplY3QgaXQgbGF0ZXIgaW4gdGhlIG1pZGRsZSBvZlxuICAgIC8vIHRoZSBwYXR0ZXJuLlxuICAgIC8vXG4gICAgLy8gV2UgY2FuIGp1c3QgYWx3YXlzIHJldHVybiB0aGUgc2FtZSBlbmQsIGFuZCBsZWF2ZSBpdCB1cCB0byB0aGUgY2FsbGVyXG4gICAgLy8gdG8ga25vdyB3aGV0aGVyIGl0J3MgZ29pbmcgdG8gYmUgdXNlZCBqb2luZWQgb3IgaW4gcGFydHMuXG4gICAgLy8gQW5kLCBpZiB0aGUgc3RhcnQgaXMgYWRqdXN0ZWQgc2xpZ2h0bHksIGNhbiBkbyB0aGUgc2FtZSB0aGVyZTpcbiAgICAvLyAtIGlmIG5vdCBpc1N0YXJ0OiBub3RoaW5nXG4gICAgLy8gLSBpZiB0cmF2ZXJzYWwgcG9zc2libGUsIGJ1dCBub3QgYWxsb3dlZDogKD86L3xeKSg/IVxcLlxcLj8kKVxuICAgIC8vIC0gaWYgZG90cyBhbGxvd2VkIG9yIG5vdCBwb3NzaWJsZTogKD86L3xeKVxuICAgIC8vIC0gaWYgZG90cyBwb3NzaWJsZSBhbmQgbm90IGFsbG93ZWQ6ICg/Oi98XikoPyFcXC4pXG4gICAgLy9cbiAgICAvLyBCdXQgaXQncyBiZXR0ZXIgdG8gaGF2ZSBhIHNpbXBsZXIgYmluZGluZyB3aXRob3V0IGEgY29uZGl0aW9uYWwsIGZvclxuICAgIC8vIHBlcmZvcm1hbmNlLCBzbyBwcm9iYWJseSBiZXR0ZXIgdG8gcmV0dXJuIGJvdGggc3RhcnQgb3B0aW9ucy5cbiAgICAvL1xuICAgIC8vIFRoZW4gdGhlIGNhbGxlciBqdXN0IGlnbm9yZXMgdGhlIGVuZCBpZiBpdCdzIG5vdCB0aGUgZmlyc3QgcGF0dGVybixcbiAgICAvLyBhbmQgdGhlIHN0YXJ0IGFsd2F5cyBnZXRzIGFwcGxpZWQuXG4gICAgLy9cbiAgICAvLyBCdXQgdGhhdCdzIGFsd2F5cyBnb2luZyB0byBiZSAkIGlmIGl0J3MgdGhlIGVuZGluZyBwYXR0ZXJuLCBvciBub3RoaW5nLFxuICAgIC8vIHNvIHRoZSBjYWxsZXIgY2FuIGp1c3QgYXR0YWNoICQgYXQgdGhlIGVuZCBvZiB0aGUgcGF0dGVybiB3aGVuIGJ1aWxkaW5nLlxuICAgIC8vXG4gICAgLy8gU28gdGhlIHRvZG8gaXM6XG4gICAgLy8gLSBiZXR0ZXIgZGV0ZWN0IHdoYXQga2luZCBvZiBzdGFydCBpcyBuZWVkZWRcbiAgICAvLyAtIHJldHVybiBib3RoIGZsYXZvcnMgb2Ygc3RhcnRpbmcgcGF0dGVyblxuICAgIC8vIC0gYXR0YWNoICQgYXQgdGhlIGVuZCBvZiB0aGUgcGF0dGVybiB3aGVuIGNyZWF0aW5nIHRoZSBhY3R1YWwgUmVnRXhwXG4gICAgLy9cbiAgICAvLyBBaCwgYnV0IHdhaXQsIG5vLCB0aGF0IGFsbCBvbmx5IGFwcGxpZXMgdG8gdGhlIHJvb3Qgd2hlbiB0aGUgZmlyc3QgcGF0dGVyblxuICAgIC8vIGlzIG5vdCBhbiBleHRnbG9iLiBJZiB0aGUgZmlyc3QgcGF0dGVybiBJUyBhbiBleHRnbG9iLCB0aGVuIHdlIG5lZWQgYWxsXG4gICAgLy8gdGhhdCBkb3QgcHJldmVudGlvbiBiaXogdG8gbGl2ZSBpbiB0aGUgZXh0Z2xvYiBwb3J0aW9ucywgYmVjYXVzZSBlZ1xuICAgIC8vICsoKnwueCopIGNhbiBtYXRjaCAueHkgYnV0IG5vdCAueXguXG4gICAgLy9cbiAgICAvLyBTbywgcmV0dXJuIHRoZSB0d28gZmxhdm9ycyBpZiBpdCdzICNyb290IGFuZCB0aGUgZmlyc3QgY2hpbGQgaXMgbm90IGFuXG4gICAgLy8gQVNULCBvdGhlcndpc2UgbGVhdmUgaXQgdG8gdGhlIGNoaWxkIEFTVCB0byBoYW5kbGUgaXQsIGFuZCB0aGVyZSxcbiAgICAvLyB1c2UgdGhlICg/Ol58Lykgc3R5bGUgb2Ygc3RhcnQgYmluZGluZy5cbiAgICAvL1xuICAgIC8vIEV2ZW4gc2ltcGxpZmllZCBmdXJ0aGVyOlxuICAgIC8vIC0gU2luY2UgdGhlIHN0YXJ0IGZvciBhIGpvaW4gaXMgZWcgLyg/IVxcLikgYW5kIHRoZSBzdGFydCBmb3IgYSBwYXJ0XG4gICAgLy8gaXMgXig/IVxcLiksIHdlIGNhbiBqdXN0IHByZXBlbmQgKD8hXFwuKSB0byB0aGUgcGF0dGVybiAoZWl0aGVyIHJvb3RcbiAgICAvLyBvciBzdGFydCBvciB3aGF0ZXZlcikgYW5kIHByZXBlbmQgXiBvciAvIGF0IHRoZSBSZWdleHAgY29uc3RydWN0aW9uLlxuICAgIHRvUmVnRXhwU291cmNlKGFsbG93RG90KSB7XG4gICAgICAgIGNvbnN0IGRvdCA9IGFsbG93RG90ID8/ICEhdGhpcy4jb3B0aW9ucy5kb3Q7XG4gICAgICAgIGlmICh0aGlzLiNyb290ID09PSB0aGlzKVxuICAgICAgICAgICAgdGhpcy4jZmlsbE5lZ3MoKTtcbiAgICAgICAgaWYgKCF0aGlzLnR5cGUpIHtcbiAgICAgICAgICAgIGNvbnN0IG5vRW1wdHkgPSB0aGlzLmlzU3RhcnQoKSAmJiB0aGlzLmlzRW5kKCk7XG4gICAgICAgICAgICBjb25zdCBzcmMgPSB0aGlzLiNwYXJ0c1xuICAgICAgICAgICAgICAgIC5tYXAocCA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgW3JlLCBfLCBoYXNNYWdpYywgdWZsYWddID0gdHlwZW9mIHAgPT09ICdzdHJpbmcnXG4gICAgICAgICAgICAgICAgICAgID8gQVNULiNwYXJzZUdsb2IocCwgdGhpcy4jaGFzTWFnaWMsIG5vRW1wdHkpXG4gICAgICAgICAgICAgICAgICAgIDogcC50b1JlZ0V4cFNvdXJjZShhbGxvd0RvdCk7XG4gICAgICAgICAgICAgICAgdGhpcy4jaGFzTWFnaWMgPSB0aGlzLiNoYXNNYWdpYyB8fCBoYXNNYWdpYztcbiAgICAgICAgICAgICAgICB0aGlzLiN1ZmxhZyA9IHRoaXMuI3VmbGFnIHx8IHVmbGFnO1xuICAgICAgICAgICAgICAgIHJldHVybiByZTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLmpvaW4oJycpO1xuICAgICAgICAgICAgbGV0IHN0YXJ0ID0gJyc7XG4gICAgICAgICAgICBpZiAodGhpcy5pc1N0YXJ0KCkpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHRoaXMuI3BhcnRzWzBdID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICAvLyB0aGlzIGlzIHRoZSBzdHJpbmcgdGhhdCB3aWxsIG1hdGNoIHRoZSBzdGFydCBvZiB0aGUgcGF0dGVybixcbiAgICAgICAgICAgICAgICAgICAgLy8gc28gd2UgbmVlZCB0byBwcm90ZWN0IGFnYWluc3QgZG90cyBhbmQgc3VjaC5cbiAgICAgICAgICAgICAgICAgICAgLy8gJy4nIGFuZCAnLi4nIGNhbm5vdCBtYXRjaCB1bmxlc3MgdGhlIHBhdHRlcm4gaXMgdGhhdCBleGFjdGx5LFxuICAgICAgICAgICAgICAgICAgICAvLyBldmVuIGlmIGl0IHN0YXJ0cyB3aXRoIC4gb3IgZG90OnRydWUgaXMgc2V0LlxuICAgICAgICAgICAgICAgICAgICBjb25zdCBkb3RUcmF2QWxsb3dlZCA9IHRoaXMuI3BhcnRzLmxlbmd0aCA9PT0gMSAmJiBqdXN0RG90cy5oYXModGhpcy4jcGFydHNbMF0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWRvdFRyYXZBbGxvd2VkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBhcHMgPSBhZGRQYXR0ZXJuU3RhcnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjaGVjayBpZiB3ZSBoYXZlIGEgcG9zc2liaWxpdHkgb2YgbWF0Y2hpbmcgLiBvciAuLixcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFuZCBwcmV2ZW50IHRoYXQuXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBuZWVkTm9UcmF2ID0gXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBkb3RzIGFyZSBhbGxvd2VkLCBhbmQgdGhlIHBhdHRlcm4gc3RhcnRzIHdpdGggWyBvciAuXG4gICAgICAgICAgICAgICAgICAgICAgICAoZG90ICYmIGFwcy5oYXMoc3JjLmNoYXJBdCgwKSkpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhlIHBhdHRlcm4gc3RhcnRzIHdpdGggXFwuLCBhbmQgdGhlbiBbIG9yIC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoc3JjLnN0YXJ0c1dpdGgoJ1xcXFwuJykgJiYgYXBzLmhhcyhzcmMuY2hhckF0KDIpKSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGUgcGF0dGVybiBzdGFydHMgd2l0aCBcXC5cXC4sIGFuZCB0aGVuIFsgb3IgLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChzcmMuc3RhcnRzV2l0aCgnXFxcXC5cXFxcLicpICYmIGFwcy5oYXMoc3JjLmNoYXJBdCg0KSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbm8gbmVlZCB0byBwcmV2ZW50IGRvdHMgaWYgaXQgY2FuJ3QgbWF0Y2ggYSBkb3QsIG9yIGlmIGFcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHN1Yi1wYXR0ZXJuIHdpbGwgYmUgcHJldmVudGluZyBpdCBhbnl3YXkuXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBuZWVkTm9Eb3QgPSAhZG90ICYmICFhbGxvd0RvdCAmJiBhcHMuaGFzKHNyYy5jaGFyQXQoMCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQgPSBuZWVkTm9UcmF2ID8gc3RhcnROb1RyYXZlcnNhbCA6IG5lZWROb0RvdCA/IHN0YXJ0Tm9Eb3QgOiAnJztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGFwcGVuZCB0aGUgXCJlbmQgb2YgcGF0aCBwb3J0aW9uXCIgcGF0dGVybiB0byBuZWdhdGlvbiB0YWlsc1xuICAgICAgICAgICAgbGV0IGVuZCA9ICcnO1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNFbmQoKSAmJlxuICAgICAgICAgICAgICAgIHRoaXMuI3Jvb3QuI2ZpbGxlZE5lZ3MgJiZcbiAgICAgICAgICAgICAgICB0aGlzLiNwYXJlbnQ/LnR5cGUgPT09ICchJykge1xuICAgICAgICAgICAgICAgIGVuZCA9ICcoPzokfFxcXFwvKSc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBmaW5hbCA9IHN0YXJ0ICsgc3JjICsgZW5kO1xuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICBmaW5hbCxcbiAgICAgICAgICAgICAgICAoMCwgdW5lc2NhcGVfanNfMS51bmVzY2FwZSkoc3JjKSxcbiAgICAgICAgICAgICAgICAodGhpcy4jaGFzTWFnaWMgPSAhIXRoaXMuI2hhc01hZ2ljKSxcbiAgICAgICAgICAgICAgICB0aGlzLiN1ZmxhZyxcbiAgICAgICAgICAgIF07XG4gICAgICAgIH1cbiAgICAgICAgLy8gV2UgbmVlZCB0byBjYWxjdWxhdGUgdGhlIGJvZHkgKnR3aWNlKiBpZiBpdCdzIGEgcmVwZWF0IHBhdHRlcm5cbiAgICAgICAgLy8gYXQgdGhlIHN0YXJ0LCBvbmNlIGluIG5vZG90IG1vZGUsIHRoZW4gYWdhaW4gaW4gZG90IG1vZGUsIHNvIGFcbiAgICAgICAgLy8gcGF0dGVybiBsaWtlICooPykgY2FuIG1hdGNoICd4LnknXG4gICAgICAgIGNvbnN0IHJlcGVhdGVkID0gdGhpcy50eXBlID09PSAnKicgfHwgdGhpcy50eXBlID09PSAnKyc7XG4gICAgICAgIC8vIHNvbWUga2luZCBvZiBleHRnbG9iXG4gICAgICAgIGNvbnN0IHN0YXJ0ID0gdGhpcy50eXBlID09PSAnIScgPyAnKD86KD8hKD86JyA6ICcoPzonO1xuICAgICAgICBsZXQgYm9keSA9IHRoaXMuI3BhcnRzVG9SZWdFeHAoZG90KTtcbiAgICAgICAgaWYgKHRoaXMuaXNTdGFydCgpICYmIHRoaXMuaXNFbmQoKSAmJiAhYm9keSAmJiB0aGlzLnR5cGUgIT09ICchJykge1xuICAgICAgICAgICAgLy8gaW52YWxpZCBleHRnbG9iLCBoYXMgdG8gYXQgbGVhc3QgYmUgKnNvbWV0aGluZyogcHJlc2VudCwgaWYgaXQnc1xuICAgICAgICAgICAgLy8gdGhlIGVudGlyZSBwYXRoIHBvcnRpb24uXG4gICAgICAgICAgICBjb25zdCBzID0gdGhpcy50b1N0cmluZygpO1xuICAgICAgICAgICAgdGhpcy4jcGFydHMgPSBbc107XG4gICAgICAgICAgICB0aGlzLnR5cGUgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy4jaGFzTWFnaWMgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICByZXR1cm4gW3MsICgwLCB1bmVzY2FwZV9qc18xLnVuZXNjYXBlKSh0aGlzLnRvU3RyaW5nKCkpLCBmYWxzZSwgZmFsc2VdO1xuICAgICAgICB9XG4gICAgICAgIC8vIFhYWCBhYnN0cmFjdCBvdXQgdGhpcyBtYXAgbWV0aG9kXG4gICAgICAgIGxldCBib2R5RG90QWxsb3dlZCA9ICFyZXBlYXRlZCB8fCBhbGxvd0RvdCB8fCBkb3QgfHwgIXN0YXJ0Tm9Eb3RcbiAgICAgICAgICAgID8gJydcbiAgICAgICAgICAgIDogdGhpcy4jcGFydHNUb1JlZ0V4cCh0cnVlKTtcbiAgICAgICAgaWYgKGJvZHlEb3RBbGxvd2VkID09PSBib2R5KSB7XG4gICAgICAgICAgICBib2R5RG90QWxsb3dlZCA9ICcnO1xuICAgICAgICB9XG4gICAgICAgIGlmIChib2R5RG90QWxsb3dlZCkge1xuICAgICAgICAgICAgYm9keSA9IGAoPzoke2JvZHl9KSg/OiR7Ym9keURvdEFsbG93ZWR9KSo/YDtcbiAgICAgICAgfVxuICAgICAgICAvLyBhbiBlbXB0eSAhKCkgaXMgZXhhY3RseSBlcXVpdmFsZW50IHRvIGEgc3Rhck5vRW1wdHlcbiAgICAgICAgbGV0IGZpbmFsID0gJyc7XG4gICAgICAgIGlmICh0aGlzLnR5cGUgPT09ICchJyAmJiB0aGlzLiNlbXB0eUV4dCkge1xuICAgICAgICAgICAgZmluYWwgPSAodGhpcy5pc1N0YXJ0KCkgJiYgIWRvdCA/IHN0YXJ0Tm9Eb3QgOiAnJykgKyBzdGFyTm9FbXB0eTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGNsb3NlID0gdGhpcy50eXBlID09PSAnISdcbiAgICAgICAgICAgICAgICA/IC8vICEoKSBtdXN0IG1hdGNoIHNvbWV0aGluZyxidXQgISh4KSBjYW4gbWF0Y2ggJydcbiAgICAgICAgICAgICAgICAgICAgJykpJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAodGhpcy5pc1N0YXJ0KCkgJiYgIWRvdCAmJiAhYWxsb3dEb3QgPyBzdGFydE5vRG90IDogJycpICtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJyknXG4gICAgICAgICAgICAgICAgOiB0aGlzLnR5cGUgPT09ICdAJ1xuICAgICAgICAgICAgICAgICAgICA/ICcpJ1xuICAgICAgICAgICAgICAgICAgICA6IHRoaXMudHlwZSA9PT0gJz8nXG4gICAgICAgICAgICAgICAgICAgICAgICA/ICcpPydcbiAgICAgICAgICAgICAgICAgICAgICAgIDogdGhpcy50eXBlID09PSAnKycgJiYgYm9keURvdEFsbG93ZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/ICcpJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogdGhpcy50eXBlID09PSAnKicgJiYgYm9keURvdEFsbG93ZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBgKT9gXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogYCkke3RoaXMudHlwZX1gO1xuICAgICAgICAgICAgZmluYWwgPSBzdGFydCArIGJvZHkgKyBjbG9zZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgZmluYWwsXG4gICAgICAgICAgICAoMCwgdW5lc2NhcGVfanNfMS51bmVzY2FwZSkoYm9keSksXG4gICAgICAgICAgICAodGhpcy4jaGFzTWFnaWMgPSAhIXRoaXMuI2hhc01hZ2ljKSxcbiAgICAgICAgICAgIHRoaXMuI3VmbGFnLFxuICAgICAgICBdO1xuICAgIH1cbiAgICAjcGFydHNUb1JlZ0V4cChkb3QpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI3BhcnRzXG4gICAgICAgICAgICAubWFwKHAgPT4ge1xuICAgICAgICAgICAgLy8gZXh0Z2xvYiBBU1RzIHNob3VsZCBvbmx5IGNvbnRhaW4gcGFyZW50IEFTVHNcbiAgICAgICAgICAgIC8qIGM4IGlnbm9yZSBzdGFydCAqL1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBwID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignc3RyaW5nIHR5cGUgaW4gZXh0Z2xvYiBhc3Q/PycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLyogYzggaWdub3JlIHN0b3AgKi9cbiAgICAgICAgICAgIC8vIGNhbiBpZ25vcmUgaGFzTWFnaWMsIGJlY2F1c2UgZXh0Z2xvYnMgYXJlIGFscmVhZHkgYWx3YXlzIG1hZ2ljXG4gICAgICAgICAgICBjb25zdCBbcmUsIF8sIF9oYXNNYWdpYywgdWZsYWddID0gcC50b1JlZ0V4cFNvdXJjZShkb3QpO1xuICAgICAgICAgICAgdGhpcy4jdWZsYWcgPSB0aGlzLiN1ZmxhZyB8fCB1ZmxhZztcbiAgICAgICAgICAgIHJldHVybiByZTtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5maWx0ZXIocCA9PiAhKHRoaXMuaXNTdGFydCgpICYmIHRoaXMuaXNFbmQoKSkgfHwgISFwKVxuICAgICAgICAgICAgLmpvaW4oJ3wnKTtcbiAgICB9XG4gICAgc3RhdGljICNwYXJzZUdsb2IoZ2xvYiwgaGFzTWFnaWMsIG5vRW1wdHkgPSBmYWxzZSkge1xuICAgICAgICBsZXQgZXNjYXBpbmcgPSBmYWxzZTtcbiAgICAgICAgbGV0IHJlID0gJyc7XG4gICAgICAgIGxldCB1ZmxhZyA9IGZhbHNlO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGdsb2IubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGMgPSBnbG9iLmNoYXJBdChpKTtcbiAgICAgICAgICAgIGlmIChlc2NhcGluZykge1xuICAgICAgICAgICAgICAgIGVzY2FwaW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgcmUgKz0gKHJlU3BlY2lhbHMuaGFzKGMpID8gJ1xcXFwnIDogJycpICsgYztcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjID09PSAnXFxcXCcpIHtcbiAgICAgICAgICAgICAgICBpZiAoaSA9PT0gZ2xvYi5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlICs9ICdcXFxcXFxcXCc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBlc2NhcGluZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGMgPT09ICdbJykge1xuICAgICAgICAgICAgICAgIGNvbnN0IFtzcmMsIG5lZWRVZmxhZywgY29uc3VtZWQsIG1hZ2ljXSA9ICgwLCBicmFjZV9leHByZXNzaW9uc19qc18xLnBhcnNlQ2xhc3MpKGdsb2IsIGkpO1xuICAgICAgICAgICAgICAgIGlmIChjb25zdW1lZCkge1xuICAgICAgICAgICAgICAgICAgICByZSArPSBzcmM7XG4gICAgICAgICAgICAgICAgICAgIHVmbGFnID0gdWZsYWcgfHwgbmVlZFVmbGFnO1xuICAgICAgICAgICAgICAgICAgICBpICs9IGNvbnN1bWVkIC0gMTtcbiAgICAgICAgICAgICAgICAgICAgaGFzTWFnaWMgPSBoYXNNYWdpYyB8fCBtYWdpYztcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGMgPT09ICcqJykge1xuICAgICAgICAgICAgICAgIGlmIChub0VtcHR5ICYmIGdsb2IgPT09ICcqJylcbiAgICAgICAgICAgICAgICAgICAgcmUgKz0gc3Rhck5vRW1wdHk7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICByZSArPSBzdGFyO1xuICAgICAgICAgICAgICAgIGhhc01hZ2ljID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjID09PSAnPycpIHtcbiAgICAgICAgICAgICAgICByZSArPSBxbWFyaztcbiAgICAgICAgICAgICAgICBoYXNNYWdpYyA9IHRydWU7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZSArPSByZWdFeHBFc2NhcGUoYyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtyZSwgKDAsIHVuZXNjYXBlX2pzXzEudW5lc2NhcGUpKGdsb2IpLCAhIWhhc01hZ2ljLCB1ZmxhZ107XG4gICAgfVxufVxuZXhwb3J0cy5BU1QgPSBBU1Q7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hc3QuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/minimatch/dist/commonjs/ast.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/minimatch/dist/commonjs/brace-expressions.js":
/*!*******************************************************************!*\
  !*** ./node_modules/minimatch/dist/commonjs/brace-expressions.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n// translate the various posix character classes into unicode properties\n// this works across all unicode locales\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.parseClass = void 0;\n// { <posix class>: [<translation>, /u flag required, negated]\nconst posixClasses = {\n    '[:alnum:]': ['\\\\p{L}\\\\p{Nl}\\\\p{Nd}', true],\n    '[:alpha:]': ['\\\\p{L}\\\\p{Nl}', true],\n    '[:ascii:]': ['\\\\x' + '00-\\\\x' + '7f', false],\n    '[:blank:]': ['\\\\p{Zs}\\\\t', true],\n    '[:cntrl:]': ['\\\\p{Cc}', true],\n    '[:digit:]': ['\\\\p{Nd}', true],\n    '[:graph:]': ['\\\\p{Z}\\\\p{C}', true, true],\n    '[:lower:]': ['\\\\p{Ll}', true],\n    '[:print:]': ['\\\\p{C}', true],\n    '[:punct:]': ['\\\\p{P}', true],\n    '[:space:]': ['\\\\p{Z}\\\\t\\\\r\\\\n\\\\v\\\\f', true],\n    '[:upper:]': ['\\\\p{Lu}', true],\n    '[:word:]': ['\\\\p{L}\\\\p{Nl}\\\\p{Nd}\\\\p{Pc}', true],\n    '[:xdigit:]': ['A-Fa-f0-9', false],\n};\n// only need to escape a few things inside of brace expressions\n// escapes: [ \\ ] -\nconst braceEscape = (s) => s.replace(/[[\\]\\\\-]/g, '\\\\$&');\n// escape all regexp magic characters\nconst regexpEscape = (s) => s.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, '\\\\$&');\n// everything has already been escaped, we just have to join\nconst rangesToString = (ranges) => ranges.join('');\n// takes a glob string at a posix brace expression, and returns\n// an equivalent regular expression source, and boolean indicating\n// whether the /u flag needs to be applied, and the number of chars\n// consumed to parse the character class.\n// This also removes out of order ranges, and returns ($.) if the\n// entire class just no good.\nconst parseClass = (glob, position) => {\n    const pos = position;\n    /* c8 ignore start */\n    if (glob.charAt(pos) !== '[') {\n        throw new Error('not in a brace expression');\n    }\n    /* c8 ignore stop */\n    const ranges = [];\n    const negs = [];\n    let i = pos + 1;\n    let sawStart = false;\n    let uflag = false;\n    let escaping = false;\n    let negate = false;\n    let endPos = pos;\n    let rangeStart = '';\n    WHILE: while (i < glob.length) {\n        const c = glob.charAt(i);\n        if ((c === '!' || c === '^') && i === pos + 1) {\n            negate = true;\n            i++;\n            continue;\n        }\n        if (c === ']' && sawStart && !escaping) {\n            endPos = i + 1;\n            break;\n        }\n        sawStart = true;\n        if (c === '\\\\') {\n            if (!escaping) {\n                escaping = true;\n                i++;\n                continue;\n            }\n            // escaped \\ char, fall through and treat like normal char\n        }\n        if (c === '[' && !escaping) {\n            // either a posix class, a collation equivalent, or just a [\n            for (const [cls, [unip, u, neg]] of Object.entries(posixClasses)) {\n                if (glob.startsWith(cls, i)) {\n                    // invalid, [a-[] is fine, but not [a-[:alpha]]\n                    if (rangeStart) {\n                        return ['$.', false, glob.length - pos, true];\n                    }\n                    i += cls.length;\n                    if (neg)\n                        negs.push(unip);\n                    else\n                        ranges.push(unip);\n                    uflag = uflag || u;\n                    continue WHILE;\n                }\n            }\n        }\n        // now it's just a normal character, effectively\n        escaping = false;\n        if (rangeStart) {\n            // throw this range away if it's not valid, but others\n            // can still match.\n            if (c > rangeStart) {\n                ranges.push(braceEscape(rangeStart) + '-' + braceEscape(c));\n            }\n            else if (c === rangeStart) {\n                ranges.push(braceEscape(c));\n            }\n            rangeStart = '';\n            i++;\n            continue;\n        }\n        // now might be the start of a range.\n        // can be either c-d or c-] or c<more...>] or c] at this point\n        if (glob.startsWith('-]', i + 1)) {\n            ranges.push(braceEscape(c + '-'));\n            i += 2;\n            continue;\n        }\n        if (glob.startsWith('-', i + 1)) {\n            rangeStart = c;\n            i += 2;\n            continue;\n        }\n        // not the start of a range, just a single character\n        ranges.push(braceEscape(c));\n        i++;\n    }\n    if (endPos < i) {\n        // didn't see the end of the class, not a valid class,\n        // but might still be valid as a literal match.\n        return ['', false, 0, false];\n    }\n    // if we got no ranges and no negates, then we have a range that\n    // cannot possibly match anything, and that poisons the whole glob\n    if (!ranges.length && !negs.length) {\n        return ['$.', false, glob.length - pos, true];\n    }\n    // if we got one positive range, and it's a single character, then that's\n    // not actually a magic pattern, it's just that one literal character.\n    // we should not treat that as \"magic\", we should just return the literal\n    // character. [_] is a perfectly valid way to escape glob magic chars.\n    if (negs.length === 0 &&\n        ranges.length === 1 &&\n        /^\\\\?.$/.test(ranges[0]) &&\n        !negate) {\n        const r = ranges[0].length === 2 ? ranges[0].slice(-1) : ranges[0];\n        return [regexpEscape(r), false, endPos - pos, false];\n    }\n    const sranges = '[' + (negate ? '^' : '') + rangesToString(ranges) + ']';\n    const snegs = '[' + (negate ? '' : '^') + rangesToString(negs) + ']';\n    const comb = ranges.length && negs.length\n        ? '(' + sranges + '|' + snegs + ')'\n        : ranges.length\n            ? sranges\n            : snegs;\n    return [comb, uflag, endPos - pos, true];\n};\nexports.parseClass = parseClass;\n//# sourceMappingURL=brace-expressions.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbWluaW1hdGNoL2Rpc3QvY29tbW9uanMvYnJhY2UtZXhwcmVzc2lvbnMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGtCQUFrQjtBQUNsQixLQUFLO0FBQ0w7QUFDQSx1QkFBdUIsRUFBRSxJQUFJLEdBQUcsSUFBSSxHQUFHO0FBQ3ZDLHVCQUF1QixFQUFFLElBQUksR0FBRztBQUNoQztBQUNBLHVCQUF1QixHQUFHO0FBQzFCLHVCQUF1QixHQUFHO0FBQzFCLHVCQUF1QixHQUFHO0FBQzFCLHVCQUF1QixFQUFFLElBQUksRUFBRTtBQUMvQix1QkFBdUIsR0FBRztBQUMxQix1QkFBdUIsRUFBRTtBQUN6Qix1QkFBdUIsRUFBRTtBQUN6Qix1QkFBdUIsRUFBRTtBQUN6Qix1QkFBdUIsR0FBRztBQUMxQixzQkFBc0IsRUFBRSxJQUFJLEdBQUcsSUFBSSxHQUFHLElBQUksR0FBRztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYXV0by1sb29wLWRlbW8vLi9ub2RlX21vZHVsZXMvbWluaW1hdGNoL2Rpc3QvY29tbW9uanMvYnJhY2UtZXhwcmVzc2lvbnMuanM/ZjU3MCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8vIHRyYW5zbGF0ZSB0aGUgdmFyaW91cyBwb3NpeCBjaGFyYWN0ZXIgY2xhc3NlcyBpbnRvIHVuaWNvZGUgcHJvcGVydGllc1xuLy8gdGhpcyB3b3JrcyBhY3Jvc3MgYWxsIHVuaWNvZGUgbG9jYWxlc1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5wYXJzZUNsYXNzID0gdm9pZCAwO1xuLy8geyA8cG9zaXggY2xhc3M+OiBbPHRyYW5zbGF0aW9uPiwgL3UgZmxhZyByZXF1aXJlZCwgbmVnYXRlZF1cbmNvbnN0IHBvc2l4Q2xhc3NlcyA9IHtcbiAgICAnWzphbG51bTpdJzogWydcXFxccHtMfVxcXFxwe05sfVxcXFxwe05kfScsIHRydWVdLFxuICAgICdbOmFscGhhOl0nOiBbJ1xcXFxwe0x9XFxcXHB7Tmx9JywgdHJ1ZV0sXG4gICAgJ1s6YXNjaWk6XSc6IFsnXFxcXHgnICsgJzAwLVxcXFx4JyArICc3ZicsIGZhbHNlXSxcbiAgICAnWzpibGFuazpdJzogWydcXFxccHtac31cXFxcdCcsIHRydWVdLFxuICAgICdbOmNudHJsOl0nOiBbJ1xcXFxwe0NjfScsIHRydWVdLFxuICAgICdbOmRpZ2l0Ol0nOiBbJ1xcXFxwe05kfScsIHRydWVdLFxuICAgICdbOmdyYXBoOl0nOiBbJ1xcXFxwe1p9XFxcXHB7Q30nLCB0cnVlLCB0cnVlXSxcbiAgICAnWzpsb3dlcjpdJzogWydcXFxccHtMbH0nLCB0cnVlXSxcbiAgICAnWzpwcmludDpdJzogWydcXFxccHtDfScsIHRydWVdLFxuICAgICdbOnB1bmN0Ol0nOiBbJ1xcXFxwe1B9JywgdHJ1ZV0sXG4gICAgJ1s6c3BhY2U6XSc6IFsnXFxcXHB7Wn1cXFxcdFxcXFxyXFxcXG5cXFxcdlxcXFxmJywgdHJ1ZV0sXG4gICAgJ1s6dXBwZXI6XSc6IFsnXFxcXHB7THV9JywgdHJ1ZV0sXG4gICAgJ1s6d29yZDpdJzogWydcXFxccHtMfVxcXFxwe05sfVxcXFxwe05kfVxcXFxwe1BjfScsIHRydWVdLFxuICAgICdbOnhkaWdpdDpdJzogWydBLUZhLWYwLTknLCBmYWxzZV0sXG59O1xuLy8gb25seSBuZWVkIHRvIGVzY2FwZSBhIGZldyB0aGluZ3MgaW5zaWRlIG9mIGJyYWNlIGV4cHJlc3Npb25zXG4vLyBlc2NhcGVzOiBbIFxcIF0gLVxuY29uc3QgYnJhY2VFc2NhcGUgPSAocykgPT4gcy5yZXBsYWNlKC9bW1xcXVxcXFwtXS9nLCAnXFxcXCQmJyk7XG4vLyBlc2NhcGUgYWxsIHJlZ2V4cCBtYWdpYyBjaGFyYWN0ZXJzXG5jb25zdCByZWdleHBFc2NhcGUgPSAocykgPT4gcy5yZXBsYWNlKC9bLVtcXF17fSgpKis/LixcXFxcXiR8I1xcc10vZywgJ1xcXFwkJicpO1xuLy8gZXZlcnl0aGluZyBoYXMgYWxyZWFkeSBiZWVuIGVzY2FwZWQsIHdlIGp1c3QgaGF2ZSB0byBqb2luXG5jb25zdCByYW5nZXNUb1N0cmluZyA9IChyYW5nZXMpID0+IHJhbmdlcy5qb2luKCcnKTtcbi8vIHRha2VzIGEgZ2xvYiBzdHJpbmcgYXQgYSBwb3NpeCBicmFjZSBleHByZXNzaW9uLCBhbmQgcmV0dXJuc1xuLy8gYW4gZXF1aXZhbGVudCByZWd1bGFyIGV4cHJlc3Npb24gc291cmNlLCBhbmQgYm9vbGVhbiBpbmRpY2F0aW5nXG4vLyB3aGV0aGVyIHRoZSAvdSBmbGFnIG5lZWRzIHRvIGJlIGFwcGxpZWQsIGFuZCB0aGUgbnVtYmVyIG9mIGNoYXJzXG4vLyBjb25zdW1lZCB0byBwYXJzZSB0aGUgY2hhcmFjdGVyIGNsYXNzLlxuLy8gVGhpcyBhbHNvIHJlbW92ZXMgb3V0IG9mIG9yZGVyIHJhbmdlcywgYW5kIHJldHVybnMgKCQuKSBpZiB0aGVcbi8vIGVudGlyZSBjbGFzcyBqdXN0IG5vIGdvb2QuXG5jb25zdCBwYXJzZUNsYXNzID0gKGdsb2IsIHBvc2l0aW9uKSA9PiB7XG4gICAgY29uc3QgcG9zID0gcG9zaXRpb247XG4gICAgLyogYzggaWdub3JlIHN0YXJ0ICovXG4gICAgaWYgKGdsb2IuY2hhckF0KHBvcykgIT09ICdbJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ25vdCBpbiBhIGJyYWNlIGV4cHJlc3Npb24nKTtcbiAgICB9XG4gICAgLyogYzggaWdub3JlIHN0b3AgKi9cbiAgICBjb25zdCByYW5nZXMgPSBbXTtcbiAgICBjb25zdCBuZWdzID0gW107XG4gICAgbGV0IGkgPSBwb3MgKyAxO1xuICAgIGxldCBzYXdTdGFydCA9IGZhbHNlO1xuICAgIGxldCB1ZmxhZyA9IGZhbHNlO1xuICAgIGxldCBlc2NhcGluZyA9IGZhbHNlO1xuICAgIGxldCBuZWdhdGUgPSBmYWxzZTtcbiAgICBsZXQgZW5kUG9zID0gcG9zO1xuICAgIGxldCByYW5nZVN0YXJ0ID0gJyc7XG4gICAgV0hJTEU6IHdoaWxlIChpIDwgZ2xvYi5sZW5ndGgpIHtcbiAgICAgICAgY29uc3QgYyA9IGdsb2IuY2hhckF0KGkpO1xuICAgICAgICBpZiAoKGMgPT09ICchJyB8fCBjID09PSAnXicpICYmIGkgPT09IHBvcyArIDEpIHtcbiAgICAgICAgICAgIG5lZ2F0ZSA9IHRydWU7XG4gICAgICAgICAgICBpKys7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYyA9PT0gJ10nICYmIHNhd1N0YXJ0ICYmICFlc2NhcGluZykge1xuICAgICAgICAgICAgZW5kUG9zID0gaSArIDE7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBzYXdTdGFydCA9IHRydWU7XG4gICAgICAgIGlmIChjID09PSAnXFxcXCcpIHtcbiAgICAgICAgICAgIGlmICghZXNjYXBpbmcpIHtcbiAgICAgICAgICAgICAgICBlc2NhcGluZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gZXNjYXBlZCBcXCBjaGFyLCBmYWxsIHRocm91Z2ggYW5kIHRyZWF0IGxpa2Ugbm9ybWFsIGNoYXJcbiAgICAgICAgfVxuICAgICAgICBpZiAoYyA9PT0gJ1snICYmICFlc2NhcGluZykge1xuICAgICAgICAgICAgLy8gZWl0aGVyIGEgcG9zaXggY2xhc3MsIGEgY29sbGF0aW9uIGVxdWl2YWxlbnQsIG9yIGp1c3QgYSBbXG4gICAgICAgICAgICBmb3IgKGNvbnN0IFtjbHMsIFt1bmlwLCB1LCBuZWddXSBvZiBPYmplY3QuZW50cmllcyhwb3NpeENsYXNzZXMpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGdsb2Iuc3RhcnRzV2l0aChjbHMsIGkpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGludmFsaWQsIFthLVtdIGlzIGZpbmUsIGJ1dCBub3QgW2EtWzphbHBoYV1dXG4gICAgICAgICAgICAgICAgICAgIGlmIChyYW5nZVN0YXJ0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWyckLicsIGZhbHNlLCBnbG9iLmxlbmd0aCAtIHBvcywgdHJ1ZV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaSArPSBjbHMubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICBpZiAobmVnKVxuICAgICAgICAgICAgICAgICAgICAgICAgbmVncy5wdXNoKHVuaXApO1xuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICByYW5nZXMucHVzaCh1bmlwKTtcbiAgICAgICAgICAgICAgICAgICAgdWZsYWcgPSB1ZmxhZyB8fCB1O1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZSBXSElMRTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gbm93IGl0J3MganVzdCBhIG5vcm1hbCBjaGFyYWN0ZXIsIGVmZmVjdGl2ZWx5XG4gICAgICAgIGVzY2FwaW5nID0gZmFsc2U7XG4gICAgICAgIGlmIChyYW5nZVN0YXJ0KSB7XG4gICAgICAgICAgICAvLyB0aHJvdyB0aGlzIHJhbmdlIGF3YXkgaWYgaXQncyBub3QgdmFsaWQsIGJ1dCBvdGhlcnNcbiAgICAgICAgICAgIC8vIGNhbiBzdGlsbCBtYXRjaC5cbiAgICAgICAgICAgIGlmIChjID4gcmFuZ2VTdGFydCkge1xuICAgICAgICAgICAgICAgIHJhbmdlcy5wdXNoKGJyYWNlRXNjYXBlKHJhbmdlU3RhcnQpICsgJy0nICsgYnJhY2VFc2NhcGUoYykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYyA9PT0gcmFuZ2VTdGFydCkge1xuICAgICAgICAgICAgICAgIHJhbmdlcy5wdXNoKGJyYWNlRXNjYXBlKGMpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJhbmdlU3RhcnQgPSAnJztcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIG5vdyBtaWdodCBiZSB0aGUgc3RhcnQgb2YgYSByYW5nZS5cbiAgICAgICAgLy8gY2FuIGJlIGVpdGhlciBjLWQgb3IgYy1dIG9yIGM8bW9yZS4uLj5dIG9yIGNdIGF0IHRoaXMgcG9pbnRcbiAgICAgICAgaWYgKGdsb2Iuc3RhcnRzV2l0aCgnLV0nLCBpICsgMSkpIHtcbiAgICAgICAgICAgIHJhbmdlcy5wdXNoKGJyYWNlRXNjYXBlKGMgKyAnLScpKTtcbiAgICAgICAgICAgIGkgKz0gMjtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChnbG9iLnN0YXJ0c1dpdGgoJy0nLCBpICsgMSkpIHtcbiAgICAgICAgICAgIHJhbmdlU3RhcnQgPSBjO1xuICAgICAgICAgICAgaSArPSAyO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gbm90IHRoZSBzdGFydCBvZiBhIHJhbmdlLCBqdXN0IGEgc2luZ2xlIGNoYXJhY3RlclxuICAgICAgICByYW5nZXMucHVzaChicmFjZUVzY2FwZShjKSk7XG4gICAgICAgIGkrKztcbiAgICB9XG4gICAgaWYgKGVuZFBvcyA8IGkpIHtcbiAgICAgICAgLy8gZGlkbid0IHNlZSB0aGUgZW5kIG9mIHRoZSBjbGFzcywgbm90IGEgdmFsaWQgY2xhc3MsXG4gICAgICAgIC8vIGJ1dCBtaWdodCBzdGlsbCBiZSB2YWxpZCBhcyBhIGxpdGVyYWwgbWF0Y2guXG4gICAgICAgIHJldHVybiBbJycsIGZhbHNlLCAwLCBmYWxzZV07XG4gICAgfVxuICAgIC8vIGlmIHdlIGdvdCBubyByYW5nZXMgYW5kIG5vIG5lZ2F0ZXMsIHRoZW4gd2UgaGF2ZSBhIHJhbmdlIHRoYXRcbiAgICAvLyBjYW5ub3QgcG9zc2libHkgbWF0Y2ggYW55dGhpbmcsIGFuZCB0aGF0IHBvaXNvbnMgdGhlIHdob2xlIGdsb2JcbiAgICBpZiAoIXJhbmdlcy5sZW5ndGggJiYgIW5lZ3MubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBbJyQuJywgZmFsc2UsIGdsb2IubGVuZ3RoIC0gcG9zLCB0cnVlXTtcbiAgICB9XG4gICAgLy8gaWYgd2UgZ290IG9uZSBwb3NpdGl2ZSByYW5nZSwgYW5kIGl0J3MgYSBzaW5nbGUgY2hhcmFjdGVyLCB0aGVuIHRoYXQnc1xuICAgIC8vIG5vdCBhY3R1YWxseSBhIG1hZ2ljIHBhdHRlcm4sIGl0J3MganVzdCB0aGF0IG9uZSBsaXRlcmFsIGNoYXJhY3Rlci5cbiAgICAvLyB3ZSBzaG91bGQgbm90IHRyZWF0IHRoYXQgYXMgXCJtYWdpY1wiLCB3ZSBzaG91bGQganVzdCByZXR1cm4gdGhlIGxpdGVyYWxcbiAgICAvLyBjaGFyYWN0ZXIuIFtfXSBpcyBhIHBlcmZlY3RseSB2YWxpZCB3YXkgdG8gZXNjYXBlIGdsb2IgbWFnaWMgY2hhcnMuXG4gICAgaWYgKG5lZ3MubGVuZ3RoID09PSAwICYmXG4gICAgICAgIHJhbmdlcy5sZW5ndGggPT09IDEgJiZcbiAgICAgICAgL15cXFxcPy4kLy50ZXN0KHJhbmdlc1swXSkgJiZcbiAgICAgICAgIW5lZ2F0ZSkge1xuICAgICAgICBjb25zdCByID0gcmFuZ2VzWzBdLmxlbmd0aCA9PT0gMiA/IHJhbmdlc1swXS5zbGljZSgtMSkgOiByYW5nZXNbMF07XG4gICAgICAgIHJldHVybiBbcmVnZXhwRXNjYXBlKHIpLCBmYWxzZSwgZW5kUG9zIC0gcG9zLCBmYWxzZV07XG4gICAgfVxuICAgIGNvbnN0IHNyYW5nZXMgPSAnWycgKyAobmVnYXRlID8gJ14nIDogJycpICsgcmFuZ2VzVG9TdHJpbmcocmFuZ2VzKSArICddJztcbiAgICBjb25zdCBzbmVncyA9ICdbJyArIChuZWdhdGUgPyAnJyA6ICdeJykgKyByYW5nZXNUb1N0cmluZyhuZWdzKSArICddJztcbiAgICBjb25zdCBjb21iID0gcmFuZ2VzLmxlbmd0aCAmJiBuZWdzLmxlbmd0aFxuICAgICAgICA/ICcoJyArIHNyYW5nZXMgKyAnfCcgKyBzbmVncyArICcpJ1xuICAgICAgICA6IHJhbmdlcy5sZW5ndGhcbiAgICAgICAgICAgID8gc3Jhbmdlc1xuICAgICAgICAgICAgOiBzbmVncztcbiAgICByZXR1cm4gW2NvbWIsIHVmbGFnLCBlbmRQb3MgLSBwb3MsIHRydWVdO1xufTtcbmV4cG9ydHMucGFyc2VDbGFzcyA9IHBhcnNlQ2xhc3M7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1icmFjZS1leHByZXNzaW9ucy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/minimatch/dist/commonjs/brace-expressions.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/minimatch/dist/commonjs/escape.js":
/*!********************************************************!*\
  !*** ./node_modules/minimatch/dist/commonjs/escape.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.escape = void 0;\n/**\n * Escape all magic characters in a glob pattern.\n *\n * If the {@link windowsPathsNoEscape | GlobOptions.windowsPathsNoEscape}\n * option is used, then characters are escaped by wrapping in `[]`, because\n * a magic character wrapped in a character class can only be satisfied by\n * that exact character.  In this mode, `\\` is _not_ escaped, because it is\n * not interpreted as a magic character, but instead as a path separator.\n */\nconst escape = (s, { windowsPathsNoEscape = false, } = {}) => {\n    // don't need to escape +@! because we escape the parens\n    // that make those magic, and escaping ! as [!] isn't valid,\n    // because [!]] is a valid glob class meaning not ']'.\n    return windowsPathsNoEscape\n        ? s.replace(/[?*()[\\]]/g, '[$&]')\n        : s.replace(/[?*()[\\]\\\\]/g, '\\\\$&');\n};\nexports.escape = escape;\n//# sourceMappingURL=escape.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbWluaW1hdGNoL2Rpc3QvY29tbW9uanMvZXNjYXBlLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixnQ0FBZ0MsSUFBSTtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZCIsInNvdXJjZXMiOlsid2VicGFjazovL2F1dG8tbG9vcC1kZW1vLy4vbm9kZV9tb2R1bGVzL21pbmltYXRjaC9kaXN0L2NvbW1vbmpzL2VzY2FwZS5qcz9kYzJhIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5lc2NhcGUgPSB2b2lkIDA7XG4vKipcbiAqIEVzY2FwZSBhbGwgbWFnaWMgY2hhcmFjdGVycyBpbiBhIGdsb2IgcGF0dGVybi5cbiAqXG4gKiBJZiB0aGUge0BsaW5rIHdpbmRvd3NQYXRoc05vRXNjYXBlIHwgR2xvYk9wdGlvbnMud2luZG93c1BhdGhzTm9Fc2NhcGV9XG4gKiBvcHRpb24gaXMgdXNlZCwgdGhlbiBjaGFyYWN0ZXJzIGFyZSBlc2NhcGVkIGJ5IHdyYXBwaW5nIGluIGBbXWAsIGJlY2F1c2VcbiAqIGEgbWFnaWMgY2hhcmFjdGVyIHdyYXBwZWQgaW4gYSBjaGFyYWN0ZXIgY2xhc3MgY2FuIG9ubHkgYmUgc2F0aXNmaWVkIGJ5XG4gKiB0aGF0IGV4YWN0IGNoYXJhY3Rlci4gIEluIHRoaXMgbW9kZSwgYFxcYCBpcyBfbm90XyBlc2NhcGVkLCBiZWNhdXNlIGl0IGlzXG4gKiBub3QgaW50ZXJwcmV0ZWQgYXMgYSBtYWdpYyBjaGFyYWN0ZXIsIGJ1dCBpbnN0ZWFkIGFzIGEgcGF0aCBzZXBhcmF0b3IuXG4gKi9cbmNvbnN0IGVzY2FwZSA9IChzLCB7IHdpbmRvd3NQYXRoc05vRXNjYXBlID0gZmFsc2UsIH0gPSB7fSkgPT4ge1xuICAgIC8vIGRvbid0IG5lZWQgdG8gZXNjYXBlICtAISBiZWNhdXNlIHdlIGVzY2FwZSB0aGUgcGFyZW5zXG4gICAgLy8gdGhhdCBtYWtlIHRob3NlIG1hZ2ljLCBhbmQgZXNjYXBpbmcgISBhcyBbIV0gaXNuJ3QgdmFsaWQsXG4gICAgLy8gYmVjYXVzZSBbIV1dIGlzIGEgdmFsaWQgZ2xvYiBjbGFzcyBtZWFuaW5nIG5vdCAnXScuXG4gICAgcmV0dXJuIHdpbmRvd3NQYXRoc05vRXNjYXBlXG4gICAgICAgID8gcy5yZXBsYWNlKC9bPyooKVtcXF1dL2csICdbJCZdJylcbiAgICAgICAgOiBzLnJlcGxhY2UoL1s/KigpW1xcXVxcXFxdL2csICdcXFxcJCYnKTtcbn07XG5leHBvcnRzLmVzY2FwZSA9IGVzY2FwZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWVzY2FwZS5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/minimatch/dist/commonjs/escape.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/minimatch/dist/commonjs/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/minimatch/dist/commonjs/index.js ***!
  \*******************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.unescape = exports.escape = exports.AST = exports.Minimatch = exports.match = exports.makeRe = exports.braceExpand = exports.defaults = exports.filter = exports.GLOBSTAR = exports.sep = exports.minimatch = void 0;\nconst brace_expansion_1 = __importDefault(__webpack_require__(/*! brace-expansion */ \"(ssr)/./node_modules/brace-expansion/index.js\"));\nconst assert_valid_pattern_js_1 = __webpack_require__(/*! ./assert-valid-pattern.js */ \"(ssr)/./node_modules/minimatch/dist/commonjs/assert-valid-pattern.js\");\nconst ast_js_1 = __webpack_require__(/*! ./ast.js */ \"(ssr)/./node_modules/minimatch/dist/commonjs/ast.js\");\nconst escape_js_1 = __webpack_require__(/*! ./escape.js */ \"(ssr)/./node_modules/minimatch/dist/commonjs/escape.js\");\nconst unescape_js_1 = __webpack_require__(/*! ./unescape.js */ \"(ssr)/./node_modules/minimatch/dist/commonjs/unescape.js\");\nconst minimatch = (p, pattern, options = {}) => {\n    (0, assert_valid_pattern_js_1.assertValidPattern)(pattern);\n    // shortcut: comments match nothing.\n    if (!options.nocomment && pattern.charAt(0) === '#') {\n        return false;\n    }\n    return new Minimatch(pattern, options).match(p);\n};\nexports.minimatch = minimatch;\n// Optimized checking for the most common glob patterns.\nconst starDotExtRE = /^\\*+([^+@!?\\*\\[\\(]*)$/;\nconst starDotExtTest = (ext) => (f) => !f.startsWith('.') && f.endsWith(ext);\nconst starDotExtTestDot = (ext) => (f) => f.endsWith(ext);\nconst starDotExtTestNocase = (ext) => {\n    ext = ext.toLowerCase();\n    return (f) => !f.startsWith('.') && f.toLowerCase().endsWith(ext);\n};\nconst starDotExtTestNocaseDot = (ext) => {\n    ext = ext.toLowerCase();\n    return (f) => f.toLowerCase().endsWith(ext);\n};\nconst starDotStarRE = /^\\*+\\.\\*+$/;\nconst starDotStarTest = (f) => !f.startsWith('.') && f.includes('.');\nconst starDotStarTestDot = (f) => f !== '.' && f !== '..' && f.includes('.');\nconst dotStarRE = /^\\.\\*+$/;\nconst dotStarTest = (f) => f !== '.' && f !== '..' && f.startsWith('.');\nconst starRE = /^\\*+$/;\nconst starTest = (f) => f.length !== 0 && !f.startsWith('.');\nconst starTestDot = (f) => f.length !== 0 && f !== '.' && f !== '..';\nconst qmarksRE = /^\\?+([^+@!?\\*\\[\\(]*)?$/;\nconst qmarksTestNocase = ([$0, ext = '']) => {\n    const noext = qmarksTestNoExt([$0]);\n    if (!ext)\n        return noext;\n    ext = ext.toLowerCase();\n    return (f) => noext(f) && f.toLowerCase().endsWith(ext);\n};\nconst qmarksTestNocaseDot = ([$0, ext = '']) => {\n    const noext = qmarksTestNoExtDot([$0]);\n    if (!ext)\n        return noext;\n    ext = ext.toLowerCase();\n    return (f) => noext(f) && f.toLowerCase().endsWith(ext);\n};\nconst qmarksTestDot = ([$0, ext = '']) => {\n    const noext = qmarksTestNoExtDot([$0]);\n    return !ext ? noext : (f) => noext(f) && f.endsWith(ext);\n};\nconst qmarksTest = ([$0, ext = '']) => {\n    const noext = qmarksTestNoExt([$0]);\n    return !ext ? noext : (f) => noext(f) && f.endsWith(ext);\n};\nconst qmarksTestNoExt = ([$0]) => {\n    const len = $0.length;\n    return (f) => f.length === len && !f.startsWith('.');\n};\nconst qmarksTestNoExtDot = ([$0]) => {\n    const len = $0.length;\n    return (f) => f.length === len && f !== '.' && f !== '..';\n};\n/* c8 ignore start */\nconst defaultPlatform = (typeof process === 'object' && process\n    ? (typeof process.env === 'object' &&\n        process.env &&\n        process.env.__MINIMATCH_TESTING_PLATFORM__) ||\n        process.platform\n    : 'posix');\nconst path = {\n    win32: { sep: '\\\\' },\n    posix: { sep: '/' },\n};\n/* c8 ignore stop */\nexports.sep = defaultPlatform === 'win32' ? path.win32.sep : path.posix.sep;\nexports.minimatch.sep = exports.sep;\nexports.GLOBSTAR = Symbol('globstar **');\nexports.minimatch.GLOBSTAR = exports.GLOBSTAR;\n// any single thing other than /\n// don't need to escape / when using new RegExp()\nconst qmark = '[^/]';\n// * => any number of characters\nconst star = qmark + '*?';\n// ** when dots are allowed.  Anything goes, except .. and .\n// not (^ or / followed by one or two dots followed by $ or /),\n// followed by anything, any number of times.\nconst twoStarDot = '(?:(?!(?:\\\\/|^)(?:\\\\.{1,2})($|\\\\/)).)*?';\n// not a ^ or / followed by a dot,\n// followed by anything, any number of times.\nconst twoStarNoDot = '(?:(?!(?:\\\\/|^)\\\\.).)*?';\nconst filter = (pattern, options = {}) => (p) => (0, exports.minimatch)(p, pattern, options);\nexports.filter = filter;\nexports.minimatch.filter = exports.filter;\nconst ext = (a, b = {}) => Object.assign({}, a, b);\nconst defaults = (def) => {\n    if (!def || typeof def !== 'object' || !Object.keys(def).length) {\n        return exports.minimatch;\n    }\n    const orig = exports.minimatch;\n    const m = (p, pattern, options = {}) => orig(p, pattern, ext(def, options));\n    return Object.assign(m, {\n        Minimatch: class Minimatch extends orig.Minimatch {\n            constructor(pattern, options = {}) {\n                super(pattern, ext(def, options));\n            }\n            static defaults(options) {\n                return orig.defaults(ext(def, options)).Minimatch;\n            }\n        },\n        AST: class AST extends orig.AST {\n            /* c8 ignore start */\n            constructor(type, parent, options = {}) {\n                super(type, parent, ext(def, options));\n            }\n            /* c8 ignore stop */\n            static fromGlob(pattern, options = {}) {\n                return orig.AST.fromGlob(pattern, ext(def, options));\n            }\n        },\n        unescape: (s, options = {}) => orig.unescape(s, ext(def, options)),\n        escape: (s, options = {}) => orig.escape(s, ext(def, options)),\n        filter: (pattern, options = {}) => orig.filter(pattern, ext(def, options)),\n        defaults: (options) => orig.defaults(ext(def, options)),\n        makeRe: (pattern, options = {}) => orig.makeRe(pattern, ext(def, options)),\n        braceExpand: (pattern, options = {}) => orig.braceExpand(pattern, ext(def, options)),\n        match: (list, pattern, options = {}) => orig.match(list, pattern, ext(def, options)),\n        sep: orig.sep,\n        GLOBSTAR: exports.GLOBSTAR,\n    });\n};\nexports.defaults = defaults;\nexports.minimatch.defaults = exports.defaults;\n// Brace expansion:\n// a{b,c}d -> abd acd\n// a{b,}c -> abc ac\n// a{0..3}d -> a0d a1d a2d a3d\n// a{b,c{d,e}f}g -> abg acdfg acefg\n// a{b,c}d{e,f}g -> abdeg acdeg abdeg abdfg\n//\n// Invalid sets are not expanded.\n// a{2..}b -> a{2..}b\n// a{b}c -> a{b}c\nconst braceExpand = (pattern, options = {}) => {\n    (0, assert_valid_pattern_js_1.assertValidPattern)(pattern);\n    // Thanks to Yeting Li <https://github.com/yetingli> for\n    // improving this regexp to avoid a ReDOS vulnerability.\n    if (options.nobrace || !/\\{(?:(?!\\{).)*\\}/.test(pattern)) {\n        // shortcut. no need to expand.\n        return [pattern];\n    }\n    return (0, brace_expansion_1.default)(pattern);\n};\nexports.braceExpand = braceExpand;\nexports.minimatch.braceExpand = exports.braceExpand;\n// parse a component of the expanded set.\n// At this point, no pattern may contain \"/\" in it\n// so we're going to return a 2d array, where each entry is the full\n// pattern, split on '/', and then turned into a regular expression.\n// A regexp is made at the end which joins each array with an\n// escaped /, and another full one which joins each regexp with |.\n//\n// Following the lead of Bash 4.1, note that \"**\" only has special meaning\n// when it is the *only* thing in a path portion.  Otherwise, any series\n// of * is equivalent to a single *.  Globstar behavior is enabled by\n// default, and can be disabled by setting options.noglobstar.\nconst makeRe = (pattern, options = {}) => new Minimatch(pattern, options).makeRe();\nexports.makeRe = makeRe;\nexports.minimatch.makeRe = exports.makeRe;\nconst match = (list, pattern, options = {}) => {\n    const mm = new Minimatch(pattern, options);\n    list = list.filter(f => mm.match(f));\n    if (mm.options.nonull && !list.length) {\n        list.push(pattern);\n    }\n    return list;\n};\nexports.match = match;\nexports.minimatch.match = exports.match;\n// replace stuff like \\* with *\nconst globMagic = /[?*]|[+@!]\\(.*?\\)|\\[|\\]/;\nconst regExpEscape = (s) => s.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, '\\\\$&');\nclass Minimatch {\n    options;\n    set;\n    pattern;\n    windowsPathsNoEscape;\n    nonegate;\n    negate;\n    comment;\n    empty;\n    preserveMultipleSlashes;\n    partial;\n    globSet;\n    globParts;\n    nocase;\n    isWindows;\n    platform;\n    windowsNoMagicRoot;\n    regexp;\n    constructor(pattern, options = {}) {\n        (0, assert_valid_pattern_js_1.assertValidPattern)(pattern);\n        options = options || {};\n        this.options = options;\n        this.pattern = pattern;\n        this.platform = options.platform || defaultPlatform;\n        this.isWindows = this.platform === 'win32';\n        this.windowsPathsNoEscape =\n            !!options.windowsPathsNoEscape || options.allowWindowsEscape === false;\n        if (this.windowsPathsNoEscape) {\n            this.pattern = this.pattern.replace(/\\\\/g, '/');\n        }\n        this.preserveMultipleSlashes = !!options.preserveMultipleSlashes;\n        this.regexp = null;\n        this.negate = false;\n        this.nonegate = !!options.nonegate;\n        this.comment = false;\n        this.empty = false;\n        this.partial = !!options.partial;\n        this.nocase = !!this.options.nocase;\n        this.windowsNoMagicRoot =\n            options.windowsNoMagicRoot !== undefined\n                ? options.windowsNoMagicRoot\n                : !!(this.isWindows && this.nocase);\n        this.globSet = [];\n        this.globParts = [];\n        this.set = [];\n        // make the set of regexps etc.\n        this.make();\n    }\n    hasMagic() {\n        if (this.options.magicalBraces && this.set.length > 1) {\n            return true;\n        }\n        for (const pattern of this.set) {\n            for (const part of pattern) {\n                if (typeof part !== 'string')\n                    return true;\n            }\n        }\n        return false;\n    }\n    debug(..._) { }\n    make() {\n        const pattern = this.pattern;\n        const options = this.options;\n        // empty patterns and comments match nothing.\n        if (!options.nocomment && pattern.charAt(0) === '#') {\n            this.comment = true;\n            return;\n        }\n        if (!pattern) {\n            this.empty = true;\n            return;\n        }\n        // step 1: figure out negation, etc.\n        this.parseNegate();\n        // step 2: expand braces\n        this.globSet = [...new Set(this.braceExpand())];\n        if (options.debug) {\n            this.debug = (...args) => console.error(...args);\n        }\n        this.debug(this.pattern, this.globSet);\n        // step 3: now we have a set, so turn each one into a series of\n        // path-portion matching patterns.\n        // These will be regexps, except in the case of \"**\", which is\n        // set to the GLOBSTAR object for globstar behavior,\n        // and will not contain any / characters\n        //\n        // First, we preprocess to make the glob pattern sets a bit simpler\n        // and deduped.  There are some perf-killing patterns that can cause\n        // problems with a glob walk, but we can simplify them down a bit.\n        const rawGlobParts = this.globSet.map(s => this.slashSplit(s));\n        this.globParts = this.preprocess(rawGlobParts);\n        this.debug(this.pattern, this.globParts);\n        // glob --> regexps\n        let set = this.globParts.map((s, _, __) => {\n            if (this.isWindows && this.windowsNoMagicRoot) {\n                // check if it's a drive or unc path.\n                const isUNC = s[0] === '' &&\n                    s[1] === '' &&\n                    (s[2] === '?' || !globMagic.test(s[2])) &&\n                    !globMagic.test(s[3]);\n                const isDrive = /^[a-z]:/i.test(s[0]);\n                if (isUNC) {\n                    return [...s.slice(0, 4), ...s.slice(4).map(ss => this.parse(ss))];\n                }\n                else if (isDrive) {\n                    return [s[0], ...s.slice(1).map(ss => this.parse(ss))];\n                }\n            }\n            return s.map(ss => this.parse(ss));\n        });\n        this.debug(this.pattern, set);\n        // filter out everything that didn't compile properly.\n        this.set = set.filter(s => s.indexOf(false) === -1);\n        // do not treat the ? in UNC paths as magic\n        if (this.isWindows) {\n            for (let i = 0; i < this.set.length; i++) {\n                const p = this.set[i];\n                if (p[0] === '' &&\n                    p[1] === '' &&\n                    this.globParts[i][2] === '?' &&\n                    typeof p[3] === 'string' &&\n                    /^[a-z]:$/i.test(p[3])) {\n                    p[2] = '?';\n                }\n            }\n        }\n        this.debug(this.pattern, this.set);\n    }\n    // various transforms to equivalent pattern sets that are\n    // faster to process in a filesystem walk.  The goal is to\n    // eliminate what we can, and push all ** patterns as far\n    // to the right as possible, even if it increases the number\n    // of patterns that we have to process.\n    preprocess(globParts) {\n        // if we're not in globstar mode, then turn all ** into *\n        if (this.options.noglobstar) {\n            for (let i = 0; i < globParts.length; i++) {\n                for (let j = 0; j < globParts[i].length; j++) {\n                    if (globParts[i][j] === '**') {\n                        globParts[i][j] = '*';\n                    }\n                }\n            }\n        }\n        const { optimizationLevel = 1 } = this.options;\n        if (optimizationLevel >= 2) {\n            // aggressive optimization for the purpose of fs walking\n            globParts = this.firstPhasePreProcess(globParts);\n            globParts = this.secondPhasePreProcess(globParts);\n        }\n        else if (optimizationLevel >= 1) {\n            // just basic optimizations to remove some .. parts\n            globParts = this.levelOneOptimize(globParts);\n        }\n        else {\n            // just collapse multiple ** portions into one\n            globParts = this.adjascentGlobstarOptimize(globParts);\n        }\n        return globParts;\n    }\n    // just get rid of adjascent ** portions\n    adjascentGlobstarOptimize(globParts) {\n        return globParts.map(parts => {\n            let gs = -1;\n            while (-1 !== (gs = parts.indexOf('**', gs + 1))) {\n                let i = gs;\n                while (parts[i + 1] === '**') {\n                    i++;\n                }\n                if (i !== gs) {\n                    parts.splice(gs, i - gs);\n                }\n            }\n            return parts;\n        });\n    }\n    // get rid of adjascent ** and resolve .. portions\n    levelOneOptimize(globParts) {\n        return globParts.map(parts => {\n            parts = parts.reduce((set, part) => {\n                const prev = set[set.length - 1];\n                if (part === '**' && prev === '**') {\n                    return set;\n                }\n                if (part === '..') {\n                    if (prev && prev !== '..' && prev !== '.' && prev !== '**') {\n                        set.pop();\n                        return set;\n                    }\n                }\n                set.push(part);\n                return set;\n            }, []);\n            return parts.length === 0 ? [''] : parts;\n        });\n    }\n    levelTwoFileOptimize(parts) {\n        if (!Array.isArray(parts)) {\n            parts = this.slashSplit(parts);\n        }\n        let didSomething = false;\n        do {\n            didSomething = false;\n            // <pre>/<e>/<rest> -> <pre>/<rest>\n            if (!this.preserveMultipleSlashes) {\n                for (let i = 1; i < parts.length - 1; i++) {\n                    const p = parts[i];\n                    // don't squeeze out UNC patterns\n                    if (i === 1 && p === '' && parts[0] === '')\n                        continue;\n                    if (p === '.' || p === '') {\n                        didSomething = true;\n                        parts.splice(i, 1);\n                        i--;\n                    }\n                }\n                if (parts[0] === '.' &&\n                    parts.length === 2 &&\n                    (parts[1] === '.' || parts[1] === '')) {\n                    didSomething = true;\n                    parts.pop();\n                }\n            }\n            // <pre>/<p>/../<rest> -> <pre>/<rest>\n            let dd = 0;\n            while (-1 !== (dd = parts.indexOf('..', dd + 1))) {\n                const p = parts[dd - 1];\n                if (p && p !== '.' && p !== '..' && p !== '**') {\n                    didSomething = true;\n                    parts.splice(dd - 1, 2);\n                    dd -= 2;\n                }\n            }\n        } while (didSomething);\n        return parts.length === 0 ? [''] : parts;\n    }\n    // First phase: single-pattern processing\n    // <pre> is 1 or more portions\n    // <rest> is 1 or more portions\n    // <p> is any portion other than ., .., '', or **\n    // <e> is . or ''\n    //\n    // **/.. is *brutal* for filesystem walking performance, because\n    // it effectively resets the recursive walk each time it occurs,\n    // and ** cannot be reduced out by a .. pattern part like a regexp\n    // or most strings (other than .., ., and '') can be.\n    //\n    // <pre>/**/../<p>/<p>/<rest> -> {<pre>/../<p>/<p>/<rest>,<pre>/**/<p>/<p>/<rest>}\n    // <pre>/<e>/<rest> -> <pre>/<rest>\n    // <pre>/<p>/../<rest> -> <pre>/<rest>\n    // **/**/<rest> -> **/<rest>\n    //\n    // **/*/<rest> -> */**/<rest> <== not valid because ** doesn't follow\n    // this WOULD be allowed if ** did follow symlinks, or * didn't\n    firstPhasePreProcess(globParts) {\n        let didSomething = false;\n        do {\n            didSomething = false;\n            // <pre>/**/../<p>/<p>/<rest> -> {<pre>/../<p>/<p>/<rest>,<pre>/**/<p>/<p>/<rest>}\n            for (let parts of globParts) {\n                let gs = -1;\n                while (-1 !== (gs = parts.indexOf('**', gs + 1))) {\n                    let gss = gs;\n                    while (parts[gss + 1] === '**') {\n                        // <pre>/**/**/<rest> -> <pre>/**/<rest>\n                        gss++;\n                    }\n                    // eg, if gs is 2 and gss is 4, that means we have 3 **\n                    // parts, and can remove 2 of them.\n                    if (gss > gs) {\n                        parts.splice(gs + 1, gss - gs);\n                    }\n                    let next = parts[gs + 1];\n                    const p = parts[gs + 2];\n                    const p2 = parts[gs + 3];\n                    if (next !== '..')\n                        continue;\n                    if (!p ||\n                        p === '.' ||\n                        p === '..' ||\n                        !p2 ||\n                        p2 === '.' ||\n                        p2 === '..') {\n                        continue;\n                    }\n                    didSomething = true;\n                    // edit parts in place, and push the new one\n                    parts.splice(gs, 1);\n                    const other = parts.slice(0);\n                    other[gs] = '**';\n                    globParts.push(other);\n                    gs--;\n                }\n                // <pre>/<e>/<rest> -> <pre>/<rest>\n                if (!this.preserveMultipleSlashes) {\n                    for (let i = 1; i < parts.length - 1; i++) {\n                        const p = parts[i];\n                        // don't squeeze out UNC patterns\n                        if (i === 1 && p === '' && parts[0] === '')\n                            continue;\n                        if (p === '.' || p === '') {\n                            didSomething = true;\n                            parts.splice(i, 1);\n                            i--;\n                        }\n                    }\n                    if (parts[0] === '.' &&\n                        parts.length === 2 &&\n                        (parts[1] === '.' || parts[1] === '')) {\n                        didSomething = true;\n                        parts.pop();\n                    }\n                }\n                // <pre>/<p>/../<rest> -> <pre>/<rest>\n                let dd = 0;\n                while (-1 !== (dd = parts.indexOf('..', dd + 1))) {\n                    const p = parts[dd - 1];\n                    if (p && p !== '.' && p !== '..' && p !== '**') {\n                        didSomething = true;\n                        const needDot = dd === 1 && parts[dd + 1] === '**';\n                        const splin = needDot ? ['.'] : [];\n                        parts.splice(dd - 1, 2, ...splin);\n                        if (parts.length === 0)\n                            parts.push('');\n                        dd -= 2;\n                    }\n                }\n            }\n        } while (didSomething);\n        return globParts;\n    }\n    // second phase: multi-pattern dedupes\n    // {<pre>/*/<rest>,<pre>/<p>/<rest>} -> <pre>/*/<rest>\n    // {<pre>/<rest>,<pre>/<rest>} -> <pre>/<rest>\n    // {<pre>/**/<rest>,<pre>/<rest>} -> <pre>/**/<rest>\n    //\n    // {<pre>/**/<rest>,<pre>/**/<p>/<rest>} -> <pre>/**/<rest>\n    // ^-- not valid because ** doens't follow symlinks\n    secondPhasePreProcess(globParts) {\n        for (let i = 0; i < globParts.length - 1; i++) {\n            for (let j = i + 1; j < globParts.length; j++) {\n                const matched = this.partsMatch(globParts[i], globParts[j], !this.preserveMultipleSlashes);\n                if (matched) {\n                    globParts[i] = [];\n                    globParts[j] = matched;\n                    break;\n                }\n            }\n        }\n        return globParts.filter(gs => gs.length);\n    }\n    partsMatch(a, b, emptyGSMatch = false) {\n        let ai = 0;\n        let bi = 0;\n        let result = [];\n        let which = '';\n        while (ai < a.length && bi < b.length) {\n            if (a[ai] === b[bi]) {\n                result.push(which === 'b' ? b[bi] : a[ai]);\n                ai++;\n                bi++;\n            }\n            else if (emptyGSMatch && a[ai] === '**' && b[bi] === a[ai + 1]) {\n                result.push(a[ai]);\n                ai++;\n            }\n            else if (emptyGSMatch && b[bi] === '**' && a[ai] === b[bi + 1]) {\n                result.push(b[bi]);\n                bi++;\n            }\n            else if (a[ai] === '*' &&\n                b[bi] &&\n                (this.options.dot || !b[bi].startsWith('.')) &&\n                b[bi] !== '**') {\n                if (which === 'b')\n                    return false;\n                which = 'a';\n                result.push(a[ai]);\n                ai++;\n                bi++;\n            }\n            else if (b[bi] === '*' &&\n                a[ai] &&\n                (this.options.dot || !a[ai].startsWith('.')) &&\n                a[ai] !== '**') {\n                if (which === 'a')\n                    return false;\n                which = 'b';\n                result.push(b[bi]);\n                ai++;\n                bi++;\n            }\n            else {\n                return false;\n            }\n        }\n        // if we fall out of the loop, it means they two are identical\n        // as long as their lengths match\n        return a.length === b.length && result;\n    }\n    parseNegate() {\n        if (this.nonegate)\n            return;\n        const pattern = this.pattern;\n        let negate = false;\n        let negateOffset = 0;\n        for (let i = 0; i < pattern.length && pattern.charAt(i) === '!'; i++) {\n            negate = !negate;\n            negateOffset++;\n        }\n        if (negateOffset)\n            this.pattern = pattern.slice(negateOffset);\n        this.negate = negate;\n    }\n    // set partial to true to test if, for example,\n    // \"/a/b\" matches the start of \"/*/b/*/d\"\n    // Partial means, if you run out of file before you run\n    // out of pattern, then that's fine, as long as all\n    // the parts match.\n    matchOne(file, pattern, partial = false) {\n        const options = this.options;\n        // UNC paths like //?/X:/... can match X:/... and vice versa\n        // Drive letters in absolute drive or unc paths are always compared\n        // case-insensitively.\n        if (this.isWindows) {\n            const fileDrive = typeof file[0] === 'string' && /^[a-z]:$/i.test(file[0]);\n            const fileUNC = !fileDrive &&\n                file[0] === '' &&\n                file[1] === '' &&\n                file[2] === '?' &&\n                /^[a-z]:$/i.test(file[3]);\n            const patternDrive = typeof pattern[0] === 'string' && /^[a-z]:$/i.test(pattern[0]);\n            const patternUNC = !patternDrive &&\n                pattern[0] === '' &&\n                pattern[1] === '' &&\n                pattern[2] === '?' &&\n                typeof pattern[3] === 'string' &&\n                /^[a-z]:$/i.test(pattern[3]);\n            const fdi = fileUNC ? 3 : fileDrive ? 0 : undefined;\n            const pdi = patternUNC ? 3 : patternDrive ? 0 : undefined;\n            if (typeof fdi === 'number' && typeof pdi === 'number') {\n                const [fd, pd] = [file[fdi], pattern[pdi]];\n                if (fd.toLowerCase() === pd.toLowerCase()) {\n                    pattern[pdi] = fd;\n                    if (pdi > fdi) {\n                        pattern = pattern.slice(pdi);\n                    }\n                    else if (fdi > pdi) {\n                        file = file.slice(fdi);\n                    }\n                }\n            }\n        }\n        // resolve and reduce . and .. portions in the file as well.\n        // dont' need to do the second phase, because it's only one string[]\n        const { optimizationLevel = 1 } = this.options;\n        if (optimizationLevel >= 2) {\n            file = this.levelTwoFileOptimize(file);\n        }\n        this.debug('matchOne', this, { file, pattern });\n        this.debug('matchOne', file.length, pattern.length);\n        for (var fi = 0, pi = 0, fl = file.length, pl = pattern.length; fi < fl && pi < pl; fi++, pi++) {\n            this.debug('matchOne loop');\n            var p = pattern[pi];\n            var f = file[fi];\n            this.debug(pattern, p, f);\n            // should be impossible.\n            // some invalid regexp stuff in the set.\n            /* c8 ignore start */\n            if (p === false) {\n                return false;\n            }\n            /* c8 ignore stop */\n            if (p === exports.GLOBSTAR) {\n                this.debug('GLOBSTAR', [pattern, p, f]);\n                // \"**\"\n                // a/**/b/**/c would match the following:\n                // a/b/x/y/z/c\n                // a/x/y/z/b/c\n                // a/b/x/b/x/c\n                // a/b/c\n                // To do this, take the rest of the pattern after\n                // the **, and see if it would match the file remainder.\n                // If so, return success.\n                // If not, the ** \"swallows\" a segment, and try again.\n                // This is recursively awful.\n                //\n                // a/**/b/**/c matching a/b/x/y/z/c\n                // - a matches a\n                // - doublestar\n                //   - matchOne(b/x/y/z/c, b/**/c)\n                //     - b matches b\n                //     - doublestar\n                //       - matchOne(x/y/z/c, c) -> no\n                //       - matchOne(y/z/c, c) -> no\n                //       - matchOne(z/c, c) -> no\n                //       - matchOne(c, c) yes, hit\n                var fr = fi;\n                var pr = pi + 1;\n                if (pr === pl) {\n                    this.debug('** at the end');\n                    // a ** at the end will just swallow the rest.\n                    // We have found a match.\n                    // however, it will not swallow /.x, unless\n                    // options.dot is set.\n                    // . and .. are *never* matched by **, for explosively\n                    // exponential reasons.\n                    for (; fi < fl; fi++) {\n                        if (file[fi] === '.' ||\n                            file[fi] === '..' ||\n                            (!options.dot && file[fi].charAt(0) === '.'))\n                            return false;\n                    }\n                    return true;\n                }\n                // ok, let's see if we can swallow whatever we can.\n                while (fr < fl) {\n                    var swallowee = file[fr];\n                    this.debug('\\nglobstar while', file, fr, pattern, pr, swallowee);\n                    // XXX remove this slice.  Just pass the start index.\n                    if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {\n                        this.debug('globstar found match!', fr, fl, swallowee);\n                        // found a match.\n                        return true;\n                    }\n                    else {\n                        // can't swallow \".\" or \"..\" ever.\n                        // can only swallow \".foo\" when explicitly asked.\n                        if (swallowee === '.' ||\n                            swallowee === '..' ||\n                            (!options.dot && swallowee.charAt(0) === '.')) {\n                            this.debug('dot detected!', file, fr, pattern, pr);\n                            break;\n                        }\n                        // ** swallows a segment, and continue.\n                        this.debug('globstar swallow a segment, and continue');\n                        fr++;\n                    }\n                }\n                // no match was found.\n                // However, in partial mode, we can't say this is necessarily over.\n                /* c8 ignore start */\n                if (partial) {\n                    // ran out of file\n                    this.debug('\\n>>> no match, partial?', file, fr, pattern, pr);\n                    if (fr === fl) {\n                        return true;\n                    }\n                }\n                /* c8 ignore stop */\n                return false;\n            }\n            // something other than **\n            // non-magic patterns just have to match exactly\n            // patterns with magic have been turned into regexps.\n            let hit;\n            if (typeof p === 'string') {\n                hit = f === p;\n                this.debug('string match', p, f, hit);\n            }\n            else {\n                hit = p.test(f);\n                this.debug('pattern match', p, f, hit);\n            }\n            if (!hit)\n                return false;\n        }\n        // Note: ending in / means that we'll get a final \"\"\n        // at the end of the pattern.  This can only match a\n        // corresponding \"\" at the end of the file.\n        // If the file ends in /, then it can only match a\n        // a pattern that ends in /, unless the pattern just\n        // doesn't have any more for it. But, a/b/ should *not*\n        // match \"a/b/*\", even though \"\" matches against the\n        // [^/]*? pattern, except in partial mode, where it might\n        // simply not be reached yet.\n        // However, a/b/ should still satisfy a/*\n        // now either we fell off the end of the pattern, or we're done.\n        if (fi === fl && pi === pl) {\n            // ran out of pattern and filename at the same time.\n            // an exact hit!\n            return true;\n        }\n        else if (fi === fl) {\n            // ran out of file, but still had pattern left.\n            // this is ok if we're doing the match as part of\n            // a glob fs traversal.\n            return partial;\n        }\n        else if (pi === pl) {\n            // ran out of pattern, still have file left.\n            // this is only acceptable if we're on the very last\n            // empty segment of a file with a trailing slash.\n            // a/* should match a/b/\n            return fi === fl - 1 && file[fi] === '';\n            /* c8 ignore start */\n        }\n        else {\n            // should be unreachable.\n            throw new Error('wtf?');\n        }\n        /* c8 ignore stop */\n    }\n    braceExpand() {\n        return (0, exports.braceExpand)(this.pattern, this.options);\n    }\n    parse(pattern) {\n        (0, assert_valid_pattern_js_1.assertValidPattern)(pattern);\n        const options = this.options;\n        // shortcuts\n        if (pattern === '**')\n            return exports.GLOBSTAR;\n        if (pattern === '')\n            return '';\n        // far and away, the most common glob pattern parts are\n        // *, *.*, and *.<ext>  Add a fast check method for those.\n        let m;\n        let fastTest = null;\n        if ((m = pattern.match(starRE))) {\n            fastTest = options.dot ? starTestDot : starTest;\n        }\n        else if ((m = pattern.match(starDotExtRE))) {\n            fastTest = (options.nocase\n                ? options.dot\n                    ? starDotExtTestNocaseDot\n                    : starDotExtTestNocase\n                : options.dot\n                    ? starDotExtTestDot\n                    : starDotExtTest)(m[1]);\n        }\n        else if ((m = pattern.match(qmarksRE))) {\n            fastTest = (options.nocase\n                ? options.dot\n                    ? qmarksTestNocaseDot\n                    : qmarksTestNocase\n                : options.dot\n                    ? qmarksTestDot\n                    : qmarksTest)(m);\n        }\n        else if ((m = pattern.match(starDotStarRE))) {\n            fastTest = options.dot ? starDotStarTestDot : starDotStarTest;\n        }\n        else if ((m = pattern.match(dotStarRE))) {\n            fastTest = dotStarTest;\n        }\n        const re = ast_js_1.AST.fromGlob(pattern, this.options).toMMPattern();\n        if (fastTest && typeof re === 'object') {\n            // Avoids overriding in frozen environments\n            Reflect.defineProperty(re, 'test', { value: fastTest });\n        }\n        return re;\n    }\n    makeRe() {\n        if (this.regexp || this.regexp === false)\n            return this.regexp;\n        // at this point, this.set is a 2d array of partial\n        // pattern strings, or \"**\".\n        //\n        // It's better to use .match().  This function shouldn't\n        // be used, really, but it's pretty convenient sometimes,\n        // when you just want to work with a regex.\n        const set = this.set;\n        if (!set.length) {\n            this.regexp = false;\n            return this.regexp;\n        }\n        const options = this.options;\n        const twoStar = options.noglobstar\n            ? star\n            : options.dot\n                ? twoStarDot\n                : twoStarNoDot;\n        const flags = new Set(options.nocase ? ['i'] : []);\n        // regexpify non-globstar patterns\n        // if ** is only item, then we just do one twoStar\n        // if ** is first, and there are more, prepend (\\/|twoStar\\/)? to next\n        // if ** is last, append (\\/twoStar|) to previous\n        // if ** is in the middle, append (\\/|\\/twoStar\\/) to previous\n        // then filter out GLOBSTAR symbols\n        let re = set\n            .map(pattern => {\n            const pp = pattern.map(p => {\n                if (p instanceof RegExp) {\n                    for (const f of p.flags.split(''))\n                        flags.add(f);\n                }\n                return typeof p === 'string'\n                    ? regExpEscape(p)\n                    : p === exports.GLOBSTAR\n                        ? exports.GLOBSTAR\n                        : p._src;\n            });\n            pp.forEach((p, i) => {\n                const next = pp[i + 1];\n                const prev = pp[i - 1];\n                if (p !== exports.GLOBSTAR || prev === exports.GLOBSTAR) {\n                    return;\n                }\n                if (prev === undefined) {\n                    if (next !== undefined && next !== exports.GLOBSTAR) {\n                        pp[i + 1] = '(?:\\\\/|' + twoStar + '\\\\/)?' + next;\n                    }\n                    else {\n                        pp[i] = twoStar;\n                    }\n                }\n                else if (next === undefined) {\n                    pp[i - 1] = prev + '(?:\\\\/|' + twoStar + ')?';\n                }\n                else if (next !== exports.GLOBSTAR) {\n                    pp[i - 1] = prev + '(?:\\\\/|\\\\/' + twoStar + '\\\\/)' + next;\n                    pp[i + 1] = exports.GLOBSTAR;\n                }\n            });\n            return pp.filter(p => p !== exports.GLOBSTAR).join('/');\n        })\n            .join('|');\n        // need to wrap in parens if we had more than one thing with |,\n        // otherwise only the first will be anchored to ^ and the last to $\n        const [open, close] = set.length > 1 ? ['(?:', ')'] : ['', ''];\n        // must match entire pattern\n        // ending in a * or ** will make it less strict.\n        re = '^' + open + re + close + '$';\n        // can match anything, as long as it's not this.\n        if (this.negate)\n            re = '^(?!' + re + ').+$';\n        try {\n            this.regexp = new RegExp(re, [...flags].join(''));\n            /* c8 ignore start */\n        }\n        catch (ex) {\n            // should be impossible\n            this.regexp = false;\n        }\n        /* c8 ignore stop */\n        return this.regexp;\n    }\n    slashSplit(p) {\n        // if p starts with // on windows, we preserve that\n        // so that UNC paths aren't broken.  Otherwise, any number of\n        // / characters are coalesced into one, unless\n        // preserveMultipleSlashes is set to true.\n        if (this.preserveMultipleSlashes) {\n            return p.split('/');\n        }\n        else if (this.isWindows && /^\\/\\/[^\\/]+/.test(p)) {\n            // add an extra '' for the one we lose\n            return ['', ...p.split(/\\/+/)];\n        }\n        else {\n            return p.split(/\\/+/);\n        }\n    }\n    match(f, partial = this.partial) {\n        this.debug('match', f, this.pattern);\n        // short-circuit in the case of busted things.\n        // comments, etc.\n        if (this.comment) {\n            return false;\n        }\n        if (this.empty) {\n            return f === '';\n        }\n        if (f === '/' && partial) {\n            return true;\n        }\n        const options = this.options;\n        // windows: need to use /, not \\\n        if (this.isWindows) {\n            f = f.split('\\\\').join('/');\n        }\n        // treat the test path as a set of pathparts.\n        const ff = this.slashSplit(f);\n        this.debug(this.pattern, 'split', ff);\n        // just ONE of the pattern sets in this.set needs to match\n        // in order for it to be valid.  If negating, then just one\n        // match means that we have failed.\n        // Either way, return on the first hit.\n        const set = this.set;\n        this.debug(this.pattern, 'set', set);\n        // Find the basename of the path by looking for the last non-empty segment\n        let filename = ff[ff.length - 1];\n        if (!filename) {\n            for (let i = ff.length - 2; !filename && i >= 0; i--) {\n                filename = ff[i];\n            }\n        }\n        for (let i = 0; i < set.length; i++) {\n            const pattern = set[i];\n            let file = ff;\n            if (options.matchBase && pattern.length === 1) {\n                file = [filename];\n            }\n            const hit = this.matchOne(file, pattern, partial);\n            if (hit) {\n                if (options.flipNegate) {\n                    return true;\n                }\n                return !this.negate;\n            }\n        }\n        // didn't get any hits.  this is success if it's a negative\n        // pattern, failure otherwise.\n        if (options.flipNegate) {\n            return false;\n        }\n        return this.negate;\n    }\n    static defaults(def) {\n        return exports.minimatch.defaults(def).Minimatch;\n    }\n}\nexports.Minimatch = Minimatch;\n/* c8 ignore start */\nvar ast_js_2 = __webpack_require__(/*! ./ast.js */ \"(ssr)/./node_modules/minimatch/dist/commonjs/ast.js\");\nObject.defineProperty(exports, \"AST\", ({ enumerable: true, get: function () { return ast_js_2.AST; } }));\nvar escape_js_2 = __webpack_require__(/*! ./escape.js */ \"(ssr)/./node_modules/minimatch/dist/commonjs/escape.js\");\nObject.defineProperty(exports, \"escape\", ({ enumerable: true, get: function () { return escape_js_2.escape; } }));\nvar unescape_js_2 = __webpack_require__(/*! ./unescape.js */ \"(ssr)/./node_modules/minimatch/dist/commonjs/unescape.js\");\nObject.defineProperty(exports, \"unescape\", ({ enumerable: true, get: function () { return unescape_js_2.unescape; } }));\n/* c8 ignore stop */\nexports.minimatch.AST = ast_js_1.AST;\nexports.minimatch.Minimatch = Minimatch;\nexports.minimatch.escape = escape_js_1.escape;\nexports.minimatch.unescape = unescape_js_1.unescape;\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbWluaW1hdGNoL2Rpc3QvY29tbW9uanMvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBLDZDQUE2QztBQUM3QztBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxnQkFBZ0IsR0FBRyxjQUFjLEdBQUcsV0FBVyxHQUFHLGlCQUFpQixHQUFHLGFBQWEsR0FBRyxjQUFjLEdBQUcsbUJBQW1CLEdBQUcsZ0JBQWdCLEdBQUcsY0FBYyxHQUFHLGdCQUFnQixHQUFHLFdBQVcsR0FBRyxpQkFBaUI7QUFDbk4sMENBQTBDLG1CQUFPLENBQUMsc0VBQWlCO0FBQ25FLGtDQUFrQyxtQkFBTyxDQUFDLHVHQUEyQjtBQUNyRSxpQkFBaUIsbUJBQU8sQ0FBQyxxRUFBVTtBQUNuQyxvQkFBb0IsbUJBQU8sQ0FBQywyRUFBYTtBQUN6QyxzQkFBc0IsbUJBQU8sQ0FBQywrRUFBZTtBQUM3QywyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsV0FBVztBQUN4QixhQUFhLFVBQVU7QUFDdkI7QUFDQTtBQUNBLFdBQVc7QUFDWCxxQkFBcUI7QUFDckIsZ0JBQWdCO0FBQ2hCLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLElBQUk7QUFDOUM7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDLGNBQWM7QUFDZCx3QkFBd0I7QUFDeEIsc0JBQXNCLHFCQUFxQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0Esa0RBQWtEO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRDtBQUNqRDtBQUNBO0FBQ0EsU0FBUztBQUNULGtDQUFrQztBQUNsQyxnQ0FBZ0M7QUFDaEMsc0NBQXNDO0FBQ3RDO0FBQ0Esc0NBQXNDO0FBQ3RDLDJDQUEyQztBQUMzQywyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGdCQUFnQjtBQUNoQiwwQkFBMEI7QUFDMUI7QUFDQSxLQUFLLElBQUk7QUFDVCxLQUFLLEdBQUc7QUFDUixLQUFLLEtBQUs7QUFDVixLQUFLLElBQUksSUFBSSxFQUFFO0FBQ2YsS0FBSyxJQUFJLEVBQUUsSUFBSTtBQUNmO0FBQ0E7QUFDQSxLQUFLLElBQUksT0FBTyxJQUFJO0FBQ3BCLEtBQUssRUFBRSxPQUFPLEVBQUU7QUFDaEIsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixRQUFRLE1BQU07QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQiw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQyxjQUFjO0FBQ2Qsd0JBQXdCO0FBQ3hCLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYix1QkFBdUI7QUFDdkI7QUFDQTtBQUNBLDhDQUE4QztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixxQkFBcUI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixzQkFBc0I7QUFDbEQsZ0NBQWdDLHlCQUF5QjtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isd0JBQXdCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxzQkFBc0I7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxzQkFBc0I7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxRQUFRLGlDQUFpQztBQUN6QyxRQUFRLDJCQUEyQjtBQUNuQyxRQUFRLDhCQUE4QjtBQUN0QztBQUNBLFFBQVEscUNBQXFDO0FBQzdDO0FBQ0E7QUFDQSx3QkFBd0IsMEJBQTBCO0FBQ2xELGdDQUFnQyxzQkFBc0I7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixpREFBaUQ7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHdCQUF3QjtBQUN4QztBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsZUFBZTtBQUN0RDtBQUNBLHdFQUF3RSxvQkFBb0I7QUFDNUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLFNBQVM7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxpQkFBaUI7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxxQkFBcUI7QUFDN0Q7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGdCQUFnQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxlQUFlLG1CQUFPLENBQUMscUVBQVU7QUFDakMsdUNBQXNDLEVBQUUscUNBQXFDLHdCQUF3QixFQUFDO0FBQ3RHLGtCQUFrQixtQkFBTyxDQUFDLDJFQUFhO0FBQ3ZDLDBDQUF5QyxFQUFFLHFDQUFxQyw4QkFBOEIsRUFBQztBQUMvRyxvQkFBb0IsbUJBQU8sQ0FBQywrRUFBZTtBQUMzQyw0Q0FBMkMsRUFBRSxxQ0FBcUMsa0NBQWtDLEVBQUM7QUFDckg7QUFDQSxxQkFBcUI7QUFDckIsMkJBQTJCO0FBQzNCLHdCQUF3QjtBQUN4QiwwQkFBMEI7QUFDMUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hdXRvLWxvb3AtZGVtby8uL25vZGVfbW9kdWxlcy9taW5pbWF0Y2gvZGlzdC9jb21tb25qcy9pbmRleC5qcz8wOTlhIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy51bmVzY2FwZSA9IGV4cG9ydHMuZXNjYXBlID0gZXhwb3J0cy5BU1QgPSBleHBvcnRzLk1pbmltYXRjaCA9IGV4cG9ydHMubWF0Y2ggPSBleHBvcnRzLm1ha2VSZSA9IGV4cG9ydHMuYnJhY2VFeHBhbmQgPSBleHBvcnRzLmRlZmF1bHRzID0gZXhwb3J0cy5maWx0ZXIgPSBleHBvcnRzLkdMT0JTVEFSID0gZXhwb3J0cy5zZXAgPSBleHBvcnRzLm1pbmltYXRjaCA9IHZvaWQgMDtcbmNvbnN0IGJyYWNlX2V4cGFuc2lvbl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJicmFjZS1leHBhbnNpb25cIikpO1xuY29uc3QgYXNzZXJ0X3ZhbGlkX3BhdHRlcm5fanNfMSA9IHJlcXVpcmUoXCIuL2Fzc2VydC12YWxpZC1wYXR0ZXJuLmpzXCIpO1xuY29uc3QgYXN0X2pzXzEgPSByZXF1aXJlKFwiLi9hc3QuanNcIik7XG5jb25zdCBlc2NhcGVfanNfMSA9IHJlcXVpcmUoXCIuL2VzY2FwZS5qc1wiKTtcbmNvbnN0IHVuZXNjYXBlX2pzXzEgPSByZXF1aXJlKFwiLi91bmVzY2FwZS5qc1wiKTtcbmNvbnN0IG1pbmltYXRjaCA9IChwLCBwYXR0ZXJuLCBvcHRpb25zID0ge30pID0+IHtcbiAgICAoMCwgYXNzZXJ0X3ZhbGlkX3BhdHRlcm5fanNfMS5hc3NlcnRWYWxpZFBhdHRlcm4pKHBhdHRlcm4pO1xuICAgIC8vIHNob3J0Y3V0OiBjb21tZW50cyBtYXRjaCBub3RoaW5nLlxuICAgIGlmICghb3B0aW9ucy5ub2NvbW1lbnQgJiYgcGF0dGVybi5jaGFyQXQoMCkgPT09ICcjJykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBuZXcgTWluaW1hdGNoKHBhdHRlcm4sIG9wdGlvbnMpLm1hdGNoKHApO1xufTtcbmV4cG9ydHMubWluaW1hdGNoID0gbWluaW1hdGNoO1xuLy8gT3B0aW1pemVkIGNoZWNraW5nIGZvciB0aGUgbW9zdCBjb21tb24gZ2xvYiBwYXR0ZXJucy5cbmNvbnN0IHN0YXJEb3RFeHRSRSA9IC9eXFwqKyhbXitAIT9cXCpcXFtcXChdKikkLztcbmNvbnN0IHN0YXJEb3RFeHRUZXN0ID0gKGV4dCkgPT4gKGYpID0+ICFmLnN0YXJ0c1dpdGgoJy4nKSAmJiBmLmVuZHNXaXRoKGV4dCk7XG5jb25zdCBzdGFyRG90RXh0VGVzdERvdCA9IChleHQpID0+IChmKSA9PiBmLmVuZHNXaXRoKGV4dCk7XG5jb25zdCBzdGFyRG90RXh0VGVzdE5vY2FzZSA9IChleHQpID0+IHtcbiAgICBleHQgPSBleHQudG9Mb3dlckNhc2UoKTtcbiAgICByZXR1cm4gKGYpID0+ICFmLnN0YXJ0c1dpdGgoJy4nKSAmJiBmLnRvTG93ZXJDYXNlKCkuZW5kc1dpdGgoZXh0KTtcbn07XG5jb25zdCBzdGFyRG90RXh0VGVzdE5vY2FzZURvdCA9IChleHQpID0+IHtcbiAgICBleHQgPSBleHQudG9Mb3dlckNhc2UoKTtcbiAgICByZXR1cm4gKGYpID0+IGYudG9Mb3dlckNhc2UoKS5lbmRzV2l0aChleHQpO1xufTtcbmNvbnN0IHN0YXJEb3RTdGFyUkUgPSAvXlxcKitcXC5cXCorJC87XG5jb25zdCBzdGFyRG90U3RhclRlc3QgPSAoZikgPT4gIWYuc3RhcnRzV2l0aCgnLicpICYmIGYuaW5jbHVkZXMoJy4nKTtcbmNvbnN0IHN0YXJEb3RTdGFyVGVzdERvdCA9IChmKSA9PiBmICE9PSAnLicgJiYgZiAhPT0gJy4uJyAmJiBmLmluY2x1ZGVzKCcuJyk7XG5jb25zdCBkb3RTdGFyUkUgPSAvXlxcLlxcKiskLztcbmNvbnN0IGRvdFN0YXJUZXN0ID0gKGYpID0+IGYgIT09ICcuJyAmJiBmICE9PSAnLi4nICYmIGYuc3RhcnRzV2l0aCgnLicpO1xuY29uc3Qgc3RhclJFID0gL15cXCorJC87XG5jb25zdCBzdGFyVGVzdCA9IChmKSA9PiBmLmxlbmd0aCAhPT0gMCAmJiAhZi5zdGFydHNXaXRoKCcuJyk7XG5jb25zdCBzdGFyVGVzdERvdCA9IChmKSA9PiBmLmxlbmd0aCAhPT0gMCAmJiBmICE9PSAnLicgJiYgZiAhPT0gJy4uJztcbmNvbnN0IHFtYXJrc1JFID0gL15cXD8rKFteK0AhP1xcKlxcW1xcKF0qKT8kLztcbmNvbnN0IHFtYXJrc1Rlc3ROb2Nhc2UgPSAoWyQwLCBleHQgPSAnJ10pID0+IHtcbiAgICBjb25zdCBub2V4dCA9IHFtYXJrc1Rlc3ROb0V4dChbJDBdKTtcbiAgICBpZiAoIWV4dClcbiAgICAgICAgcmV0dXJuIG5vZXh0O1xuICAgIGV4dCA9IGV4dC50b0xvd2VyQ2FzZSgpO1xuICAgIHJldHVybiAoZikgPT4gbm9leHQoZikgJiYgZi50b0xvd2VyQ2FzZSgpLmVuZHNXaXRoKGV4dCk7XG59O1xuY29uc3QgcW1hcmtzVGVzdE5vY2FzZURvdCA9IChbJDAsIGV4dCA9ICcnXSkgPT4ge1xuICAgIGNvbnN0IG5vZXh0ID0gcW1hcmtzVGVzdE5vRXh0RG90KFskMF0pO1xuICAgIGlmICghZXh0KVxuICAgICAgICByZXR1cm4gbm9leHQ7XG4gICAgZXh0ID0gZXh0LnRvTG93ZXJDYXNlKCk7XG4gICAgcmV0dXJuIChmKSA9PiBub2V4dChmKSAmJiBmLnRvTG93ZXJDYXNlKCkuZW5kc1dpdGgoZXh0KTtcbn07XG5jb25zdCBxbWFya3NUZXN0RG90ID0gKFskMCwgZXh0ID0gJyddKSA9PiB7XG4gICAgY29uc3Qgbm9leHQgPSBxbWFya3NUZXN0Tm9FeHREb3QoWyQwXSk7XG4gICAgcmV0dXJuICFleHQgPyBub2V4dCA6IChmKSA9PiBub2V4dChmKSAmJiBmLmVuZHNXaXRoKGV4dCk7XG59O1xuY29uc3QgcW1hcmtzVGVzdCA9IChbJDAsIGV4dCA9ICcnXSkgPT4ge1xuICAgIGNvbnN0IG5vZXh0ID0gcW1hcmtzVGVzdE5vRXh0KFskMF0pO1xuICAgIHJldHVybiAhZXh0ID8gbm9leHQgOiAoZikgPT4gbm9leHQoZikgJiYgZi5lbmRzV2l0aChleHQpO1xufTtcbmNvbnN0IHFtYXJrc1Rlc3ROb0V4dCA9IChbJDBdKSA9PiB7XG4gICAgY29uc3QgbGVuID0gJDAubGVuZ3RoO1xuICAgIHJldHVybiAoZikgPT4gZi5sZW5ndGggPT09IGxlbiAmJiAhZi5zdGFydHNXaXRoKCcuJyk7XG59O1xuY29uc3QgcW1hcmtzVGVzdE5vRXh0RG90ID0gKFskMF0pID0+IHtcbiAgICBjb25zdCBsZW4gPSAkMC5sZW5ndGg7XG4gICAgcmV0dXJuIChmKSA9PiBmLmxlbmd0aCA9PT0gbGVuICYmIGYgIT09ICcuJyAmJiBmICE9PSAnLi4nO1xufTtcbi8qIGM4IGlnbm9yZSBzdGFydCAqL1xuY29uc3QgZGVmYXVsdFBsYXRmb3JtID0gKHR5cGVvZiBwcm9jZXNzID09PSAnb2JqZWN0JyAmJiBwcm9jZXNzXG4gICAgPyAodHlwZW9mIHByb2Nlc3MuZW52ID09PSAnb2JqZWN0JyAmJlxuICAgICAgICBwcm9jZXNzLmVudiAmJlxuICAgICAgICBwcm9jZXNzLmVudi5fX01JTklNQVRDSF9URVNUSU5HX1BMQVRGT1JNX18pIHx8XG4gICAgICAgIHByb2Nlc3MucGxhdGZvcm1cbiAgICA6ICdwb3NpeCcpO1xuY29uc3QgcGF0aCA9IHtcbiAgICB3aW4zMjogeyBzZXA6ICdcXFxcJyB9LFxuICAgIHBvc2l4OiB7IHNlcDogJy8nIH0sXG59O1xuLyogYzggaWdub3JlIHN0b3AgKi9cbmV4cG9ydHMuc2VwID0gZGVmYXVsdFBsYXRmb3JtID09PSAnd2luMzInID8gcGF0aC53aW4zMi5zZXAgOiBwYXRoLnBvc2l4LnNlcDtcbmV4cG9ydHMubWluaW1hdGNoLnNlcCA9IGV4cG9ydHMuc2VwO1xuZXhwb3J0cy5HTE9CU1RBUiA9IFN5bWJvbCgnZ2xvYnN0YXIgKionKTtcbmV4cG9ydHMubWluaW1hdGNoLkdMT0JTVEFSID0gZXhwb3J0cy5HTE9CU1RBUjtcbi8vIGFueSBzaW5nbGUgdGhpbmcgb3RoZXIgdGhhbiAvXG4vLyBkb24ndCBuZWVkIHRvIGVzY2FwZSAvIHdoZW4gdXNpbmcgbmV3IFJlZ0V4cCgpXG5jb25zdCBxbWFyayA9ICdbXi9dJztcbi8vICogPT4gYW55IG51bWJlciBvZiBjaGFyYWN0ZXJzXG5jb25zdCBzdGFyID0gcW1hcmsgKyAnKj8nO1xuLy8gKiogd2hlbiBkb3RzIGFyZSBhbGxvd2VkLiAgQW55dGhpbmcgZ29lcywgZXhjZXB0IC4uIGFuZCAuXG4vLyBub3QgKF4gb3IgLyBmb2xsb3dlZCBieSBvbmUgb3IgdHdvIGRvdHMgZm9sbG93ZWQgYnkgJCBvciAvKSxcbi8vIGZvbGxvd2VkIGJ5IGFueXRoaW5nLCBhbnkgbnVtYmVyIG9mIHRpbWVzLlxuY29uc3QgdHdvU3RhckRvdCA9ICcoPzooPyEoPzpcXFxcL3xeKSg/OlxcXFwuezEsMn0pKCR8XFxcXC8pKS4pKj8nO1xuLy8gbm90IGEgXiBvciAvIGZvbGxvd2VkIGJ5IGEgZG90LFxuLy8gZm9sbG93ZWQgYnkgYW55dGhpbmcsIGFueSBudW1iZXIgb2YgdGltZXMuXG5jb25zdCB0d29TdGFyTm9Eb3QgPSAnKD86KD8hKD86XFxcXC98XilcXFxcLikuKSo/JztcbmNvbnN0IGZpbHRlciA9IChwYXR0ZXJuLCBvcHRpb25zID0ge30pID0+IChwKSA9PiAoMCwgZXhwb3J0cy5taW5pbWF0Y2gpKHAsIHBhdHRlcm4sIG9wdGlvbnMpO1xuZXhwb3J0cy5maWx0ZXIgPSBmaWx0ZXI7XG5leHBvcnRzLm1pbmltYXRjaC5maWx0ZXIgPSBleHBvcnRzLmZpbHRlcjtcbmNvbnN0IGV4dCA9IChhLCBiID0ge30pID0+IE9iamVjdC5hc3NpZ24oe30sIGEsIGIpO1xuY29uc3QgZGVmYXVsdHMgPSAoZGVmKSA9PiB7XG4gICAgaWYgKCFkZWYgfHwgdHlwZW9mIGRlZiAhPT0gJ29iamVjdCcgfHwgIU9iamVjdC5rZXlzKGRlZikubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBleHBvcnRzLm1pbmltYXRjaDtcbiAgICB9XG4gICAgY29uc3Qgb3JpZyA9IGV4cG9ydHMubWluaW1hdGNoO1xuICAgIGNvbnN0IG0gPSAocCwgcGF0dGVybiwgb3B0aW9ucyA9IHt9KSA9PiBvcmlnKHAsIHBhdHRlcm4sIGV4dChkZWYsIG9wdGlvbnMpKTtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihtLCB7XG4gICAgICAgIE1pbmltYXRjaDogY2xhc3MgTWluaW1hdGNoIGV4dGVuZHMgb3JpZy5NaW5pbWF0Y2gge1xuICAgICAgICAgICAgY29uc3RydWN0b3IocGF0dGVybiwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgICAgICAgICAgc3VwZXIocGF0dGVybiwgZXh0KGRlZiwgb3B0aW9ucykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3RhdGljIGRlZmF1bHRzKG9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gb3JpZy5kZWZhdWx0cyhleHQoZGVmLCBvcHRpb25zKSkuTWluaW1hdGNoO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBBU1Q6IGNsYXNzIEFTVCBleHRlbmRzIG9yaWcuQVNUIHtcbiAgICAgICAgICAgIC8qIGM4IGlnbm9yZSBzdGFydCAqL1xuICAgICAgICAgICAgY29uc3RydWN0b3IodHlwZSwgcGFyZW50LCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgICAgICAgICBzdXBlcih0eXBlLCBwYXJlbnQsIGV4dChkZWYsIG9wdGlvbnMpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qIGM4IGlnbm9yZSBzdG9wICovXG4gICAgICAgICAgICBzdGF0aWMgZnJvbUdsb2IocGF0dGVybiwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9yaWcuQVNULmZyb21HbG9iKHBhdHRlcm4sIGV4dChkZWYsIG9wdGlvbnMpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgdW5lc2NhcGU6IChzLCBvcHRpb25zID0ge30pID0+IG9yaWcudW5lc2NhcGUocywgZXh0KGRlZiwgb3B0aW9ucykpLFxuICAgICAgICBlc2NhcGU6IChzLCBvcHRpb25zID0ge30pID0+IG9yaWcuZXNjYXBlKHMsIGV4dChkZWYsIG9wdGlvbnMpKSxcbiAgICAgICAgZmlsdGVyOiAocGF0dGVybiwgb3B0aW9ucyA9IHt9KSA9PiBvcmlnLmZpbHRlcihwYXR0ZXJuLCBleHQoZGVmLCBvcHRpb25zKSksXG4gICAgICAgIGRlZmF1bHRzOiAob3B0aW9ucykgPT4gb3JpZy5kZWZhdWx0cyhleHQoZGVmLCBvcHRpb25zKSksXG4gICAgICAgIG1ha2VSZTogKHBhdHRlcm4sIG9wdGlvbnMgPSB7fSkgPT4gb3JpZy5tYWtlUmUocGF0dGVybiwgZXh0KGRlZiwgb3B0aW9ucykpLFxuICAgICAgICBicmFjZUV4cGFuZDogKHBhdHRlcm4sIG9wdGlvbnMgPSB7fSkgPT4gb3JpZy5icmFjZUV4cGFuZChwYXR0ZXJuLCBleHQoZGVmLCBvcHRpb25zKSksXG4gICAgICAgIG1hdGNoOiAobGlzdCwgcGF0dGVybiwgb3B0aW9ucyA9IHt9KSA9PiBvcmlnLm1hdGNoKGxpc3QsIHBhdHRlcm4sIGV4dChkZWYsIG9wdGlvbnMpKSxcbiAgICAgICAgc2VwOiBvcmlnLnNlcCxcbiAgICAgICAgR0xPQlNUQVI6IGV4cG9ydHMuR0xPQlNUQVIsXG4gICAgfSk7XG59O1xuZXhwb3J0cy5kZWZhdWx0cyA9IGRlZmF1bHRzO1xuZXhwb3J0cy5taW5pbWF0Y2guZGVmYXVsdHMgPSBleHBvcnRzLmRlZmF1bHRzO1xuLy8gQnJhY2UgZXhwYW5zaW9uOlxuLy8gYXtiLGN9ZCAtPiBhYmQgYWNkXG4vLyBhe2IsfWMgLT4gYWJjIGFjXG4vLyBhezAuLjN9ZCAtPiBhMGQgYTFkIGEyZCBhM2Rcbi8vIGF7Yixje2QsZX1mfWcgLT4gYWJnIGFjZGZnIGFjZWZnXG4vLyBhe2IsY31ke2UsZn1nIC0+IGFiZGVnIGFjZGVnIGFiZGVnIGFiZGZnXG4vL1xuLy8gSW52YWxpZCBzZXRzIGFyZSBub3QgZXhwYW5kZWQuXG4vLyBhezIuLn1iIC0+IGF7Mi4ufWJcbi8vIGF7Yn1jIC0+IGF7Yn1jXG5jb25zdCBicmFjZUV4cGFuZCA9IChwYXR0ZXJuLCBvcHRpb25zID0ge30pID0+IHtcbiAgICAoMCwgYXNzZXJ0X3ZhbGlkX3BhdHRlcm5fanNfMS5hc3NlcnRWYWxpZFBhdHRlcm4pKHBhdHRlcm4pO1xuICAgIC8vIFRoYW5rcyB0byBZZXRpbmcgTGkgPGh0dHBzOi8vZ2l0aHViLmNvbS95ZXRpbmdsaT4gZm9yXG4gICAgLy8gaW1wcm92aW5nIHRoaXMgcmVnZXhwIHRvIGF2b2lkIGEgUmVET1MgdnVsbmVyYWJpbGl0eS5cbiAgICBpZiAob3B0aW9ucy5ub2JyYWNlIHx8ICEvXFx7KD86KD8hXFx7KS4pKlxcfS8udGVzdChwYXR0ZXJuKSkge1xuICAgICAgICAvLyBzaG9ydGN1dC4gbm8gbmVlZCB0byBleHBhbmQuXG4gICAgICAgIHJldHVybiBbcGF0dGVybl07XG4gICAgfVxuICAgIHJldHVybiAoMCwgYnJhY2VfZXhwYW5zaW9uXzEuZGVmYXVsdCkocGF0dGVybik7XG59O1xuZXhwb3J0cy5icmFjZUV4cGFuZCA9IGJyYWNlRXhwYW5kO1xuZXhwb3J0cy5taW5pbWF0Y2guYnJhY2VFeHBhbmQgPSBleHBvcnRzLmJyYWNlRXhwYW5kO1xuLy8gcGFyc2UgYSBjb21wb25lbnQgb2YgdGhlIGV4cGFuZGVkIHNldC5cbi8vIEF0IHRoaXMgcG9pbnQsIG5vIHBhdHRlcm4gbWF5IGNvbnRhaW4gXCIvXCIgaW4gaXRcbi8vIHNvIHdlJ3JlIGdvaW5nIHRvIHJldHVybiBhIDJkIGFycmF5LCB3aGVyZSBlYWNoIGVudHJ5IGlzIHRoZSBmdWxsXG4vLyBwYXR0ZXJuLCBzcGxpdCBvbiAnLycsIGFuZCB0aGVuIHR1cm5lZCBpbnRvIGEgcmVndWxhciBleHByZXNzaW9uLlxuLy8gQSByZWdleHAgaXMgbWFkZSBhdCB0aGUgZW5kIHdoaWNoIGpvaW5zIGVhY2ggYXJyYXkgd2l0aCBhblxuLy8gZXNjYXBlZCAvLCBhbmQgYW5vdGhlciBmdWxsIG9uZSB3aGljaCBqb2lucyBlYWNoIHJlZ2V4cCB3aXRoIHwuXG4vL1xuLy8gRm9sbG93aW5nIHRoZSBsZWFkIG9mIEJhc2ggNC4xLCBub3RlIHRoYXQgXCIqKlwiIG9ubHkgaGFzIHNwZWNpYWwgbWVhbmluZ1xuLy8gd2hlbiBpdCBpcyB0aGUgKm9ubHkqIHRoaW5nIGluIGEgcGF0aCBwb3J0aW9uLiAgT3RoZXJ3aXNlLCBhbnkgc2VyaWVzXG4vLyBvZiAqIGlzIGVxdWl2YWxlbnQgdG8gYSBzaW5nbGUgKi4gIEdsb2JzdGFyIGJlaGF2aW9yIGlzIGVuYWJsZWQgYnlcbi8vIGRlZmF1bHQsIGFuZCBjYW4gYmUgZGlzYWJsZWQgYnkgc2V0dGluZyBvcHRpb25zLm5vZ2xvYnN0YXIuXG5jb25zdCBtYWtlUmUgPSAocGF0dGVybiwgb3B0aW9ucyA9IHt9KSA9PiBuZXcgTWluaW1hdGNoKHBhdHRlcm4sIG9wdGlvbnMpLm1ha2VSZSgpO1xuZXhwb3J0cy5tYWtlUmUgPSBtYWtlUmU7XG5leHBvcnRzLm1pbmltYXRjaC5tYWtlUmUgPSBleHBvcnRzLm1ha2VSZTtcbmNvbnN0IG1hdGNoID0gKGxpc3QsIHBhdHRlcm4sIG9wdGlvbnMgPSB7fSkgPT4ge1xuICAgIGNvbnN0IG1tID0gbmV3IE1pbmltYXRjaChwYXR0ZXJuLCBvcHRpb25zKTtcbiAgICBsaXN0ID0gbGlzdC5maWx0ZXIoZiA9PiBtbS5tYXRjaChmKSk7XG4gICAgaWYgKG1tLm9wdGlvbnMubm9udWxsICYmICFsaXN0Lmxlbmd0aCkge1xuICAgICAgICBsaXN0LnB1c2gocGF0dGVybik7XG4gICAgfVxuICAgIHJldHVybiBsaXN0O1xufTtcbmV4cG9ydHMubWF0Y2ggPSBtYXRjaDtcbmV4cG9ydHMubWluaW1hdGNoLm1hdGNoID0gZXhwb3J0cy5tYXRjaDtcbi8vIHJlcGxhY2Ugc3R1ZmYgbGlrZSBcXCogd2l0aCAqXG5jb25zdCBnbG9iTWFnaWMgPSAvWz8qXXxbK0AhXVxcKC4qP1xcKXxcXFt8XFxdLztcbmNvbnN0IHJlZ0V4cEVzY2FwZSA9IChzKSA9PiBzLnJlcGxhY2UoL1stW1xcXXt9KCkqKz8uLFxcXFxeJHwjXFxzXS9nLCAnXFxcXCQmJyk7XG5jbGFzcyBNaW5pbWF0Y2gge1xuICAgIG9wdGlvbnM7XG4gICAgc2V0O1xuICAgIHBhdHRlcm47XG4gICAgd2luZG93c1BhdGhzTm9Fc2NhcGU7XG4gICAgbm9uZWdhdGU7XG4gICAgbmVnYXRlO1xuICAgIGNvbW1lbnQ7XG4gICAgZW1wdHk7XG4gICAgcHJlc2VydmVNdWx0aXBsZVNsYXNoZXM7XG4gICAgcGFydGlhbDtcbiAgICBnbG9iU2V0O1xuICAgIGdsb2JQYXJ0cztcbiAgICBub2Nhc2U7XG4gICAgaXNXaW5kb3dzO1xuICAgIHBsYXRmb3JtO1xuICAgIHdpbmRvd3NOb01hZ2ljUm9vdDtcbiAgICByZWdleHA7XG4gICAgY29uc3RydWN0b3IocGF0dGVybiwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgICgwLCBhc3NlcnRfdmFsaWRfcGF0dGVybl9qc18xLmFzc2VydFZhbGlkUGF0dGVybikocGF0dGVybik7XG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICB0aGlzLnBhdHRlcm4gPSBwYXR0ZXJuO1xuICAgICAgICB0aGlzLnBsYXRmb3JtID0gb3B0aW9ucy5wbGF0Zm9ybSB8fCBkZWZhdWx0UGxhdGZvcm07XG4gICAgICAgIHRoaXMuaXNXaW5kb3dzID0gdGhpcy5wbGF0Zm9ybSA9PT0gJ3dpbjMyJztcbiAgICAgICAgdGhpcy53aW5kb3dzUGF0aHNOb0VzY2FwZSA9XG4gICAgICAgICAgICAhIW9wdGlvbnMud2luZG93c1BhdGhzTm9Fc2NhcGUgfHwgb3B0aW9ucy5hbGxvd1dpbmRvd3NFc2NhcGUgPT09IGZhbHNlO1xuICAgICAgICBpZiAodGhpcy53aW5kb3dzUGF0aHNOb0VzY2FwZSkge1xuICAgICAgICAgICAgdGhpcy5wYXR0ZXJuID0gdGhpcy5wYXR0ZXJuLnJlcGxhY2UoL1xcXFwvZywgJy8nKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnByZXNlcnZlTXVsdGlwbGVTbGFzaGVzID0gISFvcHRpb25zLnByZXNlcnZlTXVsdGlwbGVTbGFzaGVzO1xuICAgICAgICB0aGlzLnJlZ2V4cCA9IG51bGw7XG4gICAgICAgIHRoaXMubmVnYXRlID0gZmFsc2U7XG4gICAgICAgIHRoaXMubm9uZWdhdGUgPSAhIW9wdGlvbnMubm9uZWdhdGU7XG4gICAgICAgIHRoaXMuY29tbWVudCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmVtcHR5ID0gZmFsc2U7XG4gICAgICAgIHRoaXMucGFydGlhbCA9ICEhb3B0aW9ucy5wYXJ0aWFsO1xuICAgICAgICB0aGlzLm5vY2FzZSA9ICEhdGhpcy5vcHRpb25zLm5vY2FzZTtcbiAgICAgICAgdGhpcy53aW5kb3dzTm9NYWdpY1Jvb3QgPVxuICAgICAgICAgICAgb3B0aW9ucy53aW5kb3dzTm9NYWdpY1Jvb3QgIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgID8gb3B0aW9ucy53aW5kb3dzTm9NYWdpY1Jvb3RcbiAgICAgICAgICAgICAgICA6ICEhKHRoaXMuaXNXaW5kb3dzICYmIHRoaXMubm9jYXNlKTtcbiAgICAgICAgdGhpcy5nbG9iU2V0ID0gW107XG4gICAgICAgIHRoaXMuZ2xvYlBhcnRzID0gW107XG4gICAgICAgIHRoaXMuc2V0ID0gW107XG4gICAgICAgIC8vIG1ha2UgdGhlIHNldCBvZiByZWdleHBzIGV0Yy5cbiAgICAgICAgdGhpcy5tYWtlKCk7XG4gICAgfVxuICAgIGhhc01hZ2ljKCkge1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLm1hZ2ljYWxCcmFjZXMgJiYgdGhpcy5zZXQubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBwYXR0ZXJuIG9mIHRoaXMuc2V0KSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHBhcnQgb2YgcGF0dGVybikge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcGFydCAhPT0gJ3N0cmluZycpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZGVidWcoLi4uXykgeyB9XG4gICAgbWFrZSgpIHtcbiAgICAgICAgY29uc3QgcGF0dGVybiA9IHRoaXMucGF0dGVybjtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICAgICAgLy8gZW1wdHkgcGF0dGVybnMgYW5kIGNvbW1lbnRzIG1hdGNoIG5vdGhpbmcuXG4gICAgICAgIGlmICghb3B0aW9ucy5ub2NvbW1lbnQgJiYgcGF0dGVybi5jaGFyQXQoMCkgPT09ICcjJykge1xuICAgICAgICAgICAgdGhpcy5jb21tZW50ID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXBhdHRlcm4pIHtcbiAgICAgICAgICAgIHRoaXMuZW1wdHkgPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIHN0ZXAgMTogZmlndXJlIG91dCBuZWdhdGlvbiwgZXRjLlxuICAgICAgICB0aGlzLnBhcnNlTmVnYXRlKCk7XG4gICAgICAgIC8vIHN0ZXAgMjogZXhwYW5kIGJyYWNlc1xuICAgICAgICB0aGlzLmdsb2JTZXQgPSBbLi4ubmV3IFNldCh0aGlzLmJyYWNlRXhwYW5kKCkpXTtcbiAgICAgICAgaWYgKG9wdGlvbnMuZGVidWcpIHtcbiAgICAgICAgICAgIHRoaXMuZGVidWcgPSAoLi4uYXJncykgPT4gY29uc29sZS5lcnJvciguLi5hcmdzKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRlYnVnKHRoaXMucGF0dGVybiwgdGhpcy5nbG9iU2V0KTtcbiAgICAgICAgLy8gc3RlcCAzOiBub3cgd2UgaGF2ZSBhIHNldCwgc28gdHVybiBlYWNoIG9uZSBpbnRvIGEgc2VyaWVzIG9mXG4gICAgICAgIC8vIHBhdGgtcG9ydGlvbiBtYXRjaGluZyBwYXR0ZXJucy5cbiAgICAgICAgLy8gVGhlc2Ugd2lsbCBiZSByZWdleHBzLCBleGNlcHQgaW4gdGhlIGNhc2Ugb2YgXCIqKlwiLCB3aGljaCBpc1xuICAgICAgICAvLyBzZXQgdG8gdGhlIEdMT0JTVEFSIG9iamVjdCBmb3IgZ2xvYnN0YXIgYmVoYXZpb3IsXG4gICAgICAgIC8vIGFuZCB3aWxsIG5vdCBjb250YWluIGFueSAvIGNoYXJhY3RlcnNcbiAgICAgICAgLy9cbiAgICAgICAgLy8gRmlyc3QsIHdlIHByZXByb2Nlc3MgdG8gbWFrZSB0aGUgZ2xvYiBwYXR0ZXJuIHNldHMgYSBiaXQgc2ltcGxlclxuICAgICAgICAvLyBhbmQgZGVkdXBlZC4gIFRoZXJlIGFyZSBzb21lIHBlcmYta2lsbGluZyBwYXR0ZXJucyB0aGF0IGNhbiBjYXVzZVxuICAgICAgICAvLyBwcm9ibGVtcyB3aXRoIGEgZ2xvYiB3YWxrLCBidXQgd2UgY2FuIHNpbXBsaWZ5IHRoZW0gZG93biBhIGJpdC5cbiAgICAgICAgY29uc3QgcmF3R2xvYlBhcnRzID0gdGhpcy5nbG9iU2V0Lm1hcChzID0+IHRoaXMuc2xhc2hTcGxpdChzKSk7XG4gICAgICAgIHRoaXMuZ2xvYlBhcnRzID0gdGhpcy5wcmVwcm9jZXNzKHJhd0dsb2JQYXJ0cyk7XG4gICAgICAgIHRoaXMuZGVidWcodGhpcy5wYXR0ZXJuLCB0aGlzLmdsb2JQYXJ0cyk7XG4gICAgICAgIC8vIGdsb2IgLS0+IHJlZ2V4cHNcbiAgICAgICAgbGV0IHNldCA9IHRoaXMuZ2xvYlBhcnRzLm1hcCgocywgXywgX18pID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzV2luZG93cyAmJiB0aGlzLndpbmRvd3NOb01hZ2ljUm9vdCkge1xuICAgICAgICAgICAgICAgIC8vIGNoZWNrIGlmIGl0J3MgYSBkcml2ZSBvciB1bmMgcGF0aC5cbiAgICAgICAgICAgICAgICBjb25zdCBpc1VOQyA9IHNbMF0gPT09ICcnICYmXG4gICAgICAgICAgICAgICAgICAgIHNbMV0gPT09ICcnICYmXG4gICAgICAgICAgICAgICAgICAgIChzWzJdID09PSAnPycgfHwgIWdsb2JNYWdpYy50ZXN0KHNbMl0pKSAmJlxuICAgICAgICAgICAgICAgICAgICAhZ2xvYk1hZ2ljLnRlc3Qoc1szXSk7XG4gICAgICAgICAgICAgICAgY29uc3QgaXNEcml2ZSA9IC9eW2Etel06L2kudGVzdChzWzBdKTtcbiAgICAgICAgICAgICAgICBpZiAoaXNVTkMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsuLi5zLnNsaWNlKDAsIDQpLCAuLi5zLnNsaWNlKDQpLm1hcChzcyA9PiB0aGlzLnBhcnNlKHNzKSldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChpc0RyaXZlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbc1swXSwgLi4ucy5zbGljZSgxKS5tYXAoc3MgPT4gdGhpcy5wYXJzZShzcykpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcy5tYXAoc3MgPT4gdGhpcy5wYXJzZShzcykpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5kZWJ1Zyh0aGlzLnBhdHRlcm4sIHNldCk7XG4gICAgICAgIC8vIGZpbHRlciBvdXQgZXZlcnl0aGluZyB0aGF0IGRpZG4ndCBjb21waWxlIHByb3Blcmx5LlxuICAgICAgICB0aGlzLnNldCA9IHNldC5maWx0ZXIocyA9PiBzLmluZGV4T2YoZmFsc2UpID09PSAtMSk7XG4gICAgICAgIC8vIGRvIG5vdCB0cmVhdCB0aGUgPyBpbiBVTkMgcGF0aHMgYXMgbWFnaWNcbiAgICAgICAgaWYgKHRoaXMuaXNXaW5kb3dzKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuc2V0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcCA9IHRoaXMuc2V0W2ldO1xuICAgICAgICAgICAgICAgIGlmIChwWzBdID09PSAnJyAmJlxuICAgICAgICAgICAgICAgICAgICBwWzFdID09PSAnJyAmJlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmdsb2JQYXJ0c1tpXVsyXSA9PT0gJz8nICYmXG4gICAgICAgICAgICAgICAgICAgIHR5cGVvZiBwWzNdID09PSAnc3RyaW5nJyAmJlxuICAgICAgICAgICAgICAgICAgICAvXlthLXpdOiQvaS50ZXN0KHBbM10pKSB7XG4gICAgICAgICAgICAgICAgICAgIHBbMl0gPSAnPyc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGVidWcodGhpcy5wYXR0ZXJuLCB0aGlzLnNldCk7XG4gICAgfVxuICAgIC8vIHZhcmlvdXMgdHJhbnNmb3JtcyB0byBlcXVpdmFsZW50IHBhdHRlcm4gc2V0cyB0aGF0IGFyZVxuICAgIC8vIGZhc3RlciB0byBwcm9jZXNzIGluIGEgZmlsZXN5c3RlbSB3YWxrLiAgVGhlIGdvYWwgaXMgdG9cbiAgICAvLyBlbGltaW5hdGUgd2hhdCB3ZSBjYW4sIGFuZCBwdXNoIGFsbCAqKiBwYXR0ZXJucyBhcyBmYXJcbiAgICAvLyB0byB0aGUgcmlnaHQgYXMgcG9zc2libGUsIGV2ZW4gaWYgaXQgaW5jcmVhc2VzIHRoZSBudW1iZXJcbiAgICAvLyBvZiBwYXR0ZXJucyB0aGF0IHdlIGhhdmUgdG8gcHJvY2Vzcy5cbiAgICBwcmVwcm9jZXNzKGdsb2JQYXJ0cykge1xuICAgICAgICAvLyBpZiB3ZSdyZSBub3QgaW4gZ2xvYnN0YXIgbW9kZSwgdGhlbiB0dXJuIGFsbCAqKiBpbnRvICpcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5ub2dsb2JzdGFyKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGdsb2JQYXJ0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgZ2xvYlBhcnRzW2ldLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChnbG9iUGFydHNbaV1bal0gPT09ICcqKicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdsb2JQYXJ0c1tpXVtqXSA9ICcqJztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IG9wdGltaXphdGlvbkxldmVsID0gMSB9ID0gdGhpcy5vcHRpb25zO1xuICAgICAgICBpZiAob3B0aW1pemF0aW9uTGV2ZWwgPj0gMikge1xuICAgICAgICAgICAgLy8gYWdncmVzc2l2ZSBvcHRpbWl6YXRpb24gZm9yIHRoZSBwdXJwb3NlIG9mIGZzIHdhbGtpbmdcbiAgICAgICAgICAgIGdsb2JQYXJ0cyA9IHRoaXMuZmlyc3RQaGFzZVByZVByb2Nlc3MoZ2xvYlBhcnRzKTtcbiAgICAgICAgICAgIGdsb2JQYXJ0cyA9IHRoaXMuc2Vjb25kUGhhc2VQcmVQcm9jZXNzKGdsb2JQYXJ0cyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob3B0aW1pemF0aW9uTGV2ZWwgPj0gMSkge1xuICAgICAgICAgICAgLy8ganVzdCBiYXNpYyBvcHRpbWl6YXRpb25zIHRvIHJlbW92ZSBzb21lIC4uIHBhcnRzXG4gICAgICAgICAgICBnbG9iUGFydHMgPSB0aGlzLmxldmVsT25lT3B0aW1pemUoZ2xvYlBhcnRzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIGp1c3QgY29sbGFwc2UgbXVsdGlwbGUgKiogcG9ydGlvbnMgaW50byBvbmVcbiAgICAgICAgICAgIGdsb2JQYXJ0cyA9IHRoaXMuYWRqYXNjZW50R2xvYnN0YXJPcHRpbWl6ZShnbG9iUGFydHMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBnbG9iUGFydHM7XG4gICAgfVxuICAgIC8vIGp1c3QgZ2V0IHJpZCBvZiBhZGphc2NlbnQgKiogcG9ydGlvbnNcbiAgICBhZGphc2NlbnRHbG9ic3Rhck9wdGltaXplKGdsb2JQYXJ0cykge1xuICAgICAgICByZXR1cm4gZ2xvYlBhcnRzLm1hcChwYXJ0cyA9PiB7XG4gICAgICAgICAgICBsZXQgZ3MgPSAtMTtcbiAgICAgICAgICAgIHdoaWxlICgtMSAhPT0gKGdzID0gcGFydHMuaW5kZXhPZignKionLCBncyArIDEpKSkge1xuICAgICAgICAgICAgICAgIGxldCBpID0gZ3M7XG4gICAgICAgICAgICAgICAgd2hpbGUgKHBhcnRzW2kgKyAxXSA9PT0gJyoqJykge1xuICAgICAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpICE9PSBncykge1xuICAgICAgICAgICAgICAgICAgICBwYXJ0cy5zcGxpY2UoZ3MsIGkgLSBncyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHBhcnRzO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLy8gZ2V0IHJpZCBvZiBhZGphc2NlbnQgKiogYW5kIHJlc29sdmUgLi4gcG9ydGlvbnNcbiAgICBsZXZlbE9uZU9wdGltaXplKGdsb2JQYXJ0cykge1xuICAgICAgICByZXR1cm4gZ2xvYlBhcnRzLm1hcChwYXJ0cyA9PiB7XG4gICAgICAgICAgICBwYXJ0cyA9IHBhcnRzLnJlZHVjZSgoc2V0LCBwYXJ0KSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcHJldiA9IHNldFtzZXQubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgICAgaWYgKHBhcnQgPT09ICcqKicgJiYgcHJldiA9PT0gJyoqJykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2V0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocGFydCA9PT0gJy4uJykge1xuICAgICAgICAgICAgICAgICAgICBpZiAocHJldiAmJiBwcmV2ICE9PSAnLi4nICYmIHByZXYgIT09ICcuJyAmJiBwcmV2ICE9PSAnKionKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXQucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2V0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNldC5wdXNoKHBhcnQpO1xuICAgICAgICAgICAgICAgIHJldHVybiBzZXQ7XG4gICAgICAgICAgICB9LCBbXSk7XG4gICAgICAgICAgICByZXR1cm4gcGFydHMubGVuZ3RoID09PSAwID8gWycnXSA6IHBhcnRzO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgbGV2ZWxUd29GaWxlT3B0aW1pemUocGFydHMpIHtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHBhcnRzKSkge1xuICAgICAgICAgICAgcGFydHMgPSB0aGlzLnNsYXNoU3BsaXQocGFydHMpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBkaWRTb21ldGhpbmcgPSBmYWxzZTtcbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgZGlkU29tZXRoaW5nID0gZmFsc2U7XG4gICAgICAgICAgICAvLyA8cHJlPi88ZT4vPHJlc3Q+IC0+IDxwcmU+LzxyZXN0PlxuICAgICAgICAgICAgaWYgKCF0aGlzLnByZXNlcnZlTXVsdGlwbGVTbGFzaGVzKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCBwYXJ0cy5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcCA9IHBhcnRzW2ldO1xuICAgICAgICAgICAgICAgICAgICAvLyBkb24ndCBzcXVlZXplIG91dCBVTkMgcGF0dGVybnNcbiAgICAgICAgICAgICAgICAgICAgaWYgKGkgPT09IDEgJiYgcCA9PT0gJycgJiYgcGFydHNbMF0gPT09ICcnKVxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwID09PSAnLicgfHwgcCA9PT0gJycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpZFNvbWV0aGluZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJ0cy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpLS07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHBhcnRzWzBdID09PSAnLicgJiZcbiAgICAgICAgICAgICAgICAgICAgcGFydHMubGVuZ3RoID09PSAyICYmXG4gICAgICAgICAgICAgICAgICAgIChwYXJ0c1sxXSA9PT0gJy4nIHx8IHBhcnRzWzFdID09PSAnJykpIHtcbiAgICAgICAgICAgICAgICAgICAgZGlkU29tZXRoaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgcGFydHMucG9wKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gPHByZT4vPHA+Ly4uLzxyZXN0PiAtPiA8cHJlPi88cmVzdD5cbiAgICAgICAgICAgIGxldCBkZCA9IDA7XG4gICAgICAgICAgICB3aGlsZSAoLTEgIT09IChkZCA9IHBhcnRzLmluZGV4T2YoJy4uJywgZGQgKyAxKSkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwID0gcGFydHNbZGQgLSAxXTtcbiAgICAgICAgICAgICAgICBpZiAocCAmJiBwICE9PSAnLicgJiYgcCAhPT0gJy4uJyAmJiBwICE9PSAnKionKSB7XG4gICAgICAgICAgICAgICAgICAgIGRpZFNvbWV0aGluZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHBhcnRzLnNwbGljZShkZCAtIDEsIDIpO1xuICAgICAgICAgICAgICAgICAgICBkZCAtPSAyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSB3aGlsZSAoZGlkU29tZXRoaW5nKTtcbiAgICAgICAgcmV0dXJuIHBhcnRzLmxlbmd0aCA9PT0gMCA/IFsnJ10gOiBwYXJ0cztcbiAgICB9XG4gICAgLy8gRmlyc3QgcGhhc2U6IHNpbmdsZS1wYXR0ZXJuIHByb2Nlc3NpbmdcbiAgICAvLyA8cHJlPiBpcyAxIG9yIG1vcmUgcG9ydGlvbnNcbiAgICAvLyA8cmVzdD4gaXMgMSBvciBtb3JlIHBvcnRpb25zXG4gICAgLy8gPHA+IGlzIGFueSBwb3J0aW9uIG90aGVyIHRoYW4gLiwgLi4sICcnLCBvciAqKlxuICAgIC8vIDxlPiBpcyAuIG9yICcnXG4gICAgLy9cbiAgICAvLyAqKi8uLiBpcyAqYnJ1dGFsKiBmb3IgZmlsZXN5c3RlbSB3YWxraW5nIHBlcmZvcm1hbmNlLCBiZWNhdXNlXG4gICAgLy8gaXQgZWZmZWN0aXZlbHkgcmVzZXRzIHRoZSByZWN1cnNpdmUgd2FsayBlYWNoIHRpbWUgaXQgb2NjdXJzLFxuICAgIC8vIGFuZCAqKiBjYW5ub3QgYmUgcmVkdWNlZCBvdXQgYnkgYSAuLiBwYXR0ZXJuIHBhcnQgbGlrZSBhIHJlZ2V4cFxuICAgIC8vIG9yIG1vc3Qgc3RyaW5ncyAob3RoZXIgdGhhbiAuLiwgLiwgYW5kICcnKSBjYW4gYmUuXG4gICAgLy9cbiAgICAvLyA8cHJlPi8qKi8uLi88cD4vPHA+LzxyZXN0PiAtPiB7PHByZT4vLi4vPHA+LzxwPi88cmVzdD4sPHByZT4vKiovPHA+LzxwPi88cmVzdD59XG4gICAgLy8gPHByZT4vPGU+LzxyZXN0PiAtPiA8cHJlPi88cmVzdD5cbiAgICAvLyA8cHJlPi88cD4vLi4vPHJlc3Q+IC0+IDxwcmU+LzxyZXN0PlxuICAgIC8vICoqLyoqLzxyZXN0PiAtPiAqKi88cmVzdD5cbiAgICAvL1xuICAgIC8vICoqLyovPHJlc3Q+IC0+ICovKiovPHJlc3Q+IDw9PSBub3QgdmFsaWQgYmVjYXVzZSAqKiBkb2Vzbid0IGZvbGxvd1xuICAgIC8vIHRoaXMgV09VTEQgYmUgYWxsb3dlZCBpZiAqKiBkaWQgZm9sbG93IHN5bWxpbmtzLCBvciAqIGRpZG4ndFxuICAgIGZpcnN0UGhhc2VQcmVQcm9jZXNzKGdsb2JQYXJ0cykge1xuICAgICAgICBsZXQgZGlkU29tZXRoaW5nID0gZmFsc2U7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIGRpZFNvbWV0aGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgLy8gPHByZT4vKiovLi4vPHA+LzxwPi88cmVzdD4gLT4gezxwcmU+Ly4uLzxwPi88cD4vPHJlc3Q+LDxwcmU+LyoqLzxwPi88cD4vPHJlc3Q+fVxuICAgICAgICAgICAgZm9yIChsZXQgcGFydHMgb2YgZ2xvYlBhcnRzKSB7XG4gICAgICAgICAgICAgICAgbGV0IGdzID0gLTE7XG4gICAgICAgICAgICAgICAgd2hpbGUgKC0xICE9PSAoZ3MgPSBwYXJ0cy5pbmRleE9mKCcqKicsIGdzICsgMSkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBnc3MgPSBncztcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHBhcnRzW2dzcyArIDFdID09PSAnKionKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyA8cHJlPi8qKi8qKi88cmVzdD4gLT4gPHByZT4vKiovPHJlc3Q+XG4gICAgICAgICAgICAgICAgICAgICAgICBnc3MrKztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBlZywgaWYgZ3MgaXMgMiBhbmQgZ3NzIGlzIDQsIHRoYXQgbWVhbnMgd2UgaGF2ZSAzICoqXG4gICAgICAgICAgICAgICAgICAgIC8vIHBhcnRzLCBhbmQgY2FuIHJlbW92ZSAyIG9mIHRoZW0uXG4gICAgICAgICAgICAgICAgICAgIGlmIChnc3MgPiBncykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFydHMuc3BsaWNlKGdzICsgMSwgZ3NzIC0gZ3MpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGxldCBuZXh0ID0gcGFydHNbZ3MgKyAxXTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcCA9IHBhcnRzW2dzICsgMl07XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHAyID0gcGFydHNbZ3MgKyAzXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5leHQgIT09ICcuLicpXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFwIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBwID09PSAnLicgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIHAgPT09ICcuLicgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICFwMiB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgcDIgPT09ICcuJyB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgcDIgPT09ICcuLicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGRpZFNvbWV0aGluZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIC8vIGVkaXQgcGFydHMgaW4gcGxhY2UsIGFuZCBwdXNoIHRoZSBuZXcgb25lXG4gICAgICAgICAgICAgICAgICAgIHBhcnRzLnNwbGljZShncywgMSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG90aGVyID0gcGFydHMuc2xpY2UoMCk7XG4gICAgICAgICAgICAgICAgICAgIG90aGVyW2dzXSA9ICcqKic7XG4gICAgICAgICAgICAgICAgICAgIGdsb2JQYXJ0cy5wdXNoKG90aGVyKTtcbiAgICAgICAgICAgICAgICAgICAgZ3MtLTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gPHByZT4vPGU+LzxyZXN0PiAtPiA8cHJlPi88cmVzdD5cbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMucHJlc2VydmVNdWx0aXBsZVNsYXNoZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCBwYXJ0cy5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHAgPSBwYXJ0c1tpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGRvbid0IHNxdWVlemUgb3V0IFVOQyBwYXR0ZXJuc1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGkgPT09IDEgJiYgcCA9PT0gJycgJiYgcGFydHNbMF0gPT09ICcnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHAgPT09ICcuJyB8fCBwID09PSAnJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpZFNvbWV0aGluZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFydHMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGktLTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAocGFydHNbMF0gPT09ICcuJyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgcGFydHMubGVuZ3RoID09PSAyICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAocGFydHNbMV0gPT09ICcuJyB8fCBwYXJ0c1sxXSA9PT0gJycpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkaWRTb21ldGhpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFydHMucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gPHByZT4vPHA+Ly4uLzxyZXN0PiAtPiA8cHJlPi88cmVzdD5cbiAgICAgICAgICAgICAgICBsZXQgZGQgPSAwO1xuICAgICAgICAgICAgICAgIHdoaWxlICgtMSAhPT0gKGRkID0gcGFydHMuaW5kZXhPZignLi4nLCBkZCArIDEpKSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwID0gcGFydHNbZGQgLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHAgJiYgcCAhPT0gJy4nICYmIHAgIT09ICcuLicgJiYgcCAhPT0gJyoqJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGlkU29tZXRoaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG5lZWREb3QgPSBkZCA9PT0gMSAmJiBwYXJ0c1tkZCArIDFdID09PSAnKionO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3BsaW4gPSBuZWVkRG90ID8gWycuJ10gOiBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnRzLnNwbGljZShkZCAtIDEsIDIsIC4uLnNwbGluKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXJ0cy5sZW5ndGggPT09IDApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFydHMucHVzaCgnJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZCAtPSAyO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9IHdoaWxlIChkaWRTb21ldGhpbmcpO1xuICAgICAgICByZXR1cm4gZ2xvYlBhcnRzO1xuICAgIH1cbiAgICAvLyBzZWNvbmQgcGhhc2U6IG11bHRpLXBhdHRlcm4gZGVkdXBlc1xuICAgIC8vIHs8cHJlPi8qLzxyZXN0Piw8cHJlPi88cD4vPHJlc3Q+fSAtPiA8cHJlPi8qLzxyZXN0PlxuICAgIC8vIHs8cHJlPi88cmVzdD4sPHByZT4vPHJlc3Q+fSAtPiA8cHJlPi88cmVzdD5cbiAgICAvLyB7PHByZT4vKiovPHJlc3Q+LDxwcmU+LzxyZXN0Pn0gLT4gPHByZT4vKiovPHJlc3Q+XG4gICAgLy9cbiAgICAvLyB7PHByZT4vKiovPHJlc3Q+LDxwcmU+LyoqLzxwPi88cmVzdD59IC0+IDxwcmU+LyoqLzxyZXN0PlxuICAgIC8vIF4tLSBub3QgdmFsaWQgYmVjYXVzZSAqKiBkb2Vucyd0IGZvbGxvdyBzeW1saW5rc1xuICAgIHNlY29uZFBoYXNlUHJlUHJvY2VzcyhnbG9iUGFydHMpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBnbG9iUGFydHMubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBqID0gaSArIDE7IGogPCBnbG9iUGFydHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBtYXRjaGVkID0gdGhpcy5wYXJ0c01hdGNoKGdsb2JQYXJ0c1tpXSwgZ2xvYlBhcnRzW2pdLCAhdGhpcy5wcmVzZXJ2ZU11bHRpcGxlU2xhc2hlcyk7XG4gICAgICAgICAgICAgICAgaWYgKG1hdGNoZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgZ2xvYlBhcnRzW2ldID0gW107XG4gICAgICAgICAgICAgICAgICAgIGdsb2JQYXJ0c1tqXSA9IG1hdGNoZWQ7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZ2xvYlBhcnRzLmZpbHRlcihncyA9PiBncy5sZW5ndGgpO1xuICAgIH1cbiAgICBwYXJ0c01hdGNoKGEsIGIsIGVtcHR5R1NNYXRjaCA9IGZhbHNlKSB7XG4gICAgICAgIGxldCBhaSA9IDA7XG4gICAgICAgIGxldCBiaSA9IDA7XG4gICAgICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICAgICAgbGV0IHdoaWNoID0gJyc7XG4gICAgICAgIHdoaWxlIChhaSA8IGEubGVuZ3RoICYmIGJpIDwgYi5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmIChhW2FpXSA9PT0gYltiaV0pIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh3aGljaCA9PT0gJ2InID8gYltiaV0gOiBhW2FpXSk7XG4gICAgICAgICAgICAgICAgYWkrKztcbiAgICAgICAgICAgICAgICBiaSsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZW1wdHlHU01hdGNoICYmIGFbYWldID09PSAnKionICYmIGJbYmldID09PSBhW2FpICsgMV0pIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChhW2FpXSk7XG4gICAgICAgICAgICAgICAgYWkrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGVtcHR5R1NNYXRjaCAmJiBiW2JpXSA9PT0gJyoqJyAmJiBhW2FpXSA9PT0gYltiaSArIDFdKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goYltiaV0pO1xuICAgICAgICAgICAgICAgIGJpKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChhW2FpXSA9PT0gJyonICYmXG4gICAgICAgICAgICAgICAgYltiaV0gJiZcbiAgICAgICAgICAgICAgICAodGhpcy5vcHRpb25zLmRvdCB8fCAhYltiaV0uc3RhcnRzV2l0aCgnLicpKSAmJlxuICAgICAgICAgICAgICAgIGJbYmldICE9PSAnKionKSB7XG4gICAgICAgICAgICAgICAgaWYgKHdoaWNoID09PSAnYicpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB3aGljaCA9ICdhJztcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChhW2FpXSk7XG4gICAgICAgICAgICAgICAgYWkrKztcbiAgICAgICAgICAgICAgICBiaSsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYltiaV0gPT09ICcqJyAmJlxuICAgICAgICAgICAgICAgIGFbYWldICYmXG4gICAgICAgICAgICAgICAgKHRoaXMub3B0aW9ucy5kb3QgfHwgIWFbYWldLnN0YXJ0c1dpdGgoJy4nKSkgJiZcbiAgICAgICAgICAgICAgICBhW2FpXSAhPT0gJyoqJykge1xuICAgICAgICAgICAgICAgIGlmICh3aGljaCA9PT0gJ2EnKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgd2hpY2ggPSAnYic7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goYltiaV0pO1xuICAgICAgICAgICAgICAgIGFpKys7XG4gICAgICAgICAgICAgICAgYmkrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBpZiB3ZSBmYWxsIG91dCBvZiB0aGUgbG9vcCwgaXQgbWVhbnMgdGhleSB0d28gYXJlIGlkZW50aWNhbFxuICAgICAgICAvLyBhcyBsb25nIGFzIHRoZWlyIGxlbmd0aHMgbWF0Y2hcbiAgICAgICAgcmV0dXJuIGEubGVuZ3RoID09PSBiLmxlbmd0aCAmJiByZXN1bHQ7XG4gICAgfVxuICAgIHBhcnNlTmVnYXRlKCkge1xuICAgICAgICBpZiAodGhpcy5ub25lZ2F0ZSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3QgcGF0dGVybiA9IHRoaXMucGF0dGVybjtcbiAgICAgICAgbGV0IG5lZ2F0ZSA9IGZhbHNlO1xuICAgICAgICBsZXQgbmVnYXRlT2Zmc2V0ID0gMDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXR0ZXJuLmxlbmd0aCAmJiBwYXR0ZXJuLmNoYXJBdChpKSA9PT0gJyEnOyBpKyspIHtcbiAgICAgICAgICAgIG5lZ2F0ZSA9ICFuZWdhdGU7XG4gICAgICAgICAgICBuZWdhdGVPZmZzZXQrKztcbiAgICAgICAgfVxuICAgICAgICBpZiAobmVnYXRlT2Zmc2V0KVxuICAgICAgICAgICAgdGhpcy5wYXR0ZXJuID0gcGF0dGVybi5zbGljZShuZWdhdGVPZmZzZXQpO1xuICAgICAgICB0aGlzLm5lZ2F0ZSA9IG5lZ2F0ZTtcbiAgICB9XG4gICAgLy8gc2V0IHBhcnRpYWwgdG8gdHJ1ZSB0byB0ZXN0IGlmLCBmb3IgZXhhbXBsZSxcbiAgICAvLyBcIi9hL2JcIiBtYXRjaGVzIHRoZSBzdGFydCBvZiBcIi8qL2IvKi9kXCJcbiAgICAvLyBQYXJ0aWFsIG1lYW5zLCBpZiB5b3UgcnVuIG91dCBvZiBmaWxlIGJlZm9yZSB5b3UgcnVuXG4gICAgLy8gb3V0IG9mIHBhdHRlcm4sIHRoZW4gdGhhdCdzIGZpbmUsIGFzIGxvbmcgYXMgYWxsXG4gICAgLy8gdGhlIHBhcnRzIG1hdGNoLlxuICAgIG1hdGNoT25lKGZpbGUsIHBhdHRlcm4sIHBhcnRpYWwgPSBmYWxzZSkge1xuICAgICAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgICAgICAvLyBVTkMgcGF0aHMgbGlrZSAvLz8vWDovLi4uIGNhbiBtYXRjaCBYOi8uLi4gYW5kIHZpY2UgdmVyc2FcbiAgICAgICAgLy8gRHJpdmUgbGV0dGVycyBpbiBhYnNvbHV0ZSBkcml2ZSBvciB1bmMgcGF0aHMgYXJlIGFsd2F5cyBjb21wYXJlZFxuICAgICAgICAvLyBjYXNlLWluc2Vuc2l0aXZlbHkuXG4gICAgICAgIGlmICh0aGlzLmlzV2luZG93cykge1xuICAgICAgICAgICAgY29uc3QgZmlsZURyaXZlID0gdHlwZW9mIGZpbGVbMF0gPT09ICdzdHJpbmcnICYmIC9eW2Etel06JC9pLnRlc3QoZmlsZVswXSk7XG4gICAgICAgICAgICBjb25zdCBmaWxlVU5DID0gIWZpbGVEcml2ZSAmJlxuICAgICAgICAgICAgICAgIGZpbGVbMF0gPT09ICcnICYmXG4gICAgICAgICAgICAgICAgZmlsZVsxXSA9PT0gJycgJiZcbiAgICAgICAgICAgICAgICBmaWxlWzJdID09PSAnPycgJiZcbiAgICAgICAgICAgICAgICAvXlthLXpdOiQvaS50ZXN0KGZpbGVbM10pO1xuICAgICAgICAgICAgY29uc3QgcGF0dGVybkRyaXZlID0gdHlwZW9mIHBhdHRlcm5bMF0gPT09ICdzdHJpbmcnICYmIC9eW2Etel06JC9pLnRlc3QocGF0dGVyblswXSk7XG4gICAgICAgICAgICBjb25zdCBwYXR0ZXJuVU5DID0gIXBhdHRlcm5Ecml2ZSAmJlxuICAgICAgICAgICAgICAgIHBhdHRlcm5bMF0gPT09ICcnICYmXG4gICAgICAgICAgICAgICAgcGF0dGVyblsxXSA9PT0gJycgJiZcbiAgICAgICAgICAgICAgICBwYXR0ZXJuWzJdID09PSAnPycgJiZcbiAgICAgICAgICAgICAgICB0eXBlb2YgcGF0dGVyblszXSA9PT0gJ3N0cmluZycgJiZcbiAgICAgICAgICAgICAgICAvXlthLXpdOiQvaS50ZXN0KHBhdHRlcm5bM10pO1xuICAgICAgICAgICAgY29uc3QgZmRpID0gZmlsZVVOQyA/IDMgOiBmaWxlRHJpdmUgPyAwIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgY29uc3QgcGRpID0gcGF0dGVyblVOQyA/IDMgOiBwYXR0ZXJuRHJpdmUgPyAwIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBmZGkgPT09ICdudW1iZXInICYmIHR5cGVvZiBwZGkgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgW2ZkLCBwZF0gPSBbZmlsZVtmZGldLCBwYXR0ZXJuW3BkaV1dO1xuICAgICAgICAgICAgICAgIGlmIChmZC50b0xvd2VyQ2FzZSgpID09PSBwZC50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhdHRlcm5bcGRpXSA9IGZkO1xuICAgICAgICAgICAgICAgICAgICBpZiAocGRpID4gZmRpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXR0ZXJuID0gcGF0dGVybi5zbGljZShwZGkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGZkaSA+IHBkaSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZmlsZSA9IGZpbGUuc2xpY2UoZmRpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyByZXNvbHZlIGFuZCByZWR1Y2UgLiBhbmQgLi4gcG9ydGlvbnMgaW4gdGhlIGZpbGUgYXMgd2VsbC5cbiAgICAgICAgLy8gZG9udCcgbmVlZCB0byBkbyB0aGUgc2Vjb25kIHBoYXNlLCBiZWNhdXNlIGl0J3Mgb25seSBvbmUgc3RyaW5nW11cbiAgICAgICAgY29uc3QgeyBvcHRpbWl6YXRpb25MZXZlbCA9IDEgfSA9IHRoaXMub3B0aW9ucztcbiAgICAgICAgaWYgKG9wdGltaXphdGlvbkxldmVsID49IDIpIHtcbiAgICAgICAgICAgIGZpbGUgPSB0aGlzLmxldmVsVHdvRmlsZU9wdGltaXplKGZpbGUpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGVidWcoJ21hdGNoT25lJywgdGhpcywgeyBmaWxlLCBwYXR0ZXJuIH0pO1xuICAgICAgICB0aGlzLmRlYnVnKCdtYXRjaE9uZScsIGZpbGUubGVuZ3RoLCBwYXR0ZXJuLmxlbmd0aCk7XG4gICAgICAgIGZvciAodmFyIGZpID0gMCwgcGkgPSAwLCBmbCA9IGZpbGUubGVuZ3RoLCBwbCA9IHBhdHRlcm4ubGVuZ3RoOyBmaSA8IGZsICYmIHBpIDwgcGw7IGZpKyssIHBpKyspIHtcbiAgICAgICAgICAgIHRoaXMuZGVidWcoJ21hdGNoT25lIGxvb3AnKTtcbiAgICAgICAgICAgIHZhciBwID0gcGF0dGVybltwaV07XG4gICAgICAgICAgICB2YXIgZiA9IGZpbGVbZmldO1xuICAgICAgICAgICAgdGhpcy5kZWJ1ZyhwYXR0ZXJuLCBwLCBmKTtcbiAgICAgICAgICAgIC8vIHNob3VsZCBiZSBpbXBvc3NpYmxlLlxuICAgICAgICAgICAgLy8gc29tZSBpbnZhbGlkIHJlZ2V4cCBzdHVmZiBpbiB0aGUgc2V0LlxuICAgICAgICAgICAgLyogYzggaWdub3JlIHN0YXJ0ICovXG4gICAgICAgICAgICBpZiAocCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvKiBjOCBpZ25vcmUgc3RvcCAqL1xuICAgICAgICAgICAgaWYgKHAgPT09IGV4cG9ydHMuR0xPQlNUQVIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRlYnVnKCdHTE9CU1RBUicsIFtwYXR0ZXJuLCBwLCBmXSk7XG4gICAgICAgICAgICAgICAgLy8gXCIqKlwiXG4gICAgICAgICAgICAgICAgLy8gYS8qKi9iLyoqL2Mgd291bGQgbWF0Y2ggdGhlIGZvbGxvd2luZzpcbiAgICAgICAgICAgICAgICAvLyBhL2IveC95L3ovY1xuICAgICAgICAgICAgICAgIC8vIGEveC95L3ovYi9jXG4gICAgICAgICAgICAgICAgLy8gYS9iL3gvYi94L2NcbiAgICAgICAgICAgICAgICAvLyBhL2IvY1xuICAgICAgICAgICAgICAgIC8vIFRvIGRvIHRoaXMsIHRha2UgdGhlIHJlc3Qgb2YgdGhlIHBhdHRlcm4gYWZ0ZXJcbiAgICAgICAgICAgICAgICAvLyB0aGUgKiosIGFuZCBzZWUgaWYgaXQgd291bGQgbWF0Y2ggdGhlIGZpbGUgcmVtYWluZGVyLlxuICAgICAgICAgICAgICAgIC8vIElmIHNvLCByZXR1cm4gc3VjY2Vzcy5cbiAgICAgICAgICAgICAgICAvLyBJZiBub3QsIHRoZSAqKiBcInN3YWxsb3dzXCIgYSBzZWdtZW50LCBhbmQgdHJ5IGFnYWluLlxuICAgICAgICAgICAgICAgIC8vIFRoaXMgaXMgcmVjdXJzaXZlbHkgYXdmdWwuXG4gICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAvLyBhLyoqL2IvKiovYyBtYXRjaGluZyBhL2IveC95L3ovY1xuICAgICAgICAgICAgICAgIC8vIC0gYSBtYXRjaGVzIGFcbiAgICAgICAgICAgICAgICAvLyAtIGRvdWJsZXN0YXJcbiAgICAgICAgICAgICAgICAvLyAgIC0gbWF0Y2hPbmUoYi94L3kvei9jLCBiLyoqL2MpXG4gICAgICAgICAgICAgICAgLy8gICAgIC0gYiBtYXRjaGVzIGJcbiAgICAgICAgICAgICAgICAvLyAgICAgLSBkb3VibGVzdGFyXG4gICAgICAgICAgICAgICAgLy8gICAgICAgLSBtYXRjaE9uZSh4L3kvei9jLCBjKSAtPiBub1xuICAgICAgICAgICAgICAgIC8vICAgICAgIC0gbWF0Y2hPbmUoeS96L2MsIGMpIC0+IG5vXG4gICAgICAgICAgICAgICAgLy8gICAgICAgLSBtYXRjaE9uZSh6L2MsIGMpIC0+IG5vXG4gICAgICAgICAgICAgICAgLy8gICAgICAgLSBtYXRjaE9uZShjLCBjKSB5ZXMsIGhpdFxuICAgICAgICAgICAgICAgIHZhciBmciA9IGZpO1xuICAgICAgICAgICAgICAgIHZhciBwciA9IHBpICsgMTtcbiAgICAgICAgICAgICAgICBpZiAocHIgPT09IHBsKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGVidWcoJyoqIGF0IHRoZSBlbmQnKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gYSAqKiBhdCB0aGUgZW5kIHdpbGwganVzdCBzd2FsbG93IHRoZSByZXN0LlxuICAgICAgICAgICAgICAgICAgICAvLyBXZSBoYXZlIGZvdW5kIGEgbWF0Y2guXG4gICAgICAgICAgICAgICAgICAgIC8vIGhvd2V2ZXIsIGl0IHdpbGwgbm90IHN3YWxsb3cgLy54LCB1bmxlc3NcbiAgICAgICAgICAgICAgICAgICAgLy8gb3B0aW9ucy5kb3QgaXMgc2V0LlxuICAgICAgICAgICAgICAgICAgICAvLyAuIGFuZCAuLiBhcmUgKm5ldmVyKiBtYXRjaGVkIGJ5ICoqLCBmb3IgZXhwbG9zaXZlbHlcbiAgICAgICAgICAgICAgICAgICAgLy8gZXhwb25lbnRpYWwgcmVhc29ucy5cbiAgICAgICAgICAgICAgICAgICAgZm9yICg7IGZpIDwgZmw7IGZpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmaWxlW2ZpXSA9PT0gJy4nIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsZVtmaV0gPT09ICcuLicgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoIW9wdGlvbnMuZG90ICYmIGZpbGVbZmldLmNoYXJBdCgwKSA9PT0gJy4nKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIG9rLCBsZXQncyBzZWUgaWYgd2UgY2FuIHN3YWxsb3cgd2hhdGV2ZXIgd2UgY2FuLlxuICAgICAgICAgICAgICAgIHdoaWxlIChmciA8IGZsKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzd2FsbG93ZWUgPSBmaWxlW2ZyXTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kZWJ1ZygnXFxuZ2xvYnN0YXIgd2hpbGUnLCBmaWxlLCBmciwgcGF0dGVybiwgcHIsIHN3YWxsb3dlZSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIFhYWCByZW1vdmUgdGhpcyBzbGljZS4gIEp1c3QgcGFzcyB0aGUgc3RhcnQgaW5kZXguXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLm1hdGNoT25lKGZpbGUuc2xpY2UoZnIpLCBwYXR0ZXJuLnNsaWNlKHByKSwgcGFydGlhbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGVidWcoJ2dsb2JzdGFyIGZvdW5kIG1hdGNoIScsIGZyLCBmbCwgc3dhbGxvd2VlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGZvdW5kIGEgbWF0Y2guXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNhbid0IHN3YWxsb3cgXCIuXCIgb3IgXCIuLlwiIGV2ZXIuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjYW4gb25seSBzd2FsbG93IFwiLmZvb1wiIHdoZW4gZXhwbGljaXRseSBhc2tlZC5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzd2FsbG93ZWUgPT09ICcuJyB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN3YWxsb3dlZSA9PT0gJy4uJyB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICghb3B0aW9ucy5kb3QgJiYgc3dhbGxvd2VlLmNoYXJBdCgwKSA9PT0gJy4nKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGVidWcoJ2RvdCBkZXRlY3RlZCEnLCBmaWxlLCBmciwgcGF0dGVybiwgcHIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gKiogc3dhbGxvd3MgYSBzZWdtZW50LCBhbmQgY29udGludWUuXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRlYnVnKCdnbG9ic3RhciBzd2FsbG93IGEgc2VnbWVudCwgYW5kIGNvbnRpbnVlJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBmcisrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIG5vIG1hdGNoIHdhcyBmb3VuZC5cbiAgICAgICAgICAgICAgICAvLyBIb3dldmVyLCBpbiBwYXJ0aWFsIG1vZGUsIHdlIGNhbid0IHNheSB0aGlzIGlzIG5lY2Vzc2FyaWx5IG92ZXIuXG4gICAgICAgICAgICAgICAgLyogYzggaWdub3JlIHN0YXJ0ICovXG4gICAgICAgICAgICAgICAgaWYgKHBhcnRpYWwpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gcmFuIG91dCBvZiBmaWxlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGVidWcoJ1xcbj4+PiBubyBtYXRjaCwgcGFydGlhbD8nLCBmaWxlLCBmciwgcGF0dGVybiwgcHIpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZnIgPT09IGZsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvKiBjOCBpZ25vcmUgc3RvcCAqL1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHNvbWV0aGluZyBvdGhlciB0aGFuICoqXG4gICAgICAgICAgICAvLyBub24tbWFnaWMgcGF0dGVybnMganVzdCBoYXZlIHRvIG1hdGNoIGV4YWN0bHlcbiAgICAgICAgICAgIC8vIHBhdHRlcm5zIHdpdGggbWFnaWMgaGF2ZSBiZWVuIHR1cm5lZCBpbnRvIHJlZ2V4cHMuXG4gICAgICAgICAgICBsZXQgaGl0O1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBwID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIGhpdCA9IGYgPT09IHA7XG4gICAgICAgICAgICAgICAgdGhpcy5kZWJ1Zygnc3RyaW5nIG1hdGNoJywgcCwgZiwgaGl0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGhpdCA9IHAudGVzdChmKTtcbiAgICAgICAgICAgICAgICB0aGlzLmRlYnVnKCdwYXR0ZXJuIG1hdGNoJywgcCwgZiwgaGl0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghaGl0KVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBOb3RlOiBlbmRpbmcgaW4gLyBtZWFucyB0aGF0IHdlJ2xsIGdldCBhIGZpbmFsIFwiXCJcbiAgICAgICAgLy8gYXQgdGhlIGVuZCBvZiB0aGUgcGF0dGVybi4gIFRoaXMgY2FuIG9ubHkgbWF0Y2ggYVxuICAgICAgICAvLyBjb3JyZXNwb25kaW5nIFwiXCIgYXQgdGhlIGVuZCBvZiB0aGUgZmlsZS5cbiAgICAgICAgLy8gSWYgdGhlIGZpbGUgZW5kcyBpbiAvLCB0aGVuIGl0IGNhbiBvbmx5IG1hdGNoIGFcbiAgICAgICAgLy8gYSBwYXR0ZXJuIHRoYXQgZW5kcyBpbiAvLCB1bmxlc3MgdGhlIHBhdHRlcm4ganVzdFxuICAgICAgICAvLyBkb2Vzbid0IGhhdmUgYW55IG1vcmUgZm9yIGl0LiBCdXQsIGEvYi8gc2hvdWxkICpub3QqXG4gICAgICAgIC8vIG1hdGNoIFwiYS9iLypcIiwgZXZlbiB0aG91Z2ggXCJcIiBtYXRjaGVzIGFnYWluc3QgdGhlXG4gICAgICAgIC8vIFteL10qPyBwYXR0ZXJuLCBleGNlcHQgaW4gcGFydGlhbCBtb2RlLCB3aGVyZSBpdCBtaWdodFxuICAgICAgICAvLyBzaW1wbHkgbm90IGJlIHJlYWNoZWQgeWV0LlxuICAgICAgICAvLyBIb3dldmVyLCBhL2IvIHNob3VsZCBzdGlsbCBzYXRpc2Z5IGEvKlxuICAgICAgICAvLyBub3cgZWl0aGVyIHdlIGZlbGwgb2ZmIHRoZSBlbmQgb2YgdGhlIHBhdHRlcm4sIG9yIHdlJ3JlIGRvbmUuXG4gICAgICAgIGlmIChmaSA9PT0gZmwgJiYgcGkgPT09IHBsKSB7XG4gICAgICAgICAgICAvLyByYW4gb3V0IG9mIHBhdHRlcm4gYW5kIGZpbGVuYW1lIGF0IHRoZSBzYW1lIHRpbWUuXG4gICAgICAgICAgICAvLyBhbiBleGFjdCBoaXQhXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChmaSA9PT0gZmwpIHtcbiAgICAgICAgICAgIC8vIHJhbiBvdXQgb2YgZmlsZSwgYnV0IHN0aWxsIGhhZCBwYXR0ZXJuIGxlZnQuXG4gICAgICAgICAgICAvLyB0aGlzIGlzIG9rIGlmIHdlJ3JlIGRvaW5nIHRoZSBtYXRjaCBhcyBwYXJ0IG9mXG4gICAgICAgICAgICAvLyBhIGdsb2IgZnMgdHJhdmVyc2FsLlxuICAgICAgICAgICAgcmV0dXJuIHBhcnRpYWw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocGkgPT09IHBsKSB7XG4gICAgICAgICAgICAvLyByYW4gb3V0IG9mIHBhdHRlcm4sIHN0aWxsIGhhdmUgZmlsZSBsZWZ0LlxuICAgICAgICAgICAgLy8gdGhpcyBpcyBvbmx5IGFjY2VwdGFibGUgaWYgd2UncmUgb24gdGhlIHZlcnkgbGFzdFxuICAgICAgICAgICAgLy8gZW1wdHkgc2VnbWVudCBvZiBhIGZpbGUgd2l0aCBhIHRyYWlsaW5nIHNsYXNoLlxuICAgICAgICAgICAgLy8gYS8qIHNob3VsZCBtYXRjaCBhL2IvXG4gICAgICAgICAgICByZXR1cm4gZmkgPT09IGZsIC0gMSAmJiBmaWxlW2ZpXSA9PT0gJyc7XG4gICAgICAgICAgICAvKiBjOCBpZ25vcmUgc3RhcnQgKi9cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIHNob3VsZCBiZSB1bnJlYWNoYWJsZS5cbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignd3RmPycpO1xuICAgICAgICB9XG4gICAgICAgIC8qIGM4IGlnbm9yZSBzdG9wICovXG4gICAgfVxuICAgIGJyYWNlRXhwYW5kKCkge1xuICAgICAgICByZXR1cm4gKDAsIGV4cG9ydHMuYnJhY2VFeHBhbmQpKHRoaXMucGF0dGVybiwgdGhpcy5vcHRpb25zKTtcbiAgICB9XG4gICAgcGFyc2UocGF0dGVybikge1xuICAgICAgICAoMCwgYXNzZXJ0X3ZhbGlkX3BhdHRlcm5fanNfMS5hc3NlcnRWYWxpZFBhdHRlcm4pKHBhdHRlcm4pO1xuICAgICAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgICAgICAvLyBzaG9ydGN1dHNcbiAgICAgICAgaWYgKHBhdHRlcm4gPT09ICcqKicpXG4gICAgICAgICAgICByZXR1cm4gZXhwb3J0cy5HTE9CU1RBUjtcbiAgICAgICAgaWYgKHBhdHRlcm4gPT09ICcnKVxuICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICAvLyBmYXIgYW5kIGF3YXksIHRoZSBtb3N0IGNvbW1vbiBnbG9iIHBhdHRlcm4gcGFydHMgYXJlXG4gICAgICAgIC8vICosICouKiwgYW5kICouPGV4dD4gIEFkZCBhIGZhc3QgY2hlY2sgbWV0aG9kIGZvciB0aG9zZS5cbiAgICAgICAgbGV0IG07XG4gICAgICAgIGxldCBmYXN0VGVzdCA9IG51bGw7XG4gICAgICAgIGlmICgobSA9IHBhdHRlcm4ubWF0Y2goc3RhclJFKSkpIHtcbiAgICAgICAgICAgIGZhc3RUZXN0ID0gb3B0aW9ucy5kb3QgPyBzdGFyVGVzdERvdCA6IHN0YXJUZXN0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKChtID0gcGF0dGVybi5tYXRjaChzdGFyRG90RXh0UkUpKSkge1xuICAgICAgICAgICAgZmFzdFRlc3QgPSAob3B0aW9ucy5ub2Nhc2VcbiAgICAgICAgICAgICAgICA/IG9wdGlvbnMuZG90XG4gICAgICAgICAgICAgICAgICAgID8gc3RhckRvdEV4dFRlc3ROb2Nhc2VEb3RcbiAgICAgICAgICAgICAgICAgICAgOiBzdGFyRG90RXh0VGVzdE5vY2FzZVxuICAgICAgICAgICAgICAgIDogb3B0aW9ucy5kb3RcbiAgICAgICAgICAgICAgICAgICAgPyBzdGFyRG90RXh0VGVzdERvdFxuICAgICAgICAgICAgICAgICAgICA6IHN0YXJEb3RFeHRUZXN0KShtWzFdKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgobSA9IHBhdHRlcm4ubWF0Y2gocW1hcmtzUkUpKSkge1xuICAgICAgICAgICAgZmFzdFRlc3QgPSAob3B0aW9ucy5ub2Nhc2VcbiAgICAgICAgICAgICAgICA/IG9wdGlvbnMuZG90XG4gICAgICAgICAgICAgICAgICAgID8gcW1hcmtzVGVzdE5vY2FzZURvdFxuICAgICAgICAgICAgICAgICAgICA6IHFtYXJrc1Rlc3ROb2Nhc2VcbiAgICAgICAgICAgICAgICA6IG9wdGlvbnMuZG90XG4gICAgICAgICAgICAgICAgICAgID8gcW1hcmtzVGVzdERvdFxuICAgICAgICAgICAgICAgICAgICA6IHFtYXJrc1Rlc3QpKG0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKChtID0gcGF0dGVybi5tYXRjaChzdGFyRG90U3RhclJFKSkpIHtcbiAgICAgICAgICAgIGZhc3RUZXN0ID0gb3B0aW9ucy5kb3QgPyBzdGFyRG90U3RhclRlc3REb3QgOiBzdGFyRG90U3RhclRlc3Q7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoKG0gPSBwYXR0ZXJuLm1hdGNoKGRvdFN0YXJSRSkpKSB7XG4gICAgICAgICAgICBmYXN0VGVzdCA9IGRvdFN0YXJUZXN0O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlID0gYXN0X2pzXzEuQVNULmZyb21HbG9iKHBhdHRlcm4sIHRoaXMub3B0aW9ucykudG9NTVBhdHRlcm4oKTtcbiAgICAgICAgaWYgKGZhc3RUZXN0ICYmIHR5cGVvZiByZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIC8vIEF2b2lkcyBvdmVycmlkaW5nIGluIGZyb3plbiBlbnZpcm9ubWVudHNcbiAgICAgICAgICAgIFJlZmxlY3QuZGVmaW5lUHJvcGVydHkocmUsICd0ZXN0JywgeyB2YWx1ZTogZmFzdFRlc3QgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlO1xuICAgIH1cbiAgICBtYWtlUmUoKSB7XG4gICAgICAgIGlmICh0aGlzLnJlZ2V4cCB8fCB0aGlzLnJlZ2V4cCA9PT0gZmFsc2UpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZWdleHA7XG4gICAgICAgIC8vIGF0IHRoaXMgcG9pbnQsIHRoaXMuc2V0IGlzIGEgMmQgYXJyYXkgb2YgcGFydGlhbFxuICAgICAgICAvLyBwYXR0ZXJuIHN0cmluZ3MsIG9yIFwiKipcIi5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gSXQncyBiZXR0ZXIgdG8gdXNlIC5tYXRjaCgpLiAgVGhpcyBmdW5jdGlvbiBzaG91bGRuJ3RcbiAgICAgICAgLy8gYmUgdXNlZCwgcmVhbGx5LCBidXQgaXQncyBwcmV0dHkgY29udmVuaWVudCBzb21ldGltZXMsXG4gICAgICAgIC8vIHdoZW4geW91IGp1c3Qgd2FudCB0byB3b3JrIHdpdGggYSByZWdleC5cbiAgICAgICAgY29uc3Qgc2V0ID0gdGhpcy5zZXQ7XG4gICAgICAgIGlmICghc2V0Lmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5yZWdleHAgPSBmYWxzZTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlZ2V4cDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgICAgICBjb25zdCB0d29TdGFyID0gb3B0aW9ucy5ub2dsb2JzdGFyXG4gICAgICAgICAgICA/IHN0YXJcbiAgICAgICAgICAgIDogb3B0aW9ucy5kb3RcbiAgICAgICAgICAgICAgICA/IHR3b1N0YXJEb3RcbiAgICAgICAgICAgICAgICA6IHR3b1N0YXJOb0RvdDtcbiAgICAgICAgY29uc3QgZmxhZ3MgPSBuZXcgU2V0KG9wdGlvbnMubm9jYXNlID8gWydpJ10gOiBbXSk7XG4gICAgICAgIC8vIHJlZ2V4cGlmeSBub24tZ2xvYnN0YXIgcGF0dGVybnNcbiAgICAgICAgLy8gaWYgKiogaXMgb25seSBpdGVtLCB0aGVuIHdlIGp1c3QgZG8gb25lIHR3b1N0YXJcbiAgICAgICAgLy8gaWYgKiogaXMgZmlyc3QsIGFuZCB0aGVyZSBhcmUgbW9yZSwgcHJlcGVuZCAoXFwvfHR3b1N0YXJcXC8pPyB0byBuZXh0XG4gICAgICAgIC8vIGlmICoqIGlzIGxhc3QsIGFwcGVuZCAoXFwvdHdvU3RhcnwpIHRvIHByZXZpb3VzXG4gICAgICAgIC8vIGlmICoqIGlzIGluIHRoZSBtaWRkbGUsIGFwcGVuZCAoXFwvfFxcL3R3b1N0YXJcXC8pIHRvIHByZXZpb3VzXG4gICAgICAgIC8vIHRoZW4gZmlsdGVyIG91dCBHTE9CU1RBUiBzeW1ib2xzXG4gICAgICAgIGxldCByZSA9IHNldFxuICAgICAgICAgICAgLm1hcChwYXR0ZXJuID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHBwID0gcGF0dGVybi5tYXAocCA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHAgaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBmIG9mIHAuZmxhZ3Muc3BsaXQoJycpKVxuICAgICAgICAgICAgICAgICAgICAgICAgZmxhZ3MuYWRkKGYpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZW9mIHAgPT09ICdzdHJpbmcnXG4gICAgICAgICAgICAgICAgICAgID8gcmVnRXhwRXNjYXBlKHApXG4gICAgICAgICAgICAgICAgICAgIDogcCA9PT0gZXhwb3J0cy5HTE9CU1RBUlxuICAgICAgICAgICAgICAgICAgICAgICAgPyBleHBvcnRzLkdMT0JTVEFSXG4gICAgICAgICAgICAgICAgICAgICAgICA6IHAuX3NyYztcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcHAuZm9yRWFjaCgocCwgaSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IG5leHQgPSBwcFtpICsgMV07XG4gICAgICAgICAgICAgICAgY29uc3QgcHJldiA9IHBwW2kgLSAxXTtcbiAgICAgICAgICAgICAgICBpZiAocCAhPT0gZXhwb3J0cy5HTE9CU1RBUiB8fCBwcmV2ID09PSBleHBvcnRzLkdMT0JTVEFSKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHByZXYgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAobmV4dCAhPT0gdW5kZWZpbmVkICYmIG5leHQgIT09IGV4cG9ydHMuR0xPQlNUQVIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBwW2kgKyAxXSA9ICcoPzpcXFxcL3wnICsgdHdvU3RhciArICdcXFxcLyk/JyArIG5leHQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcFtpXSA9IHR3b1N0YXI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAobmV4dCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHBwW2kgLSAxXSA9IHByZXYgKyAnKD86XFxcXC98JyArIHR3b1N0YXIgKyAnKT8nO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChuZXh0ICE9PSBleHBvcnRzLkdMT0JTVEFSKSB7XG4gICAgICAgICAgICAgICAgICAgIHBwW2kgLSAxXSA9IHByZXYgKyAnKD86XFxcXC98XFxcXC8nICsgdHdvU3RhciArICdcXFxcLyknICsgbmV4dDtcbiAgICAgICAgICAgICAgICAgICAgcHBbaSArIDFdID0gZXhwb3J0cy5HTE9CU1RBUjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBwcC5maWx0ZXIocCA9PiBwICE9PSBleHBvcnRzLkdMT0JTVEFSKS5qb2luKCcvJyk7XG4gICAgICAgIH0pXG4gICAgICAgICAgICAuam9pbignfCcpO1xuICAgICAgICAvLyBuZWVkIHRvIHdyYXAgaW4gcGFyZW5zIGlmIHdlIGhhZCBtb3JlIHRoYW4gb25lIHRoaW5nIHdpdGggfCxcbiAgICAgICAgLy8gb3RoZXJ3aXNlIG9ubHkgdGhlIGZpcnN0IHdpbGwgYmUgYW5jaG9yZWQgdG8gXiBhbmQgdGhlIGxhc3QgdG8gJFxuICAgICAgICBjb25zdCBbb3BlbiwgY2xvc2VdID0gc2V0Lmxlbmd0aCA+IDEgPyBbJyg/OicsICcpJ10gOiBbJycsICcnXTtcbiAgICAgICAgLy8gbXVzdCBtYXRjaCBlbnRpcmUgcGF0dGVyblxuICAgICAgICAvLyBlbmRpbmcgaW4gYSAqIG9yICoqIHdpbGwgbWFrZSBpdCBsZXNzIHN0cmljdC5cbiAgICAgICAgcmUgPSAnXicgKyBvcGVuICsgcmUgKyBjbG9zZSArICckJztcbiAgICAgICAgLy8gY2FuIG1hdGNoIGFueXRoaW5nLCBhcyBsb25nIGFzIGl0J3Mgbm90IHRoaXMuXG4gICAgICAgIGlmICh0aGlzLm5lZ2F0ZSlcbiAgICAgICAgICAgIHJlID0gJ14oPyEnICsgcmUgKyAnKS4rJCc7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLnJlZ2V4cCA9IG5ldyBSZWdFeHAocmUsIFsuLi5mbGFnc10uam9pbignJykpO1xuICAgICAgICAgICAgLyogYzggaWdub3JlIHN0YXJ0ICovXG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgICAvLyBzaG91bGQgYmUgaW1wb3NzaWJsZVxuICAgICAgICAgICAgdGhpcy5yZWdleHAgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvKiBjOCBpZ25vcmUgc3RvcCAqL1xuICAgICAgICByZXR1cm4gdGhpcy5yZWdleHA7XG4gICAgfVxuICAgIHNsYXNoU3BsaXQocCkge1xuICAgICAgICAvLyBpZiBwIHN0YXJ0cyB3aXRoIC8vIG9uIHdpbmRvd3MsIHdlIHByZXNlcnZlIHRoYXRcbiAgICAgICAgLy8gc28gdGhhdCBVTkMgcGF0aHMgYXJlbid0IGJyb2tlbi4gIE90aGVyd2lzZSwgYW55IG51bWJlciBvZlxuICAgICAgICAvLyAvIGNoYXJhY3RlcnMgYXJlIGNvYWxlc2NlZCBpbnRvIG9uZSwgdW5sZXNzXG4gICAgICAgIC8vIHByZXNlcnZlTXVsdGlwbGVTbGFzaGVzIGlzIHNldCB0byB0cnVlLlxuICAgICAgICBpZiAodGhpcy5wcmVzZXJ2ZU11bHRpcGxlU2xhc2hlcykge1xuICAgICAgICAgICAgcmV0dXJuIHAuc3BsaXQoJy8nKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLmlzV2luZG93cyAmJiAvXlxcL1xcL1teXFwvXSsvLnRlc3QocCkpIHtcbiAgICAgICAgICAgIC8vIGFkZCBhbiBleHRyYSAnJyBmb3IgdGhlIG9uZSB3ZSBsb3NlXG4gICAgICAgICAgICByZXR1cm4gWycnLCAuLi5wLnNwbGl0KC9cXC8rLyldO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHAuc3BsaXQoL1xcLysvKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBtYXRjaChmLCBwYXJ0aWFsID0gdGhpcy5wYXJ0aWFsKSB7XG4gICAgICAgIHRoaXMuZGVidWcoJ21hdGNoJywgZiwgdGhpcy5wYXR0ZXJuKTtcbiAgICAgICAgLy8gc2hvcnQtY2lyY3VpdCBpbiB0aGUgY2FzZSBvZiBidXN0ZWQgdGhpbmdzLlxuICAgICAgICAvLyBjb21tZW50cywgZXRjLlxuICAgICAgICBpZiAodGhpcy5jb21tZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZW1wdHkpIHtcbiAgICAgICAgICAgIHJldHVybiBmID09PSAnJztcbiAgICAgICAgfVxuICAgICAgICBpZiAoZiA9PT0gJy8nICYmIHBhcnRpYWwpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgICAgIC8vIHdpbmRvd3M6IG5lZWQgdG8gdXNlIC8sIG5vdCBcXFxuICAgICAgICBpZiAodGhpcy5pc1dpbmRvd3MpIHtcbiAgICAgICAgICAgIGYgPSBmLnNwbGl0KCdcXFxcJykuam9pbignLycpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHRyZWF0IHRoZSB0ZXN0IHBhdGggYXMgYSBzZXQgb2YgcGF0aHBhcnRzLlxuICAgICAgICBjb25zdCBmZiA9IHRoaXMuc2xhc2hTcGxpdChmKTtcbiAgICAgICAgdGhpcy5kZWJ1Zyh0aGlzLnBhdHRlcm4sICdzcGxpdCcsIGZmKTtcbiAgICAgICAgLy8ganVzdCBPTkUgb2YgdGhlIHBhdHRlcm4gc2V0cyBpbiB0aGlzLnNldCBuZWVkcyB0byBtYXRjaFxuICAgICAgICAvLyBpbiBvcmRlciBmb3IgaXQgdG8gYmUgdmFsaWQuICBJZiBuZWdhdGluZywgdGhlbiBqdXN0IG9uZVxuICAgICAgICAvLyBtYXRjaCBtZWFucyB0aGF0IHdlIGhhdmUgZmFpbGVkLlxuICAgICAgICAvLyBFaXRoZXIgd2F5LCByZXR1cm4gb24gdGhlIGZpcnN0IGhpdC5cbiAgICAgICAgY29uc3Qgc2V0ID0gdGhpcy5zZXQ7XG4gICAgICAgIHRoaXMuZGVidWcodGhpcy5wYXR0ZXJuLCAnc2V0Jywgc2V0KTtcbiAgICAgICAgLy8gRmluZCB0aGUgYmFzZW5hbWUgb2YgdGhlIHBhdGggYnkgbG9va2luZyBmb3IgdGhlIGxhc3Qgbm9uLWVtcHR5IHNlZ21lbnRcbiAgICAgICAgbGV0IGZpbGVuYW1lID0gZmZbZmYubGVuZ3RoIC0gMV07XG4gICAgICAgIGlmICghZmlsZW5hbWUpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSBmZi5sZW5ndGggLSAyOyAhZmlsZW5hbWUgJiYgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgICAgICBmaWxlbmFtZSA9IGZmW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2V0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBwYXR0ZXJuID0gc2V0W2ldO1xuICAgICAgICAgICAgbGV0IGZpbGUgPSBmZjtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLm1hdGNoQmFzZSAmJiBwYXR0ZXJuLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICAgIGZpbGUgPSBbZmlsZW5hbWVdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgaGl0ID0gdGhpcy5tYXRjaE9uZShmaWxlLCBwYXR0ZXJuLCBwYXJ0aWFsKTtcbiAgICAgICAgICAgIGlmIChoaXQpIHtcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5mbGlwTmVnYXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gIXRoaXMubmVnYXRlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGRpZG4ndCBnZXQgYW55IGhpdHMuICB0aGlzIGlzIHN1Y2Nlc3MgaWYgaXQncyBhIG5lZ2F0aXZlXG4gICAgICAgIC8vIHBhdHRlcm4sIGZhaWx1cmUgb3RoZXJ3aXNlLlxuICAgICAgICBpZiAob3B0aW9ucy5mbGlwTmVnYXRlKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMubmVnYXRlO1xuICAgIH1cbiAgICBzdGF0aWMgZGVmYXVsdHMoZGVmKSB7XG4gICAgICAgIHJldHVybiBleHBvcnRzLm1pbmltYXRjaC5kZWZhdWx0cyhkZWYpLk1pbmltYXRjaDtcbiAgICB9XG59XG5leHBvcnRzLk1pbmltYXRjaCA9IE1pbmltYXRjaDtcbi8qIGM4IGlnbm9yZSBzdGFydCAqL1xudmFyIGFzdF9qc18yID0gcmVxdWlyZShcIi4vYXN0LmpzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQVNUXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBhc3RfanNfMi5BU1Q7IH0gfSk7XG52YXIgZXNjYXBlX2pzXzIgPSByZXF1aXJlKFwiLi9lc2NhcGUuanNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJlc2NhcGVcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGVzY2FwZV9qc18yLmVzY2FwZTsgfSB9KTtcbnZhciB1bmVzY2FwZV9qc18yID0gcmVxdWlyZShcIi4vdW5lc2NhcGUuanNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJ1bmVzY2FwZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdW5lc2NhcGVfanNfMi51bmVzY2FwZTsgfSB9KTtcbi8qIGM4IGlnbm9yZSBzdG9wICovXG5leHBvcnRzLm1pbmltYXRjaC5BU1QgPSBhc3RfanNfMS5BU1Q7XG5leHBvcnRzLm1pbmltYXRjaC5NaW5pbWF0Y2ggPSBNaW5pbWF0Y2g7XG5leHBvcnRzLm1pbmltYXRjaC5lc2NhcGUgPSBlc2NhcGVfanNfMS5lc2NhcGU7XG5leHBvcnRzLm1pbmltYXRjaC51bmVzY2FwZSA9IHVuZXNjYXBlX2pzXzEudW5lc2NhcGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/minimatch/dist/commonjs/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/minimatch/dist/commonjs/unescape.js":
/*!**********************************************************!*\
  !*** ./node_modules/minimatch/dist/commonjs/unescape.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.unescape = void 0;\n/**\n * Un-escape a string that has been escaped with {@link escape}.\n *\n * If the {@link windowsPathsNoEscape} option is used, then square-brace\n * escapes are removed, but not backslash escapes.  For example, it will turn\n * the string `'[*]'` into `*`, but it will not turn `'\\\\*'` into `'*'`,\n * becuase `\\` is a path separator in `windowsPathsNoEscape` mode.\n *\n * When `windowsPathsNoEscape` is not set, then both brace escapes and\n * backslash escapes are removed.\n *\n * Slashes (and backslashes in `windowsPathsNoEscape` mode) cannot be escaped\n * or unescaped.\n */\nconst unescape = (s, { windowsPathsNoEscape = false, } = {}) => {\n    return windowsPathsNoEscape\n        ? s.replace(/\\[([^\\/\\\\])\\]/g, '$1')\n        : s.replace(/((?!\\\\).|^)\\[([^\\/\\\\])\\]/g, '$1$2').replace(/\\\\([^\\/])/g, '$1');\n};\nexports.unescape = unescape;\n//# sourceMappingURL=unescape.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbWluaW1hdGNoL2Rpc3QvY29tbW9uanMvdW5lc2NhcGUuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsZ0JBQWdCO0FBQ2hCO0FBQ0Esa0RBQWtELGFBQWE7QUFDL0Q7QUFDQSxXQUFXLDRCQUE0QjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixnQ0FBZ0MsSUFBSTtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQiIsInNvdXJjZXMiOlsid2VicGFjazovL2F1dG8tbG9vcC1kZW1vLy4vbm9kZV9tb2R1bGVzL21pbmltYXRjaC9kaXN0L2NvbW1vbmpzL3VuZXNjYXBlLmpzPzlkNzkiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnVuZXNjYXBlID0gdm9pZCAwO1xuLyoqXG4gKiBVbi1lc2NhcGUgYSBzdHJpbmcgdGhhdCBoYXMgYmVlbiBlc2NhcGVkIHdpdGgge0BsaW5rIGVzY2FwZX0uXG4gKlxuICogSWYgdGhlIHtAbGluayB3aW5kb3dzUGF0aHNOb0VzY2FwZX0gb3B0aW9uIGlzIHVzZWQsIHRoZW4gc3F1YXJlLWJyYWNlXG4gKiBlc2NhcGVzIGFyZSByZW1vdmVkLCBidXQgbm90IGJhY2tzbGFzaCBlc2NhcGVzLiAgRm9yIGV4YW1wbGUsIGl0IHdpbGwgdHVyblxuICogdGhlIHN0cmluZyBgJ1sqXSdgIGludG8gYCpgLCBidXQgaXQgd2lsbCBub3QgdHVybiBgJ1xcXFwqJ2AgaW50byBgJyonYCxcbiAqIGJlY3Vhc2UgYFxcYCBpcyBhIHBhdGggc2VwYXJhdG9yIGluIGB3aW5kb3dzUGF0aHNOb0VzY2FwZWAgbW9kZS5cbiAqXG4gKiBXaGVuIGB3aW5kb3dzUGF0aHNOb0VzY2FwZWAgaXMgbm90IHNldCwgdGhlbiBib3RoIGJyYWNlIGVzY2FwZXMgYW5kXG4gKiBiYWNrc2xhc2ggZXNjYXBlcyBhcmUgcmVtb3ZlZC5cbiAqXG4gKiBTbGFzaGVzIChhbmQgYmFja3NsYXNoZXMgaW4gYHdpbmRvd3NQYXRoc05vRXNjYXBlYCBtb2RlKSBjYW5ub3QgYmUgZXNjYXBlZFxuICogb3IgdW5lc2NhcGVkLlxuICovXG5jb25zdCB1bmVzY2FwZSA9IChzLCB7IHdpbmRvd3NQYXRoc05vRXNjYXBlID0gZmFsc2UsIH0gPSB7fSkgPT4ge1xuICAgIHJldHVybiB3aW5kb3dzUGF0aHNOb0VzY2FwZVxuICAgICAgICA/IHMucmVwbGFjZSgvXFxbKFteXFwvXFxcXF0pXFxdL2csICckMScpXG4gICAgICAgIDogcy5yZXBsYWNlKC8oKD8hXFxcXCkufF4pXFxbKFteXFwvXFxcXF0pXFxdL2csICckMSQyJykucmVwbGFjZSgvXFxcXChbXlxcL10pL2csICckMScpO1xufTtcbmV4cG9ydHMudW5lc2NhcGUgPSB1bmVzY2FwZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXVuZXNjYXBlLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/minimatch/dist/commonjs/unescape.js\n");

/***/ }),

/***/ "(instrument)/./node_modules/minimatch/dist/commonjs/assert-valid-pattern.js":
/*!**********************************************************************!*\
  !*** ./node_modules/minimatch/dist/commonjs/assert-valid-pattern.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.assertValidPattern = void 0;\nconst MAX_PATTERN_LENGTH = 1024 * 64;\nconst assertValidPattern = (pattern) => {\n    if (typeof pattern !== 'string') {\n        throw new TypeError('invalid pattern');\n    }\n    if (pattern.length > MAX_PATTERN_LENGTH) {\n        throw new TypeError('pattern is too long');\n    }\n};\nexports.assertValidPattern = assertValidPattern;\n//# sourceMappingURL=assert-valid-pattern.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGluc3RydW1lbnQpLy4vbm9kZV9tb2R1bGVzL21pbmltYXRjaC9kaXN0L2NvbW1vbmpzL2Fzc2VydC12YWxpZC1wYXR0ZXJuLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hdXRvLWxvb3AtZGVtby8uL25vZGVfbW9kdWxlcy9taW5pbWF0Y2gvZGlzdC9jb21tb25qcy9hc3NlcnQtdmFsaWQtcGF0dGVybi5qcz81MDY1Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5hc3NlcnRWYWxpZFBhdHRlcm4gPSB2b2lkIDA7XG5jb25zdCBNQVhfUEFUVEVSTl9MRU5HVEggPSAxMDI0ICogNjQ7XG5jb25zdCBhc3NlcnRWYWxpZFBhdHRlcm4gPSAocGF0dGVybikgPT4ge1xuICAgIGlmICh0eXBlb2YgcGF0dGVybiAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCBwYXR0ZXJuJyk7XG4gICAgfVxuICAgIGlmIChwYXR0ZXJuLmxlbmd0aCA+IE1BWF9QQVRURVJOX0xFTkdUSCkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdwYXR0ZXJuIGlzIHRvbyBsb25nJyk7XG4gICAgfVxufTtcbmV4cG9ydHMuYXNzZXJ0VmFsaWRQYXR0ZXJuID0gYXNzZXJ0VmFsaWRQYXR0ZXJuO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXNzZXJ0LXZhbGlkLXBhdHRlcm4uanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(instrument)/./node_modules/minimatch/dist/commonjs/assert-valid-pattern.js\n");

/***/ }),

/***/ "(instrument)/./node_modules/minimatch/dist/commonjs/ast.js":
/*!*****************************************************!*\
  !*** ./node_modules/minimatch/dist/commonjs/ast.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n// parse a single path portion\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.AST = void 0;\nconst brace_expressions_js_1 = __webpack_require__(/*! ./brace-expressions.js */ \"(instrument)/./node_modules/minimatch/dist/commonjs/brace-expressions.js\");\nconst unescape_js_1 = __webpack_require__(/*! ./unescape.js */ \"(instrument)/./node_modules/minimatch/dist/commonjs/unescape.js\");\nconst types = new Set(['!', '?', '+', '*', '@']);\nconst isExtglobType = (c) => types.has(c);\n// Patterns that get prepended to bind to the start of either the\n// entire string, or just a single path portion, to prevent dots\n// and/or traversal patterns, when needed.\n// Exts don't need the ^ or / bit, because the root binds that already.\nconst startNoTraversal = '(?!(?:^|/)\\\\.\\\\.?(?:$|/))';\nconst startNoDot = '(?!\\\\.)';\n// characters that indicate a start of pattern needs the \"no dots\" bit,\n// because a dot *might* be matched. ( is not in the list, because in\n// the case of a child extglob, it will handle the prevention itself.\nconst addPatternStart = new Set(['[', '.']);\n// cases where traversal is A-OK, no dot prevention needed\nconst justDots = new Set(['..', '.']);\nconst reSpecials = new Set('().*{}+?[]^$\\\\!');\nconst regExpEscape = (s) => s.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, '\\\\$&');\n// any single thing other than /\nconst qmark = '[^/]';\n// * => any number of characters\nconst star = qmark + '*?';\n// use + when we need to ensure that *something* matches, because the * is\n// the only thing in the path portion.\nconst starNoEmpty = qmark + '+?';\n// remove the \\ chars that we added if we end up doing a nonmagic compare\n// const deslash = (s: string) => s.replace(/\\\\(.)/g, '$1')\nclass AST {\n    type;\n    #root;\n    #hasMagic;\n    #uflag = false;\n    #parts = [];\n    #parent;\n    #parentIndex;\n    #negs;\n    #filledNegs = false;\n    #options;\n    #toString;\n    // set to true if it's an extglob with no children\n    // (which really means one child of '')\n    #emptyExt = false;\n    constructor(type, parent, options = {}) {\n        this.type = type;\n        // extglobs are inherently magical\n        if (type)\n            this.#hasMagic = true;\n        this.#parent = parent;\n        this.#root = this.#parent ? this.#parent.#root : this;\n        this.#options = this.#root === this ? options : this.#root.#options;\n        this.#negs = this.#root === this ? [] : this.#root.#negs;\n        if (type === '!' && !this.#root.#filledNegs)\n            this.#negs.push(this);\n        this.#parentIndex = this.#parent ? this.#parent.#parts.length : 0;\n    }\n    get hasMagic() {\n        /* c8 ignore start */\n        if (this.#hasMagic !== undefined)\n            return this.#hasMagic;\n        /* c8 ignore stop */\n        for (const p of this.#parts) {\n            if (typeof p === 'string')\n                continue;\n            if (p.type || p.hasMagic)\n                return (this.#hasMagic = true);\n        }\n        // note: will be undefined until we generate the regexp src and find out\n        return this.#hasMagic;\n    }\n    // reconstructs the pattern\n    toString() {\n        if (this.#toString !== undefined)\n            return this.#toString;\n        if (!this.type) {\n            return (this.#toString = this.#parts.map(p => String(p)).join(''));\n        }\n        else {\n            return (this.#toString =\n                this.type + '(' + this.#parts.map(p => String(p)).join('|') + ')');\n        }\n    }\n    #fillNegs() {\n        /* c8 ignore start */\n        if (this !== this.#root)\n            throw new Error('should only call on root');\n        if (this.#filledNegs)\n            return this;\n        /* c8 ignore stop */\n        // call toString() once to fill this out\n        this.toString();\n        this.#filledNegs = true;\n        let n;\n        while ((n = this.#negs.pop())) {\n            if (n.type !== '!')\n                continue;\n            // walk up the tree, appending everthing that comes AFTER parentIndex\n            let p = n;\n            let pp = p.#parent;\n            while (pp) {\n                for (let i = p.#parentIndex + 1; !pp.type && i < pp.#parts.length; i++) {\n                    for (const part of n.#parts) {\n                        /* c8 ignore start */\n                        if (typeof part === 'string') {\n                            throw new Error('string part in extglob AST??');\n                        }\n                        /* c8 ignore stop */\n                        part.copyIn(pp.#parts[i]);\n                    }\n                }\n                p = pp;\n                pp = p.#parent;\n            }\n        }\n        return this;\n    }\n    push(...parts) {\n        for (const p of parts) {\n            if (p === '')\n                continue;\n            /* c8 ignore start */\n            if (typeof p !== 'string' && !(p instanceof AST && p.#parent === this)) {\n                throw new Error('invalid part: ' + p);\n            }\n            /* c8 ignore stop */\n            this.#parts.push(p);\n        }\n    }\n    toJSON() {\n        const ret = this.type === null\n            ? this.#parts.slice().map(p => (typeof p === 'string' ? p : p.toJSON()))\n            : [this.type, ...this.#parts.map(p => p.toJSON())];\n        if (this.isStart() && !this.type)\n            ret.unshift([]);\n        if (this.isEnd() &&\n            (this === this.#root ||\n                (this.#root.#filledNegs && this.#parent?.type === '!'))) {\n            ret.push({});\n        }\n        return ret;\n    }\n    isStart() {\n        if (this.#root === this)\n            return true;\n        // if (this.type) return !!this.#parent?.isStart()\n        if (!this.#parent?.isStart())\n            return false;\n        if (this.#parentIndex === 0)\n            return true;\n        // if everything AHEAD of this is a negation, then it's still the \"start\"\n        const p = this.#parent;\n        for (let i = 0; i < this.#parentIndex; i++) {\n            const pp = p.#parts[i];\n            if (!(pp instanceof AST && pp.type === '!')) {\n                return false;\n            }\n        }\n        return true;\n    }\n    isEnd() {\n        if (this.#root === this)\n            return true;\n        if (this.#parent?.type === '!')\n            return true;\n        if (!this.#parent?.isEnd())\n            return false;\n        if (!this.type)\n            return this.#parent?.isEnd();\n        // if not root, it'll always have a parent\n        /* c8 ignore start */\n        const pl = this.#parent ? this.#parent.#parts.length : 0;\n        /* c8 ignore stop */\n        return this.#parentIndex === pl - 1;\n    }\n    copyIn(part) {\n        if (typeof part === 'string')\n            this.push(part);\n        else\n            this.push(part.clone(this));\n    }\n    clone(parent) {\n        const c = new AST(this.type, parent);\n        for (const p of this.#parts) {\n            c.copyIn(p);\n        }\n        return c;\n    }\n    static #parseAST(str, ast, pos, opt) {\n        let escaping = false;\n        let inBrace = false;\n        let braceStart = -1;\n        let braceNeg = false;\n        if (ast.type === null) {\n            // outside of a extglob, append until we find a start\n            let i = pos;\n            let acc = '';\n            while (i < str.length) {\n                const c = str.charAt(i++);\n                // still accumulate escapes at this point, but we do ignore\n                // starts that are escaped\n                if (escaping || c === '\\\\') {\n                    escaping = !escaping;\n                    acc += c;\n                    continue;\n                }\n                if (inBrace) {\n                    if (i === braceStart + 1) {\n                        if (c === '^' || c === '!') {\n                            braceNeg = true;\n                        }\n                    }\n                    else if (c === ']' && !(i === braceStart + 2 && braceNeg)) {\n                        inBrace = false;\n                    }\n                    acc += c;\n                    continue;\n                }\n                else if (c === '[') {\n                    inBrace = true;\n                    braceStart = i;\n                    braceNeg = false;\n                    acc += c;\n                    continue;\n                }\n                if (!opt.noext && isExtglobType(c) && str.charAt(i) === '(') {\n                    ast.push(acc);\n                    acc = '';\n                    const ext = new AST(c, ast);\n                    i = AST.#parseAST(str, ext, i, opt);\n                    ast.push(ext);\n                    continue;\n                }\n                acc += c;\n            }\n            ast.push(acc);\n            return i;\n        }\n        // some kind of extglob, pos is at the (\n        // find the next | or )\n        let i = pos + 1;\n        let part = new AST(null, ast);\n        const parts = [];\n        let acc = '';\n        while (i < str.length) {\n            const c = str.charAt(i++);\n            // still accumulate escapes at this point, but we do ignore\n            // starts that are escaped\n            if (escaping || c === '\\\\') {\n                escaping = !escaping;\n                acc += c;\n                continue;\n            }\n            if (inBrace) {\n                if (i === braceStart + 1) {\n                    if (c === '^' || c === '!') {\n                        braceNeg = true;\n                    }\n                }\n                else if (c === ']' && !(i === braceStart + 2 && braceNeg)) {\n                    inBrace = false;\n                }\n                acc += c;\n                continue;\n            }\n            else if (c === '[') {\n                inBrace = true;\n                braceStart = i;\n                braceNeg = false;\n                acc += c;\n                continue;\n            }\n            if (isExtglobType(c) && str.charAt(i) === '(') {\n                part.push(acc);\n                acc = '';\n                const ext = new AST(c, part);\n                part.push(ext);\n                i = AST.#parseAST(str, ext, i, opt);\n                continue;\n            }\n            if (c === '|') {\n                part.push(acc);\n                acc = '';\n                parts.push(part);\n                part = new AST(null, ast);\n                continue;\n            }\n            if (c === ')') {\n                if (acc === '' && ast.#parts.length === 0) {\n                    ast.#emptyExt = true;\n                }\n                part.push(acc);\n                acc = '';\n                ast.push(...parts, part);\n                return i;\n            }\n            acc += c;\n        }\n        // unfinished extglob\n        // if we got here, it was a malformed extglob! not an extglob, but\n        // maybe something else in there.\n        ast.type = null;\n        ast.#hasMagic = undefined;\n        ast.#parts = [str.substring(pos - 1)];\n        return i;\n    }\n    static fromGlob(pattern, options = {}) {\n        const ast = new AST(null, undefined, options);\n        AST.#parseAST(pattern, ast, 0, options);\n        return ast;\n    }\n    // returns the regular expression if there's magic, or the unescaped\n    // string if not.\n    toMMPattern() {\n        // should only be called on root\n        /* c8 ignore start */\n        if (this !== this.#root)\n            return this.#root.toMMPattern();\n        /* c8 ignore stop */\n        const glob = this.toString();\n        const [re, body, hasMagic, uflag] = this.toRegExpSource();\n        // if we're in nocase mode, and not nocaseMagicOnly, then we do\n        // still need a regular expression if we have to case-insensitively\n        // match capital/lowercase characters.\n        const anyMagic = hasMagic ||\n            this.#hasMagic ||\n            (this.#options.nocase &&\n                !this.#options.nocaseMagicOnly &&\n                glob.toUpperCase() !== glob.toLowerCase());\n        if (!anyMagic) {\n            return body;\n        }\n        const flags = (this.#options.nocase ? 'i' : '') + (uflag ? 'u' : '');\n        return Object.assign(new RegExp(`^${re}$`, flags), {\n            _src: re,\n            _glob: glob,\n        });\n    }\n    get options() {\n        return this.#options;\n    }\n    // returns the string match, the regexp source, whether there's magic\n    // in the regexp (so a regular expression is required) and whether or\n    // not the uflag is needed for the regular expression (for posix classes)\n    // TODO: instead of injecting the start/end at this point, just return\n    // the BODY of the regexp, along with the start/end portions suitable\n    // for binding the start/end in either a joined full-path makeRe context\n    // (where we bind to (^|/), or a standalone matchPart context (where\n    // we bind to ^, and not /).  Otherwise slashes get duped!\n    //\n    // In part-matching mode, the start is:\n    // - if not isStart: nothing\n    // - if traversal possible, but not allowed: ^(?!\\.\\.?$)\n    // - if dots allowed or not possible: ^\n    // - if dots possible and not allowed: ^(?!\\.)\n    // end is:\n    // - if not isEnd(): nothing\n    // - else: $\n    //\n    // In full-path matching mode, we put the slash at the START of the\n    // pattern, so start is:\n    // - if first pattern: same as part-matching mode\n    // - if not isStart(): nothing\n    // - if traversal possible, but not allowed: /(?!\\.\\.?(?:$|/))\n    // - if dots allowed or not possible: /\n    // - if dots possible and not allowed: /(?!\\.)\n    // end is:\n    // - if last pattern, same as part-matching mode\n    // - else nothing\n    //\n    // Always put the (?:$|/) on negated tails, though, because that has to be\n    // there to bind the end of the negated pattern portion, and it's easier to\n    // just stick it in now rather than try to inject it later in the middle of\n    // the pattern.\n    //\n    // We can just always return the same end, and leave it up to the caller\n    // to know whether it's going to be used joined or in parts.\n    // And, if the start is adjusted slightly, can do the same there:\n    // - if not isStart: nothing\n    // - if traversal possible, but not allowed: (?:/|^)(?!\\.\\.?$)\n    // - if dots allowed or not possible: (?:/|^)\n    // - if dots possible and not allowed: (?:/|^)(?!\\.)\n    //\n    // But it's better to have a simpler binding without a conditional, for\n    // performance, so probably better to return both start options.\n    //\n    // Then the caller just ignores the end if it's not the first pattern,\n    // and the start always gets applied.\n    //\n    // But that's always going to be $ if it's the ending pattern, or nothing,\n    // so the caller can just attach $ at the end of the pattern when building.\n    //\n    // So the todo is:\n    // - better detect what kind of start is needed\n    // - return both flavors of starting pattern\n    // - attach $ at the end of the pattern when creating the actual RegExp\n    //\n    // Ah, but wait, no, that all only applies to the root when the first pattern\n    // is not an extglob. If the first pattern IS an extglob, then we need all\n    // that dot prevention biz to live in the extglob portions, because eg\n    // +(*|.x*) can match .xy but not .yx.\n    //\n    // So, return the two flavors if it's #root and the first child is not an\n    // AST, otherwise leave it to the child AST to handle it, and there,\n    // use the (?:^|/) style of start binding.\n    //\n    // Even simplified further:\n    // - Since the start for a join is eg /(?!\\.) and the start for a part\n    // is ^(?!\\.), we can just prepend (?!\\.) to the pattern (either root\n    // or start or whatever) and prepend ^ or / at the Regexp construction.\n    toRegExpSource(allowDot) {\n        const dot = allowDot ?? !!this.#options.dot;\n        if (this.#root === this)\n            this.#fillNegs();\n        if (!this.type) {\n            const noEmpty = this.isStart() && this.isEnd();\n            const src = this.#parts\n                .map(p => {\n                const [re, _, hasMagic, uflag] = typeof p === 'string'\n                    ? AST.#parseGlob(p, this.#hasMagic, noEmpty)\n                    : p.toRegExpSource(allowDot);\n                this.#hasMagic = this.#hasMagic || hasMagic;\n                this.#uflag = this.#uflag || uflag;\n                return re;\n            })\n                .join('');\n            let start = '';\n            if (this.isStart()) {\n                if (typeof this.#parts[0] === 'string') {\n                    // this is the string that will match the start of the pattern,\n                    // so we need to protect against dots and such.\n                    // '.' and '..' cannot match unless the pattern is that exactly,\n                    // even if it starts with . or dot:true is set.\n                    const dotTravAllowed = this.#parts.length === 1 && justDots.has(this.#parts[0]);\n                    if (!dotTravAllowed) {\n                        const aps = addPatternStart;\n                        // check if we have a possibility of matching . or ..,\n                        // and prevent that.\n                        const needNoTrav = \n                        // dots are allowed, and the pattern starts with [ or .\n                        (dot && aps.has(src.charAt(0))) ||\n                            // the pattern starts with \\., and then [ or .\n                            (src.startsWith('\\\\.') && aps.has(src.charAt(2))) ||\n                            // the pattern starts with \\.\\., and then [ or .\n                            (src.startsWith('\\\\.\\\\.') && aps.has(src.charAt(4)));\n                        // no need to prevent dots if it can't match a dot, or if a\n                        // sub-pattern will be preventing it anyway.\n                        const needNoDot = !dot && !allowDot && aps.has(src.charAt(0));\n                        start = needNoTrav ? startNoTraversal : needNoDot ? startNoDot : '';\n                    }\n                }\n            }\n            // append the \"end of path portion\" pattern to negation tails\n            let end = '';\n            if (this.isEnd() &&\n                this.#root.#filledNegs &&\n                this.#parent?.type === '!') {\n                end = '(?:$|\\\\/)';\n            }\n            const final = start + src + end;\n            return [\n                final,\n                (0, unescape_js_1.unescape)(src),\n                (this.#hasMagic = !!this.#hasMagic),\n                this.#uflag,\n            ];\n        }\n        // We need to calculate the body *twice* if it's a repeat pattern\n        // at the start, once in nodot mode, then again in dot mode, so a\n        // pattern like *(?) can match 'x.y'\n        const repeated = this.type === '*' || this.type === '+';\n        // some kind of extglob\n        const start = this.type === '!' ? '(?:(?!(?:' : '(?:';\n        let body = this.#partsToRegExp(dot);\n        if (this.isStart() && this.isEnd() && !body && this.type !== '!') {\n            // invalid extglob, has to at least be *something* present, if it's\n            // the entire path portion.\n            const s = this.toString();\n            this.#parts = [s];\n            this.type = null;\n            this.#hasMagic = undefined;\n            return [s, (0, unescape_js_1.unescape)(this.toString()), false, false];\n        }\n        // XXX abstract out this map method\n        let bodyDotAllowed = !repeated || allowDot || dot || !startNoDot\n            ? ''\n            : this.#partsToRegExp(true);\n        if (bodyDotAllowed === body) {\n            bodyDotAllowed = '';\n        }\n        if (bodyDotAllowed) {\n            body = `(?:${body})(?:${bodyDotAllowed})*?`;\n        }\n        // an empty !() is exactly equivalent to a starNoEmpty\n        let final = '';\n        if (this.type === '!' && this.#emptyExt) {\n            final = (this.isStart() && !dot ? startNoDot : '') + starNoEmpty;\n        }\n        else {\n            const close = this.type === '!'\n                ? // !() must match something,but !(x) can match ''\n                    '))' +\n                        (this.isStart() && !dot && !allowDot ? startNoDot : '') +\n                        star +\n                        ')'\n                : this.type === '@'\n                    ? ')'\n                    : this.type === '?'\n                        ? ')?'\n                        : this.type === '+' && bodyDotAllowed\n                            ? ')'\n                            : this.type === '*' && bodyDotAllowed\n                                ? `)?`\n                                : `)${this.type}`;\n            final = start + body + close;\n        }\n        return [\n            final,\n            (0, unescape_js_1.unescape)(body),\n            (this.#hasMagic = !!this.#hasMagic),\n            this.#uflag,\n        ];\n    }\n    #partsToRegExp(dot) {\n        return this.#parts\n            .map(p => {\n            // extglob ASTs should only contain parent ASTs\n            /* c8 ignore start */\n            if (typeof p === 'string') {\n                throw new Error('string type in extglob ast??');\n            }\n            /* c8 ignore stop */\n            // can ignore hasMagic, because extglobs are already always magic\n            const [re, _, _hasMagic, uflag] = p.toRegExpSource(dot);\n            this.#uflag = this.#uflag || uflag;\n            return re;\n        })\n            .filter(p => !(this.isStart() && this.isEnd()) || !!p)\n            .join('|');\n    }\n    static #parseGlob(glob, hasMagic, noEmpty = false) {\n        let escaping = false;\n        let re = '';\n        let uflag = false;\n        for (let i = 0; i < glob.length; i++) {\n            const c = glob.charAt(i);\n            if (escaping) {\n                escaping = false;\n                re += (reSpecials.has(c) ? '\\\\' : '') + c;\n                continue;\n            }\n            if (c === '\\\\') {\n                if (i === glob.length - 1) {\n                    re += '\\\\\\\\';\n                }\n                else {\n                    escaping = true;\n                }\n                continue;\n            }\n            if (c === '[') {\n                const [src, needUflag, consumed, magic] = (0, brace_expressions_js_1.parseClass)(glob, i);\n                if (consumed) {\n                    re += src;\n                    uflag = uflag || needUflag;\n                    i += consumed - 1;\n                    hasMagic = hasMagic || magic;\n                    continue;\n                }\n            }\n            if (c === '*') {\n                if (noEmpty && glob === '*')\n                    re += starNoEmpty;\n                else\n                    re += star;\n                hasMagic = true;\n                continue;\n            }\n            if (c === '?') {\n                re += qmark;\n                hasMagic = true;\n                continue;\n            }\n            re += regExpEscape(c);\n        }\n        return [re, (0, unescape_js_1.unescape)(glob), !!hasMagic, uflag];\n    }\n}\nexports.AST = AST;\n//# sourceMappingURL=ast.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGluc3RydW1lbnQpLy4vbm9kZV9tb2R1bGVzL21pbmltYXRjaC9kaXN0L2NvbW1vbmpzL2FzdC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELFdBQVc7QUFDWCwrQkFBK0IsbUJBQU8sQ0FBQyx3R0FBd0I7QUFDL0Qsc0JBQXNCLG1CQUFPLENBQUMsc0ZBQWU7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQyw4Q0FBOEM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsa0NBQWtDO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix1QkFBdUI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsR0FBRztBQUMvQztBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsS0FBSyxNQUFNLGVBQWU7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLFVBQVU7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsaUJBQWlCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYXV0by1sb29wLWRlbW8vLi9ub2RlX21vZHVsZXMvbWluaW1hdGNoL2Rpc3QvY29tbW9uanMvYXN0LmpzP2MyMWIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vLyBwYXJzZSBhIHNpbmdsZSBwYXRoIHBvcnRpb25cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQVNUID0gdm9pZCAwO1xuY29uc3QgYnJhY2VfZXhwcmVzc2lvbnNfanNfMSA9IHJlcXVpcmUoXCIuL2JyYWNlLWV4cHJlc3Npb25zLmpzXCIpO1xuY29uc3QgdW5lc2NhcGVfanNfMSA9IHJlcXVpcmUoXCIuL3VuZXNjYXBlLmpzXCIpO1xuY29uc3QgdHlwZXMgPSBuZXcgU2V0KFsnIScsICc/JywgJysnLCAnKicsICdAJ10pO1xuY29uc3QgaXNFeHRnbG9iVHlwZSA9IChjKSA9PiB0eXBlcy5oYXMoYyk7XG4vLyBQYXR0ZXJucyB0aGF0IGdldCBwcmVwZW5kZWQgdG8gYmluZCB0byB0aGUgc3RhcnQgb2YgZWl0aGVyIHRoZVxuLy8gZW50aXJlIHN0cmluZywgb3IganVzdCBhIHNpbmdsZSBwYXRoIHBvcnRpb24sIHRvIHByZXZlbnQgZG90c1xuLy8gYW5kL29yIHRyYXZlcnNhbCBwYXR0ZXJucywgd2hlbiBuZWVkZWQuXG4vLyBFeHRzIGRvbid0IG5lZWQgdGhlIF4gb3IgLyBiaXQsIGJlY2F1c2UgdGhlIHJvb3QgYmluZHMgdGhhdCBhbHJlYWR5LlxuY29uc3Qgc3RhcnROb1RyYXZlcnNhbCA9ICcoPyEoPzpefC8pXFxcXC5cXFxcLj8oPzokfC8pKSc7XG5jb25zdCBzdGFydE5vRG90ID0gJyg/IVxcXFwuKSc7XG4vLyBjaGFyYWN0ZXJzIHRoYXQgaW5kaWNhdGUgYSBzdGFydCBvZiBwYXR0ZXJuIG5lZWRzIHRoZSBcIm5vIGRvdHNcIiBiaXQsXG4vLyBiZWNhdXNlIGEgZG90ICptaWdodCogYmUgbWF0Y2hlZC4gKCBpcyBub3QgaW4gdGhlIGxpc3QsIGJlY2F1c2UgaW5cbi8vIHRoZSBjYXNlIG9mIGEgY2hpbGQgZXh0Z2xvYiwgaXQgd2lsbCBoYW5kbGUgdGhlIHByZXZlbnRpb24gaXRzZWxmLlxuY29uc3QgYWRkUGF0dGVyblN0YXJ0ID0gbmV3IFNldChbJ1snLCAnLiddKTtcbi8vIGNhc2VzIHdoZXJlIHRyYXZlcnNhbCBpcyBBLU9LLCBubyBkb3QgcHJldmVudGlvbiBuZWVkZWRcbmNvbnN0IGp1c3REb3RzID0gbmV3IFNldChbJy4uJywgJy4nXSk7XG5jb25zdCByZVNwZWNpYWxzID0gbmV3IFNldCgnKCkuKnt9Kz9bXV4kXFxcXCEnKTtcbmNvbnN0IHJlZ0V4cEVzY2FwZSA9IChzKSA9PiBzLnJlcGxhY2UoL1stW1xcXXt9KCkqKz8uLFxcXFxeJHwjXFxzXS9nLCAnXFxcXCQmJyk7XG4vLyBhbnkgc2luZ2xlIHRoaW5nIG90aGVyIHRoYW4gL1xuY29uc3QgcW1hcmsgPSAnW14vXSc7XG4vLyAqID0+IGFueSBudW1iZXIgb2YgY2hhcmFjdGVyc1xuY29uc3Qgc3RhciA9IHFtYXJrICsgJyo/Jztcbi8vIHVzZSArIHdoZW4gd2UgbmVlZCB0byBlbnN1cmUgdGhhdCAqc29tZXRoaW5nKiBtYXRjaGVzLCBiZWNhdXNlIHRoZSAqIGlzXG4vLyB0aGUgb25seSB0aGluZyBpbiB0aGUgcGF0aCBwb3J0aW9uLlxuY29uc3Qgc3Rhck5vRW1wdHkgPSBxbWFyayArICcrPyc7XG4vLyByZW1vdmUgdGhlIFxcIGNoYXJzIHRoYXQgd2UgYWRkZWQgaWYgd2UgZW5kIHVwIGRvaW5nIGEgbm9ubWFnaWMgY29tcGFyZVxuLy8gY29uc3QgZGVzbGFzaCA9IChzOiBzdHJpbmcpID0+IHMucmVwbGFjZSgvXFxcXCguKS9nLCAnJDEnKVxuY2xhc3MgQVNUIHtcbiAgICB0eXBlO1xuICAgICNyb290O1xuICAgICNoYXNNYWdpYztcbiAgICAjdWZsYWcgPSBmYWxzZTtcbiAgICAjcGFydHMgPSBbXTtcbiAgICAjcGFyZW50O1xuICAgICNwYXJlbnRJbmRleDtcbiAgICAjbmVncztcbiAgICAjZmlsbGVkTmVncyA9IGZhbHNlO1xuICAgICNvcHRpb25zO1xuICAgICN0b1N0cmluZztcbiAgICAvLyBzZXQgdG8gdHJ1ZSBpZiBpdCdzIGFuIGV4dGdsb2Igd2l0aCBubyBjaGlsZHJlblxuICAgIC8vICh3aGljaCByZWFsbHkgbWVhbnMgb25lIGNoaWxkIG9mICcnKVxuICAgICNlbXB0eUV4dCA9IGZhbHNlO1xuICAgIGNvbnN0cnVjdG9yKHR5cGUsIHBhcmVudCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgICAgIC8vIGV4dGdsb2JzIGFyZSBpbmhlcmVudGx5IG1hZ2ljYWxcbiAgICAgICAgaWYgKHR5cGUpXG4gICAgICAgICAgICB0aGlzLiNoYXNNYWdpYyA9IHRydWU7XG4gICAgICAgIHRoaXMuI3BhcmVudCA9IHBhcmVudDtcbiAgICAgICAgdGhpcy4jcm9vdCA9IHRoaXMuI3BhcmVudCA/IHRoaXMuI3BhcmVudC4jcm9vdCA6IHRoaXM7XG4gICAgICAgIHRoaXMuI29wdGlvbnMgPSB0aGlzLiNyb290ID09PSB0aGlzID8gb3B0aW9ucyA6IHRoaXMuI3Jvb3QuI29wdGlvbnM7XG4gICAgICAgIHRoaXMuI25lZ3MgPSB0aGlzLiNyb290ID09PSB0aGlzID8gW10gOiB0aGlzLiNyb290LiNuZWdzO1xuICAgICAgICBpZiAodHlwZSA9PT0gJyEnICYmICF0aGlzLiNyb290LiNmaWxsZWROZWdzKVxuICAgICAgICAgICAgdGhpcy4jbmVncy5wdXNoKHRoaXMpO1xuICAgICAgICB0aGlzLiNwYXJlbnRJbmRleCA9IHRoaXMuI3BhcmVudCA/IHRoaXMuI3BhcmVudC4jcGFydHMubGVuZ3RoIDogMDtcbiAgICB9XG4gICAgZ2V0IGhhc01hZ2ljKCkge1xuICAgICAgICAvKiBjOCBpZ25vcmUgc3RhcnQgKi9cbiAgICAgICAgaWYgKHRoaXMuI2hhc01hZ2ljICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy4jaGFzTWFnaWM7XG4gICAgICAgIC8qIGM4IGlnbm9yZSBzdG9wICovXG4gICAgICAgIGZvciAoY29uc3QgcCBvZiB0aGlzLiNwYXJ0cykge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBwID09PSAnc3RyaW5nJylcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGlmIChwLnR5cGUgfHwgcC5oYXNNYWdpYylcbiAgICAgICAgICAgICAgICByZXR1cm4gKHRoaXMuI2hhc01hZ2ljID0gdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gbm90ZTogd2lsbCBiZSB1bmRlZmluZWQgdW50aWwgd2UgZ2VuZXJhdGUgdGhlIHJlZ2V4cCBzcmMgYW5kIGZpbmQgb3V0XG4gICAgICAgIHJldHVybiB0aGlzLiNoYXNNYWdpYztcbiAgICB9XG4gICAgLy8gcmVjb25zdHJ1Y3RzIHRoZSBwYXR0ZXJuXG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIGlmICh0aGlzLiN0b1N0cmluZyAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuI3RvU3RyaW5nO1xuICAgICAgICBpZiAoIXRoaXMudHlwZSkge1xuICAgICAgICAgICAgcmV0dXJuICh0aGlzLiN0b1N0cmluZyA9IHRoaXMuI3BhcnRzLm1hcChwID0+IFN0cmluZyhwKSkuam9pbignJykpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuICh0aGlzLiN0b1N0cmluZyA9XG4gICAgICAgICAgICAgICAgdGhpcy50eXBlICsgJygnICsgdGhpcy4jcGFydHMubWFwKHAgPT4gU3RyaW5nKHApKS5qb2luKCd8JykgKyAnKScpO1xuICAgICAgICB9XG4gICAgfVxuICAgICNmaWxsTmVncygpIHtcbiAgICAgICAgLyogYzggaWdub3JlIHN0YXJ0ICovXG4gICAgICAgIGlmICh0aGlzICE9PSB0aGlzLiNyb290KVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzaG91bGQgb25seSBjYWxsIG9uIHJvb3QnKTtcbiAgICAgICAgaWYgKHRoaXMuI2ZpbGxlZE5lZ3MpXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgLyogYzggaWdub3JlIHN0b3AgKi9cbiAgICAgICAgLy8gY2FsbCB0b1N0cmluZygpIG9uY2UgdG8gZmlsbCB0aGlzIG91dFxuICAgICAgICB0aGlzLnRvU3RyaW5nKCk7XG4gICAgICAgIHRoaXMuI2ZpbGxlZE5lZ3MgPSB0cnVlO1xuICAgICAgICBsZXQgbjtcbiAgICAgICAgd2hpbGUgKChuID0gdGhpcy4jbmVncy5wb3AoKSkpIHtcbiAgICAgICAgICAgIGlmIChuLnR5cGUgIT09ICchJylcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIC8vIHdhbGsgdXAgdGhlIHRyZWUsIGFwcGVuZGluZyBldmVydGhpbmcgdGhhdCBjb21lcyBBRlRFUiBwYXJlbnRJbmRleFxuICAgICAgICAgICAgbGV0IHAgPSBuO1xuICAgICAgICAgICAgbGV0IHBwID0gcC4jcGFyZW50O1xuICAgICAgICAgICAgd2hpbGUgKHBwKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IHAuI3BhcmVudEluZGV4ICsgMTsgIXBwLnR5cGUgJiYgaSA8IHBwLiNwYXJ0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHBhcnQgb2Ygbi4jcGFydHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8qIGM4IGlnbm9yZSBzdGFydCAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBwYXJ0ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignc3RyaW5nIHBhcnQgaW4gZXh0Z2xvYiBBU1Q/PycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLyogYzggaWdub3JlIHN0b3AgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnQuY29weUluKHBwLiNwYXJ0c1tpXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcCA9IHBwO1xuICAgICAgICAgICAgICAgIHBwID0gcC4jcGFyZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBwdXNoKC4uLnBhcnRzKSB7XG4gICAgICAgIGZvciAoY29uc3QgcCBvZiBwYXJ0cykge1xuICAgICAgICAgICAgaWYgKHAgPT09ICcnKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgLyogYzggaWdub3JlIHN0YXJ0ICovXG4gICAgICAgICAgICBpZiAodHlwZW9mIHAgIT09ICdzdHJpbmcnICYmICEocCBpbnN0YW5jZW9mIEFTVCAmJiBwLiNwYXJlbnQgPT09IHRoaXMpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIHBhcnQ6ICcgKyBwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qIGM4IGlnbm9yZSBzdG9wICovXG4gICAgICAgICAgICB0aGlzLiNwYXJ0cy5wdXNoKHApO1xuICAgICAgICB9XG4gICAgfVxuICAgIHRvSlNPTigpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gdGhpcy50eXBlID09PSBudWxsXG4gICAgICAgICAgICA/IHRoaXMuI3BhcnRzLnNsaWNlKCkubWFwKHAgPT4gKHR5cGVvZiBwID09PSAnc3RyaW5nJyA/IHAgOiBwLnRvSlNPTigpKSlcbiAgICAgICAgICAgIDogW3RoaXMudHlwZSwgLi4udGhpcy4jcGFydHMubWFwKHAgPT4gcC50b0pTT04oKSldO1xuICAgICAgICBpZiAodGhpcy5pc1N0YXJ0KCkgJiYgIXRoaXMudHlwZSlcbiAgICAgICAgICAgIHJldC51bnNoaWZ0KFtdKTtcbiAgICAgICAgaWYgKHRoaXMuaXNFbmQoKSAmJlxuICAgICAgICAgICAgKHRoaXMgPT09IHRoaXMuI3Jvb3QgfHxcbiAgICAgICAgICAgICAgICAodGhpcy4jcm9vdC4jZmlsbGVkTmVncyAmJiB0aGlzLiNwYXJlbnQ/LnR5cGUgPT09ICchJykpKSB7XG4gICAgICAgICAgICByZXQucHVzaCh7fSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gICAgaXNTdGFydCgpIHtcbiAgICAgICAgaWYgKHRoaXMuI3Jvb3QgPT09IHRoaXMpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgLy8gaWYgKHRoaXMudHlwZSkgcmV0dXJuICEhdGhpcy4jcGFyZW50Py5pc1N0YXJ0KClcbiAgICAgICAgaWYgKCF0aGlzLiNwYXJlbnQ/LmlzU3RhcnQoKSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKHRoaXMuI3BhcmVudEluZGV4ID09PSAwKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIC8vIGlmIGV2ZXJ5dGhpbmcgQUhFQUQgb2YgdGhpcyBpcyBhIG5lZ2F0aW9uLCB0aGVuIGl0J3Mgc3RpbGwgdGhlIFwic3RhcnRcIlxuICAgICAgICBjb25zdCBwID0gdGhpcy4jcGFyZW50O1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuI3BhcmVudEluZGV4OyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHBwID0gcC4jcGFydHNbaV07XG4gICAgICAgICAgICBpZiAoIShwcCBpbnN0YW5jZW9mIEFTVCAmJiBwcC50eXBlID09PSAnIScpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpc0VuZCgpIHtcbiAgICAgICAgaWYgKHRoaXMuI3Jvb3QgPT09IHRoaXMpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgaWYgKHRoaXMuI3BhcmVudD8udHlwZSA9PT0gJyEnKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGlmICghdGhpcy4jcGFyZW50Py5pc0VuZCgpKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAoIXRoaXMudHlwZSlcbiAgICAgICAgICAgIHJldHVybiB0aGlzLiNwYXJlbnQ/LmlzRW5kKCk7XG4gICAgICAgIC8vIGlmIG5vdCByb290LCBpdCdsbCBhbHdheXMgaGF2ZSBhIHBhcmVudFxuICAgICAgICAvKiBjOCBpZ25vcmUgc3RhcnQgKi9cbiAgICAgICAgY29uc3QgcGwgPSB0aGlzLiNwYXJlbnQgPyB0aGlzLiNwYXJlbnQuI3BhcnRzLmxlbmd0aCA6IDA7XG4gICAgICAgIC8qIGM4IGlnbm9yZSBzdG9wICovXG4gICAgICAgIHJldHVybiB0aGlzLiNwYXJlbnRJbmRleCA9PT0gcGwgLSAxO1xuICAgIH1cbiAgICBjb3B5SW4ocGFydCkge1xuICAgICAgICBpZiAodHlwZW9mIHBhcnQgPT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgdGhpcy5wdXNoKHBhcnQpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICB0aGlzLnB1c2gocGFydC5jbG9uZSh0aGlzKSk7XG4gICAgfVxuICAgIGNsb25lKHBhcmVudCkge1xuICAgICAgICBjb25zdCBjID0gbmV3IEFTVCh0aGlzLnR5cGUsIHBhcmVudCk7XG4gICAgICAgIGZvciAoY29uc3QgcCBvZiB0aGlzLiNwYXJ0cykge1xuICAgICAgICAgICAgYy5jb3B5SW4ocCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGM7XG4gICAgfVxuICAgIHN0YXRpYyAjcGFyc2VBU1Qoc3RyLCBhc3QsIHBvcywgb3B0KSB7XG4gICAgICAgIGxldCBlc2NhcGluZyA9IGZhbHNlO1xuICAgICAgICBsZXQgaW5CcmFjZSA9IGZhbHNlO1xuICAgICAgICBsZXQgYnJhY2VTdGFydCA9IC0xO1xuICAgICAgICBsZXQgYnJhY2VOZWcgPSBmYWxzZTtcbiAgICAgICAgaWYgKGFzdC50eXBlID09PSBudWxsKSB7XG4gICAgICAgICAgICAvLyBvdXRzaWRlIG9mIGEgZXh0Z2xvYiwgYXBwZW5kIHVudGlsIHdlIGZpbmQgYSBzdGFydFxuICAgICAgICAgICAgbGV0IGkgPSBwb3M7XG4gICAgICAgICAgICBsZXQgYWNjID0gJyc7XG4gICAgICAgICAgICB3aGlsZSAoaSA8IHN0ci5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjID0gc3RyLmNoYXJBdChpKyspO1xuICAgICAgICAgICAgICAgIC8vIHN0aWxsIGFjY3VtdWxhdGUgZXNjYXBlcyBhdCB0aGlzIHBvaW50LCBidXQgd2UgZG8gaWdub3JlXG4gICAgICAgICAgICAgICAgLy8gc3RhcnRzIHRoYXQgYXJlIGVzY2FwZWRcbiAgICAgICAgICAgICAgICBpZiAoZXNjYXBpbmcgfHwgYyA9PT0gJ1xcXFwnKSB7XG4gICAgICAgICAgICAgICAgICAgIGVzY2FwaW5nID0gIWVzY2FwaW5nO1xuICAgICAgICAgICAgICAgICAgICBhY2MgKz0gYztcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpbkJyYWNlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpID09PSBicmFjZVN0YXJ0ICsgMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGMgPT09ICdeJyB8fCBjID09PSAnIScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmFjZU5lZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoYyA9PT0gJ10nICYmICEoaSA9PT0gYnJhY2VTdGFydCArIDIgJiYgYnJhY2VOZWcpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbkJyYWNlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYWNjICs9IGM7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChjID09PSAnWycpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5CcmFjZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGJyYWNlU3RhcnQgPSBpO1xuICAgICAgICAgICAgICAgICAgICBicmFjZU5lZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBhY2MgKz0gYztcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghb3B0Lm5vZXh0ICYmIGlzRXh0Z2xvYlR5cGUoYykgJiYgc3RyLmNoYXJBdChpKSA9PT0gJygnKSB7XG4gICAgICAgICAgICAgICAgICAgIGFzdC5wdXNoKGFjYyk7XG4gICAgICAgICAgICAgICAgICAgIGFjYyA9ICcnO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBleHQgPSBuZXcgQVNUKGMsIGFzdCk7XG4gICAgICAgICAgICAgICAgICAgIGkgPSBBU1QuI3BhcnNlQVNUKHN0ciwgZXh0LCBpLCBvcHQpO1xuICAgICAgICAgICAgICAgICAgICBhc3QucHVzaChleHQpO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYWNjICs9IGM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhc3QucHVzaChhY2MpO1xuICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gc29tZSBraW5kIG9mIGV4dGdsb2IsIHBvcyBpcyBhdCB0aGUgKFxuICAgICAgICAvLyBmaW5kIHRoZSBuZXh0IHwgb3IgKVxuICAgICAgICBsZXQgaSA9IHBvcyArIDE7XG4gICAgICAgIGxldCBwYXJ0ID0gbmV3IEFTVChudWxsLCBhc3QpO1xuICAgICAgICBjb25zdCBwYXJ0cyA9IFtdO1xuICAgICAgICBsZXQgYWNjID0gJyc7XG4gICAgICAgIHdoaWxlIChpIDwgc3RyLmxlbmd0aCkge1xuICAgICAgICAgICAgY29uc3QgYyA9IHN0ci5jaGFyQXQoaSsrKTtcbiAgICAgICAgICAgIC8vIHN0aWxsIGFjY3VtdWxhdGUgZXNjYXBlcyBhdCB0aGlzIHBvaW50LCBidXQgd2UgZG8gaWdub3JlXG4gICAgICAgICAgICAvLyBzdGFydHMgdGhhdCBhcmUgZXNjYXBlZFxuICAgICAgICAgICAgaWYgKGVzY2FwaW5nIHx8IGMgPT09ICdcXFxcJykge1xuICAgICAgICAgICAgICAgIGVzY2FwaW5nID0gIWVzY2FwaW5nO1xuICAgICAgICAgICAgICAgIGFjYyArPSBjO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGluQnJhY2UpIHtcbiAgICAgICAgICAgICAgICBpZiAoaSA9PT0gYnJhY2VTdGFydCArIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGMgPT09ICdeJyB8fCBjID09PSAnIScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyYWNlTmVnID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChjID09PSAnXScgJiYgIShpID09PSBicmFjZVN0YXJ0ICsgMiAmJiBicmFjZU5lZykpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5CcmFjZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhY2MgKz0gYztcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGMgPT09ICdbJykge1xuICAgICAgICAgICAgICAgIGluQnJhY2UgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGJyYWNlU3RhcnQgPSBpO1xuICAgICAgICAgICAgICAgIGJyYWNlTmVnID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgYWNjICs9IGM7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNFeHRnbG9iVHlwZShjKSAmJiBzdHIuY2hhckF0KGkpID09PSAnKCcpIHtcbiAgICAgICAgICAgICAgICBwYXJ0LnB1c2goYWNjKTtcbiAgICAgICAgICAgICAgICBhY2MgPSAnJztcbiAgICAgICAgICAgICAgICBjb25zdCBleHQgPSBuZXcgQVNUKGMsIHBhcnQpO1xuICAgICAgICAgICAgICAgIHBhcnQucHVzaChleHQpO1xuICAgICAgICAgICAgICAgIGkgPSBBU1QuI3BhcnNlQVNUKHN0ciwgZXh0LCBpLCBvcHQpO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGMgPT09ICd8Jykge1xuICAgICAgICAgICAgICAgIHBhcnQucHVzaChhY2MpO1xuICAgICAgICAgICAgICAgIGFjYyA9ICcnO1xuICAgICAgICAgICAgICAgIHBhcnRzLnB1c2gocGFydCk7XG4gICAgICAgICAgICAgICAgcGFydCA9IG5ldyBBU1QobnVsbCwgYXN0KTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjID09PSAnKScpIHtcbiAgICAgICAgICAgICAgICBpZiAoYWNjID09PSAnJyAmJiBhc3QuI3BhcnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBhc3QuI2VtcHR5RXh0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcGFydC5wdXNoKGFjYyk7XG4gICAgICAgICAgICAgICAgYWNjID0gJyc7XG4gICAgICAgICAgICAgICAgYXN0LnB1c2goLi4ucGFydHMsIHBhcnQpO1xuICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYWNjICs9IGM7XG4gICAgICAgIH1cbiAgICAgICAgLy8gdW5maW5pc2hlZCBleHRnbG9iXG4gICAgICAgIC8vIGlmIHdlIGdvdCBoZXJlLCBpdCB3YXMgYSBtYWxmb3JtZWQgZXh0Z2xvYiEgbm90IGFuIGV4dGdsb2IsIGJ1dFxuICAgICAgICAvLyBtYXliZSBzb21ldGhpbmcgZWxzZSBpbiB0aGVyZS5cbiAgICAgICAgYXN0LnR5cGUgPSBudWxsO1xuICAgICAgICBhc3QuI2hhc01hZ2ljID0gdW5kZWZpbmVkO1xuICAgICAgICBhc3QuI3BhcnRzID0gW3N0ci5zdWJzdHJpbmcocG9zIC0gMSldO1xuICAgICAgICByZXR1cm4gaTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21HbG9iKHBhdHRlcm4sIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICBjb25zdCBhc3QgPSBuZXcgQVNUKG51bGwsIHVuZGVmaW5lZCwgb3B0aW9ucyk7XG4gICAgICAgIEFTVC4jcGFyc2VBU1QocGF0dGVybiwgYXN0LCAwLCBvcHRpb25zKTtcbiAgICAgICAgcmV0dXJuIGFzdDtcbiAgICB9XG4gICAgLy8gcmV0dXJucyB0aGUgcmVndWxhciBleHByZXNzaW9uIGlmIHRoZXJlJ3MgbWFnaWMsIG9yIHRoZSB1bmVzY2FwZWRcbiAgICAvLyBzdHJpbmcgaWYgbm90LlxuICAgIHRvTU1QYXR0ZXJuKCkge1xuICAgICAgICAvLyBzaG91bGQgb25seSBiZSBjYWxsZWQgb24gcm9vdFxuICAgICAgICAvKiBjOCBpZ25vcmUgc3RhcnQgKi9cbiAgICAgICAgaWYgKHRoaXMgIT09IHRoaXMuI3Jvb3QpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy4jcm9vdC50b01NUGF0dGVybigpO1xuICAgICAgICAvKiBjOCBpZ25vcmUgc3RvcCAqL1xuICAgICAgICBjb25zdCBnbG9iID0gdGhpcy50b1N0cmluZygpO1xuICAgICAgICBjb25zdCBbcmUsIGJvZHksIGhhc01hZ2ljLCB1ZmxhZ10gPSB0aGlzLnRvUmVnRXhwU291cmNlKCk7XG4gICAgICAgIC8vIGlmIHdlJ3JlIGluIG5vY2FzZSBtb2RlLCBhbmQgbm90IG5vY2FzZU1hZ2ljT25seSwgdGhlbiB3ZSBkb1xuICAgICAgICAvLyBzdGlsbCBuZWVkIGEgcmVndWxhciBleHByZXNzaW9uIGlmIHdlIGhhdmUgdG8gY2FzZS1pbnNlbnNpdGl2ZWx5XG4gICAgICAgIC8vIG1hdGNoIGNhcGl0YWwvbG93ZXJjYXNlIGNoYXJhY3RlcnMuXG4gICAgICAgIGNvbnN0IGFueU1hZ2ljID0gaGFzTWFnaWMgfHxcbiAgICAgICAgICAgIHRoaXMuI2hhc01hZ2ljIHx8XG4gICAgICAgICAgICAodGhpcy4jb3B0aW9ucy5ub2Nhc2UgJiZcbiAgICAgICAgICAgICAgICAhdGhpcy4jb3B0aW9ucy5ub2Nhc2VNYWdpY09ubHkgJiZcbiAgICAgICAgICAgICAgICBnbG9iLnRvVXBwZXJDYXNlKCkgIT09IGdsb2IudG9Mb3dlckNhc2UoKSk7XG4gICAgICAgIGlmICghYW55TWFnaWMpIHtcbiAgICAgICAgICAgIHJldHVybiBib2R5O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGZsYWdzID0gKHRoaXMuI29wdGlvbnMubm9jYXNlID8gJ2knIDogJycpICsgKHVmbGFnID8gJ3UnIDogJycpO1xuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihuZXcgUmVnRXhwKGBeJHtyZX0kYCwgZmxhZ3MpLCB7XG4gICAgICAgICAgICBfc3JjOiByZSxcbiAgICAgICAgICAgIF9nbG9iOiBnbG9iLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0IG9wdGlvbnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiNvcHRpb25zO1xuICAgIH1cbiAgICAvLyByZXR1cm5zIHRoZSBzdHJpbmcgbWF0Y2gsIHRoZSByZWdleHAgc291cmNlLCB3aGV0aGVyIHRoZXJlJ3MgbWFnaWNcbiAgICAvLyBpbiB0aGUgcmVnZXhwIChzbyBhIHJlZ3VsYXIgZXhwcmVzc2lvbiBpcyByZXF1aXJlZCkgYW5kIHdoZXRoZXIgb3JcbiAgICAvLyBub3QgdGhlIHVmbGFnIGlzIG5lZWRlZCBmb3IgdGhlIHJlZ3VsYXIgZXhwcmVzc2lvbiAoZm9yIHBvc2l4IGNsYXNzZXMpXG4gICAgLy8gVE9ETzogaW5zdGVhZCBvZiBpbmplY3RpbmcgdGhlIHN0YXJ0L2VuZCBhdCB0aGlzIHBvaW50LCBqdXN0IHJldHVyblxuICAgIC8vIHRoZSBCT0RZIG9mIHRoZSByZWdleHAsIGFsb25nIHdpdGggdGhlIHN0YXJ0L2VuZCBwb3J0aW9ucyBzdWl0YWJsZVxuICAgIC8vIGZvciBiaW5kaW5nIHRoZSBzdGFydC9lbmQgaW4gZWl0aGVyIGEgam9pbmVkIGZ1bGwtcGF0aCBtYWtlUmUgY29udGV4dFxuICAgIC8vICh3aGVyZSB3ZSBiaW5kIHRvIChefC8pLCBvciBhIHN0YW5kYWxvbmUgbWF0Y2hQYXJ0IGNvbnRleHQgKHdoZXJlXG4gICAgLy8gd2UgYmluZCB0byBeLCBhbmQgbm90IC8pLiAgT3RoZXJ3aXNlIHNsYXNoZXMgZ2V0IGR1cGVkIVxuICAgIC8vXG4gICAgLy8gSW4gcGFydC1tYXRjaGluZyBtb2RlLCB0aGUgc3RhcnQgaXM6XG4gICAgLy8gLSBpZiBub3QgaXNTdGFydDogbm90aGluZ1xuICAgIC8vIC0gaWYgdHJhdmVyc2FsIHBvc3NpYmxlLCBidXQgbm90IGFsbG93ZWQ6IF4oPyFcXC5cXC4/JClcbiAgICAvLyAtIGlmIGRvdHMgYWxsb3dlZCBvciBub3QgcG9zc2libGU6IF5cbiAgICAvLyAtIGlmIGRvdHMgcG9zc2libGUgYW5kIG5vdCBhbGxvd2VkOiBeKD8hXFwuKVxuICAgIC8vIGVuZCBpczpcbiAgICAvLyAtIGlmIG5vdCBpc0VuZCgpOiBub3RoaW5nXG4gICAgLy8gLSBlbHNlOiAkXG4gICAgLy9cbiAgICAvLyBJbiBmdWxsLXBhdGggbWF0Y2hpbmcgbW9kZSwgd2UgcHV0IHRoZSBzbGFzaCBhdCB0aGUgU1RBUlQgb2YgdGhlXG4gICAgLy8gcGF0dGVybiwgc28gc3RhcnQgaXM6XG4gICAgLy8gLSBpZiBmaXJzdCBwYXR0ZXJuOiBzYW1lIGFzIHBhcnQtbWF0Y2hpbmcgbW9kZVxuICAgIC8vIC0gaWYgbm90IGlzU3RhcnQoKTogbm90aGluZ1xuICAgIC8vIC0gaWYgdHJhdmVyc2FsIHBvc3NpYmxlLCBidXQgbm90IGFsbG93ZWQ6IC8oPyFcXC5cXC4/KD86JHwvKSlcbiAgICAvLyAtIGlmIGRvdHMgYWxsb3dlZCBvciBub3QgcG9zc2libGU6IC9cbiAgICAvLyAtIGlmIGRvdHMgcG9zc2libGUgYW5kIG5vdCBhbGxvd2VkOiAvKD8hXFwuKVxuICAgIC8vIGVuZCBpczpcbiAgICAvLyAtIGlmIGxhc3QgcGF0dGVybiwgc2FtZSBhcyBwYXJ0LW1hdGNoaW5nIG1vZGVcbiAgICAvLyAtIGVsc2Ugbm90aGluZ1xuICAgIC8vXG4gICAgLy8gQWx3YXlzIHB1dCB0aGUgKD86JHwvKSBvbiBuZWdhdGVkIHRhaWxzLCB0aG91Z2gsIGJlY2F1c2UgdGhhdCBoYXMgdG8gYmVcbiAgICAvLyB0aGVyZSB0byBiaW5kIHRoZSBlbmQgb2YgdGhlIG5lZ2F0ZWQgcGF0dGVybiBwb3J0aW9uLCBhbmQgaXQncyBlYXNpZXIgdG9cbiAgICAvLyBqdXN0IHN0aWNrIGl0IGluIG5vdyByYXRoZXIgdGhhbiB0cnkgdG8gaW5qZWN0IGl0IGxhdGVyIGluIHRoZSBtaWRkbGUgb2ZcbiAgICAvLyB0aGUgcGF0dGVybi5cbiAgICAvL1xuICAgIC8vIFdlIGNhbiBqdXN0IGFsd2F5cyByZXR1cm4gdGhlIHNhbWUgZW5kLCBhbmQgbGVhdmUgaXQgdXAgdG8gdGhlIGNhbGxlclxuICAgIC8vIHRvIGtub3cgd2hldGhlciBpdCdzIGdvaW5nIHRvIGJlIHVzZWQgam9pbmVkIG9yIGluIHBhcnRzLlxuICAgIC8vIEFuZCwgaWYgdGhlIHN0YXJ0IGlzIGFkanVzdGVkIHNsaWdodGx5LCBjYW4gZG8gdGhlIHNhbWUgdGhlcmU6XG4gICAgLy8gLSBpZiBub3QgaXNTdGFydDogbm90aGluZ1xuICAgIC8vIC0gaWYgdHJhdmVyc2FsIHBvc3NpYmxlLCBidXQgbm90IGFsbG93ZWQ6ICg/Oi98XikoPyFcXC5cXC4/JClcbiAgICAvLyAtIGlmIGRvdHMgYWxsb3dlZCBvciBub3QgcG9zc2libGU6ICg/Oi98XilcbiAgICAvLyAtIGlmIGRvdHMgcG9zc2libGUgYW5kIG5vdCBhbGxvd2VkOiAoPzovfF4pKD8hXFwuKVxuICAgIC8vXG4gICAgLy8gQnV0IGl0J3MgYmV0dGVyIHRvIGhhdmUgYSBzaW1wbGVyIGJpbmRpbmcgd2l0aG91dCBhIGNvbmRpdGlvbmFsLCBmb3JcbiAgICAvLyBwZXJmb3JtYW5jZSwgc28gcHJvYmFibHkgYmV0dGVyIHRvIHJldHVybiBib3RoIHN0YXJ0IG9wdGlvbnMuXG4gICAgLy9cbiAgICAvLyBUaGVuIHRoZSBjYWxsZXIganVzdCBpZ25vcmVzIHRoZSBlbmQgaWYgaXQncyBub3QgdGhlIGZpcnN0IHBhdHRlcm4sXG4gICAgLy8gYW5kIHRoZSBzdGFydCBhbHdheXMgZ2V0cyBhcHBsaWVkLlxuICAgIC8vXG4gICAgLy8gQnV0IHRoYXQncyBhbHdheXMgZ29pbmcgdG8gYmUgJCBpZiBpdCdzIHRoZSBlbmRpbmcgcGF0dGVybiwgb3Igbm90aGluZyxcbiAgICAvLyBzbyB0aGUgY2FsbGVyIGNhbiBqdXN0IGF0dGFjaCAkIGF0IHRoZSBlbmQgb2YgdGhlIHBhdHRlcm4gd2hlbiBidWlsZGluZy5cbiAgICAvL1xuICAgIC8vIFNvIHRoZSB0b2RvIGlzOlxuICAgIC8vIC0gYmV0dGVyIGRldGVjdCB3aGF0IGtpbmQgb2Ygc3RhcnQgaXMgbmVlZGVkXG4gICAgLy8gLSByZXR1cm4gYm90aCBmbGF2b3JzIG9mIHN0YXJ0aW5nIHBhdHRlcm5cbiAgICAvLyAtIGF0dGFjaCAkIGF0IHRoZSBlbmQgb2YgdGhlIHBhdHRlcm4gd2hlbiBjcmVhdGluZyB0aGUgYWN0dWFsIFJlZ0V4cFxuICAgIC8vXG4gICAgLy8gQWgsIGJ1dCB3YWl0LCBubywgdGhhdCBhbGwgb25seSBhcHBsaWVzIHRvIHRoZSByb290IHdoZW4gdGhlIGZpcnN0IHBhdHRlcm5cbiAgICAvLyBpcyBub3QgYW4gZXh0Z2xvYi4gSWYgdGhlIGZpcnN0IHBhdHRlcm4gSVMgYW4gZXh0Z2xvYiwgdGhlbiB3ZSBuZWVkIGFsbFxuICAgIC8vIHRoYXQgZG90IHByZXZlbnRpb24gYml6IHRvIGxpdmUgaW4gdGhlIGV4dGdsb2IgcG9ydGlvbnMsIGJlY2F1c2UgZWdcbiAgICAvLyArKCp8LngqKSBjYW4gbWF0Y2ggLnh5IGJ1dCBub3QgLnl4LlxuICAgIC8vXG4gICAgLy8gU28sIHJldHVybiB0aGUgdHdvIGZsYXZvcnMgaWYgaXQncyAjcm9vdCBhbmQgdGhlIGZpcnN0IGNoaWxkIGlzIG5vdCBhblxuICAgIC8vIEFTVCwgb3RoZXJ3aXNlIGxlYXZlIGl0IHRvIHRoZSBjaGlsZCBBU1QgdG8gaGFuZGxlIGl0LCBhbmQgdGhlcmUsXG4gICAgLy8gdXNlIHRoZSAoPzpefC8pIHN0eWxlIG9mIHN0YXJ0IGJpbmRpbmcuXG4gICAgLy9cbiAgICAvLyBFdmVuIHNpbXBsaWZpZWQgZnVydGhlcjpcbiAgICAvLyAtIFNpbmNlIHRoZSBzdGFydCBmb3IgYSBqb2luIGlzIGVnIC8oPyFcXC4pIGFuZCB0aGUgc3RhcnQgZm9yIGEgcGFydFxuICAgIC8vIGlzIF4oPyFcXC4pLCB3ZSBjYW4ganVzdCBwcmVwZW5kICg/IVxcLikgdG8gdGhlIHBhdHRlcm4gKGVpdGhlciByb290XG4gICAgLy8gb3Igc3RhcnQgb3Igd2hhdGV2ZXIpIGFuZCBwcmVwZW5kIF4gb3IgLyBhdCB0aGUgUmVnZXhwIGNvbnN0cnVjdGlvbi5cbiAgICB0b1JlZ0V4cFNvdXJjZShhbGxvd0RvdCkge1xuICAgICAgICBjb25zdCBkb3QgPSBhbGxvd0RvdCA/PyAhIXRoaXMuI29wdGlvbnMuZG90O1xuICAgICAgICBpZiAodGhpcy4jcm9vdCA9PT0gdGhpcylcbiAgICAgICAgICAgIHRoaXMuI2ZpbGxOZWdzKCk7XG4gICAgICAgIGlmICghdGhpcy50eXBlKSB7XG4gICAgICAgICAgICBjb25zdCBub0VtcHR5ID0gdGhpcy5pc1N0YXJ0KCkgJiYgdGhpcy5pc0VuZCgpO1xuICAgICAgICAgICAgY29uc3Qgc3JjID0gdGhpcy4jcGFydHNcbiAgICAgICAgICAgICAgICAubWFwKHAgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IFtyZSwgXywgaGFzTWFnaWMsIHVmbGFnXSA9IHR5cGVvZiBwID09PSAnc3RyaW5nJ1xuICAgICAgICAgICAgICAgICAgICA/IEFTVC4jcGFyc2VHbG9iKHAsIHRoaXMuI2hhc01hZ2ljLCBub0VtcHR5KVxuICAgICAgICAgICAgICAgICAgICA6IHAudG9SZWdFeHBTb3VyY2UoYWxsb3dEb3QpO1xuICAgICAgICAgICAgICAgIHRoaXMuI2hhc01hZ2ljID0gdGhpcy4jaGFzTWFnaWMgfHwgaGFzTWFnaWM7XG4gICAgICAgICAgICAgICAgdGhpcy4jdWZsYWcgPSB0aGlzLiN1ZmxhZyB8fCB1ZmxhZztcbiAgICAgICAgICAgICAgICByZXR1cm4gcmU7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5qb2luKCcnKTtcbiAgICAgICAgICAgIGxldCBzdGFydCA9ICcnO1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNTdGFydCgpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB0aGlzLiNwYXJ0c1swXSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhpcyBpcyB0aGUgc3RyaW5nIHRoYXQgd2lsbCBtYXRjaCB0aGUgc3RhcnQgb2YgdGhlIHBhdHRlcm4sXG4gICAgICAgICAgICAgICAgICAgIC8vIHNvIHdlIG5lZWQgdG8gcHJvdGVjdCBhZ2FpbnN0IGRvdHMgYW5kIHN1Y2guXG4gICAgICAgICAgICAgICAgICAgIC8vICcuJyBhbmQgJy4uJyBjYW5ub3QgbWF0Y2ggdW5sZXNzIHRoZSBwYXR0ZXJuIGlzIHRoYXQgZXhhY3RseSxcbiAgICAgICAgICAgICAgICAgICAgLy8gZXZlbiBpZiBpdCBzdGFydHMgd2l0aCAuIG9yIGRvdDp0cnVlIGlzIHNldC5cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZG90VHJhdkFsbG93ZWQgPSB0aGlzLiNwYXJ0cy5sZW5ndGggPT09IDEgJiYganVzdERvdHMuaGFzKHRoaXMuI3BhcnRzWzBdKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFkb3RUcmF2QWxsb3dlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgYXBzID0gYWRkUGF0dGVyblN0YXJ0O1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2hlY2sgaWYgd2UgaGF2ZSBhIHBvc3NpYmlsaXR5IG9mIG1hdGNoaW5nIC4gb3IgLi4sXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBhbmQgcHJldmVudCB0aGF0LlxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbmVlZE5vVHJhdiA9IFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZG90cyBhcmUgYWxsb3dlZCwgYW5kIHRoZSBwYXR0ZXJuIHN0YXJ0cyB3aXRoIFsgb3IgLlxuICAgICAgICAgICAgICAgICAgICAgICAgKGRvdCAmJiBhcHMuaGFzKHNyYy5jaGFyQXQoMCkpKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoZSBwYXR0ZXJuIHN0YXJ0cyB3aXRoIFxcLiwgYW5kIHRoZW4gWyBvciAuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKHNyYy5zdGFydHNXaXRoKCdcXFxcLicpICYmIGFwcy5oYXMoc3JjLmNoYXJBdCgyKSkpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhlIHBhdHRlcm4gc3RhcnRzIHdpdGggXFwuXFwuLCBhbmQgdGhlbiBbIG9yIC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoc3JjLnN0YXJ0c1dpdGgoJ1xcXFwuXFxcXC4nKSAmJiBhcHMuaGFzKHNyYy5jaGFyQXQoNCkpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG5vIG5lZWQgdG8gcHJldmVudCBkb3RzIGlmIGl0IGNhbid0IG1hdGNoIGEgZG90LCBvciBpZiBhXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzdWItcGF0dGVybiB3aWxsIGJlIHByZXZlbnRpbmcgaXQgYW55d2F5LlxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbmVlZE5vRG90ID0gIWRvdCAmJiAhYWxsb3dEb3QgJiYgYXBzLmhhcyhzcmMuY2hhckF0KDApKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0ID0gbmVlZE5vVHJhdiA/IHN0YXJ0Tm9UcmF2ZXJzYWwgOiBuZWVkTm9Eb3QgPyBzdGFydE5vRG90IDogJyc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBhcHBlbmQgdGhlIFwiZW5kIG9mIHBhdGggcG9ydGlvblwiIHBhdHRlcm4gdG8gbmVnYXRpb24gdGFpbHNcbiAgICAgICAgICAgIGxldCBlbmQgPSAnJztcbiAgICAgICAgICAgIGlmICh0aGlzLmlzRW5kKCkgJiZcbiAgICAgICAgICAgICAgICB0aGlzLiNyb290LiNmaWxsZWROZWdzICYmXG4gICAgICAgICAgICAgICAgdGhpcy4jcGFyZW50Py50eXBlID09PSAnIScpIHtcbiAgICAgICAgICAgICAgICBlbmQgPSAnKD86JHxcXFxcLyknO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZmluYWwgPSBzdGFydCArIHNyYyArIGVuZDtcbiAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgZmluYWwsXG4gICAgICAgICAgICAgICAgKDAsIHVuZXNjYXBlX2pzXzEudW5lc2NhcGUpKHNyYyksXG4gICAgICAgICAgICAgICAgKHRoaXMuI2hhc01hZ2ljID0gISF0aGlzLiNoYXNNYWdpYyksXG4gICAgICAgICAgICAgICAgdGhpcy4jdWZsYWcsXG4gICAgICAgICAgICBdO1xuICAgICAgICB9XG4gICAgICAgIC8vIFdlIG5lZWQgdG8gY2FsY3VsYXRlIHRoZSBib2R5ICp0d2ljZSogaWYgaXQncyBhIHJlcGVhdCBwYXR0ZXJuXG4gICAgICAgIC8vIGF0IHRoZSBzdGFydCwgb25jZSBpbiBub2RvdCBtb2RlLCB0aGVuIGFnYWluIGluIGRvdCBtb2RlLCBzbyBhXG4gICAgICAgIC8vIHBhdHRlcm4gbGlrZSAqKD8pIGNhbiBtYXRjaCAneC55J1xuICAgICAgICBjb25zdCByZXBlYXRlZCA9IHRoaXMudHlwZSA9PT0gJyonIHx8IHRoaXMudHlwZSA9PT0gJysnO1xuICAgICAgICAvLyBzb21lIGtpbmQgb2YgZXh0Z2xvYlxuICAgICAgICBjb25zdCBzdGFydCA9IHRoaXMudHlwZSA9PT0gJyEnID8gJyg/Oig/ISg/OicgOiAnKD86JztcbiAgICAgICAgbGV0IGJvZHkgPSB0aGlzLiNwYXJ0c1RvUmVnRXhwKGRvdCk7XG4gICAgICAgIGlmICh0aGlzLmlzU3RhcnQoKSAmJiB0aGlzLmlzRW5kKCkgJiYgIWJvZHkgJiYgdGhpcy50eXBlICE9PSAnIScpIHtcbiAgICAgICAgICAgIC8vIGludmFsaWQgZXh0Z2xvYiwgaGFzIHRvIGF0IGxlYXN0IGJlICpzb21ldGhpbmcqIHByZXNlbnQsIGlmIGl0J3NcbiAgICAgICAgICAgIC8vIHRoZSBlbnRpcmUgcGF0aCBwb3J0aW9uLlxuICAgICAgICAgICAgY29uc3QgcyA9IHRoaXMudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIHRoaXMuI3BhcnRzID0gW3NdO1xuICAgICAgICAgICAgdGhpcy50eXBlID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuI2hhc01hZ2ljID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgcmV0dXJuIFtzLCAoMCwgdW5lc2NhcGVfanNfMS51bmVzY2FwZSkodGhpcy50b1N0cmluZygpKSwgZmFsc2UsIGZhbHNlXTtcbiAgICAgICAgfVxuICAgICAgICAvLyBYWFggYWJzdHJhY3Qgb3V0IHRoaXMgbWFwIG1ldGhvZFxuICAgICAgICBsZXQgYm9keURvdEFsbG93ZWQgPSAhcmVwZWF0ZWQgfHwgYWxsb3dEb3QgfHwgZG90IHx8ICFzdGFydE5vRG90XG4gICAgICAgICAgICA/ICcnXG4gICAgICAgICAgICA6IHRoaXMuI3BhcnRzVG9SZWdFeHAodHJ1ZSk7XG4gICAgICAgIGlmIChib2R5RG90QWxsb3dlZCA9PT0gYm9keSkge1xuICAgICAgICAgICAgYm9keURvdEFsbG93ZWQgPSAnJztcbiAgICAgICAgfVxuICAgICAgICBpZiAoYm9keURvdEFsbG93ZWQpIHtcbiAgICAgICAgICAgIGJvZHkgPSBgKD86JHtib2R5fSkoPzoke2JvZHlEb3RBbGxvd2VkfSkqP2A7XG4gICAgICAgIH1cbiAgICAgICAgLy8gYW4gZW1wdHkgISgpIGlzIGV4YWN0bHkgZXF1aXZhbGVudCB0byBhIHN0YXJOb0VtcHR5XG4gICAgICAgIGxldCBmaW5hbCA9ICcnO1xuICAgICAgICBpZiAodGhpcy50eXBlID09PSAnIScgJiYgdGhpcy4jZW1wdHlFeHQpIHtcbiAgICAgICAgICAgIGZpbmFsID0gKHRoaXMuaXNTdGFydCgpICYmICFkb3QgPyBzdGFydE5vRG90IDogJycpICsgc3Rhck5vRW1wdHk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBjbG9zZSA9IHRoaXMudHlwZSA9PT0gJyEnXG4gICAgICAgICAgICAgICAgPyAvLyAhKCkgbXVzdCBtYXRjaCBzb21ldGhpbmcsYnV0ICEoeCkgY2FuIG1hdGNoICcnXG4gICAgICAgICAgICAgICAgICAgICcpKScgK1xuICAgICAgICAgICAgICAgICAgICAgICAgKHRoaXMuaXNTdGFydCgpICYmICFkb3QgJiYgIWFsbG93RG90ID8gc3RhcnROb0RvdCA6ICcnKSArXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFyICtcbiAgICAgICAgICAgICAgICAgICAgICAgICcpJ1xuICAgICAgICAgICAgICAgIDogdGhpcy50eXBlID09PSAnQCdcbiAgICAgICAgICAgICAgICAgICAgPyAnKSdcbiAgICAgICAgICAgICAgICAgICAgOiB0aGlzLnR5cGUgPT09ICc/J1xuICAgICAgICAgICAgICAgICAgICAgICAgPyAnKT8nXG4gICAgICAgICAgICAgICAgICAgICAgICA6IHRoaXMudHlwZSA9PT0gJysnICYmIGJvZHlEb3RBbGxvd2VkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyAnKSdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHRoaXMudHlwZSA9PT0gJyonICYmIGJvZHlEb3RBbGxvd2VkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gYCk/YFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IGApJHt0aGlzLnR5cGV9YDtcbiAgICAgICAgICAgIGZpbmFsID0gc3RhcnQgKyBib2R5ICsgY2xvc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIGZpbmFsLFxuICAgICAgICAgICAgKDAsIHVuZXNjYXBlX2pzXzEudW5lc2NhcGUpKGJvZHkpLFxuICAgICAgICAgICAgKHRoaXMuI2hhc01hZ2ljID0gISF0aGlzLiNoYXNNYWdpYyksXG4gICAgICAgICAgICB0aGlzLiN1ZmxhZyxcbiAgICAgICAgXTtcbiAgICB9XG4gICAgI3BhcnRzVG9SZWdFeHAoZG90KSB7XG4gICAgICAgIHJldHVybiB0aGlzLiNwYXJ0c1xuICAgICAgICAgICAgLm1hcChwID0+IHtcbiAgICAgICAgICAgIC8vIGV4dGdsb2IgQVNUcyBzaG91bGQgb25seSBjb250YWluIHBhcmVudCBBU1RzXG4gICAgICAgICAgICAvKiBjOCBpZ25vcmUgc3RhcnQgKi9cbiAgICAgICAgICAgIGlmICh0eXBlb2YgcCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3N0cmluZyB0eXBlIGluIGV4dGdsb2IgYXN0Pz8nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qIGM4IGlnbm9yZSBzdG9wICovXG4gICAgICAgICAgICAvLyBjYW4gaWdub3JlIGhhc01hZ2ljLCBiZWNhdXNlIGV4dGdsb2JzIGFyZSBhbHJlYWR5IGFsd2F5cyBtYWdpY1xuICAgICAgICAgICAgY29uc3QgW3JlLCBfLCBfaGFzTWFnaWMsIHVmbGFnXSA9IHAudG9SZWdFeHBTb3VyY2UoZG90KTtcbiAgICAgICAgICAgIHRoaXMuI3VmbGFnID0gdGhpcy4jdWZsYWcgfHwgdWZsYWc7XG4gICAgICAgICAgICByZXR1cm4gcmU7XG4gICAgICAgIH0pXG4gICAgICAgICAgICAuZmlsdGVyKHAgPT4gISh0aGlzLmlzU3RhcnQoKSAmJiB0aGlzLmlzRW5kKCkpIHx8ICEhcClcbiAgICAgICAgICAgIC5qb2luKCd8Jyk7XG4gICAgfVxuICAgIHN0YXRpYyAjcGFyc2VHbG9iKGdsb2IsIGhhc01hZ2ljLCBub0VtcHR5ID0gZmFsc2UpIHtcbiAgICAgICAgbGV0IGVzY2FwaW5nID0gZmFsc2U7XG4gICAgICAgIGxldCByZSA9ICcnO1xuICAgICAgICBsZXQgdWZsYWcgPSBmYWxzZTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBnbG9iLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBjID0gZ2xvYi5jaGFyQXQoaSk7XG4gICAgICAgICAgICBpZiAoZXNjYXBpbmcpIHtcbiAgICAgICAgICAgICAgICBlc2NhcGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHJlICs9IChyZVNwZWNpYWxzLmhhcyhjKSA/ICdcXFxcJyA6ICcnKSArIGM7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYyA9PT0gJ1xcXFwnKSB7XG4gICAgICAgICAgICAgICAgaWYgKGkgPT09IGdsb2IubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgICAgICByZSArPSAnXFxcXFxcXFwnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZXNjYXBpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjID09PSAnWycpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBbc3JjLCBuZWVkVWZsYWcsIGNvbnN1bWVkLCBtYWdpY10gPSAoMCwgYnJhY2VfZXhwcmVzc2lvbnNfanNfMS5wYXJzZUNsYXNzKShnbG9iLCBpKTtcbiAgICAgICAgICAgICAgICBpZiAoY29uc3VtZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmUgKz0gc3JjO1xuICAgICAgICAgICAgICAgICAgICB1ZmxhZyA9IHVmbGFnIHx8IG5lZWRVZmxhZztcbiAgICAgICAgICAgICAgICAgICAgaSArPSBjb25zdW1lZCAtIDE7XG4gICAgICAgICAgICAgICAgICAgIGhhc01hZ2ljID0gaGFzTWFnaWMgfHwgbWFnaWM7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjID09PSAnKicpIHtcbiAgICAgICAgICAgICAgICBpZiAobm9FbXB0eSAmJiBnbG9iID09PSAnKicpXG4gICAgICAgICAgICAgICAgICAgIHJlICs9IHN0YXJOb0VtcHR5O1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgcmUgKz0gc3RhcjtcbiAgICAgICAgICAgICAgICBoYXNNYWdpYyA9IHRydWU7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYyA9PT0gJz8nKSB7XG4gICAgICAgICAgICAgICAgcmUgKz0gcW1hcms7XG4gICAgICAgICAgICAgICAgaGFzTWFnaWMgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmUgKz0gcmVnRXhwRXNjYXBlKGMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbcmUsICgwLCB1bmVzY2FwZV9qc18xLnVuZXNjYXBlKShnbG9iKSwgISFoYXNNYWdpYywgdWZsYWddO1xuICAgIH1cbn1cbmV4cG9ydHMuQVNUID0gQVNUO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXN0LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(instrument)/./node_modules/minimatch/dist/commonjs/ast.js\n");

/***/ }),

/***/ "(instrument)/./node_modules/minimatch/dist/commonjs/brace-expressions.js":
/*!*******************************************************************!*\
  !*** ./node_modules/minimatch/dist/commonjs/brace-expressions.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n// translate the various posix character classes into unicode properties\n// this works across all unicode locales\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.parseClass = void 0;\n// { <posix class>: [<translation>, /u flag required, negated]\nconst posixClasses = {\n    '[:alnum:]': ['\\\\p{L}\\\\p{Nl}\\\\p{Nd}', true],\n    '[:alpha:]': ['\\\\p{L}\\\\p{Nl}', true],\n    '[:ascii:]': ['\\\\x' + '00-\\\\x' + '7f', false],\n    '[:blank:]': ['\\\\p{Zs}\\\\t', true],\n    '[:cntrl:]': ['\\\\p{Cc}', true],\n    '[:digit:]': ['\\\\p{Nd}', true],\n    '[:graph:]': ['\\\\p{Z}\\\\p{C}', true, true],\n    '[:lower:]': ['\\\\p{Ll}', true],\n    '[:print:]': ['\\\\p{C}', true],\n    '[:punct:]': ['\\\\p{P}', true],\n    '[:space:]': ['\\\\p{Z}\\\\t\\\\r\\\\n\\\\v\\\\f', true],\n    '[:upper:]': ['\\\\p{Lu}', true],\n    '[:word:]': ['\\\\p{L}\\\\p{Nl}\\\\p{Nd}\\\\p{Pc}', true],\n    '[:xdigit:]': ['A-Fa-f0-9', false],\n};\n// only need to escape a few things inside of brace expressions\n// escapes: [ \\ ] -\nconst braceEscape = (s) => s.replace(/[[\\]\\\\-]/g, '\\\\$&');\n// escape all regexp magic characters\nconst regexpEscape = (s) => s.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, '\\\\$&');\n// everything has already been escaped, we just have to join\nconst rangesToString = (ranges) => ranges.join('');\n// takes a glob string at a posix brace expression, and returns\n// an equivalent regular expression source, and boolean indicating\n// whether the /u flag needs to be applied, and the number of chars\n// consumed to parse the character class.\n// This also removes out of order ranges, and returns ($.) if the\n// entire class just no good.\nconst parseClass = (glob, position) => {\n    const pos = position;\n    /* c8 ignore start */\n    if (glob.charAt(pos) !== '[') {\n        throw new Error('not in a brace expression');\n    }\n    /* c8 ignore stop */\n    const ranges = [];\n    const negs = [];\n    let i = pos + 1;\n    let sawStart = false;\n    let uflag = false;\n    let escaping = false;\n    let negate = false;\n    let endPos = pos;\n    let rangeStart = '';\n    WHILE: while (i < glob.length) {\n        const c = glob.charAt(i);\n        if ((c === '!' || c === '^') && i === pos + 1) {\n            negate = true;\n            i++;\n            continue;\n        }\n        if (c === ']' && sawStart && !escaping) {\n            endPos = i + 1;\n            break;\n        }\n        sawStart = true;\n        if (c === '\\\\') {\n            if (!escaping) {\n                escaping = true;\n                i++;\n                continue;\n            }\n            // escaped \\ char, fall through and treat like normal char\n        }\n        if (c === '[' && !escaping) {\n            // either a posix class, a collation equivalent, or just a [\n            for (const [cls, [unip, u, neg]] of Object.entries(posixClasses)) {\n                if (glob.startsWith(cls, i)) {\n                    // invalid, [a-[] is fine, but not [a-[:alpha]]\n                    if (rangeStart) {\n                        return ['$.', false, glob.length - pos, true];\n                    }\n                    i += cls.length;\n                    if (neg)\n                        negs.push(unip);\n                    else\n                        ranges.push(unip);\n                    uflag = uflag || u;\n                    continue WHILE;\n                }\n            }\n        }\n        // now it's just a normal character, effectively\n        escaping = false;\n        if (rangeStart) {\n            // throw this range away if it's not valid, but others\n            // can still match.\n            if (c > rangeStart) {\n                ranges.push(braceEscape(rangeStart) + '-' + braceEscape(c));\n            }\n            else if (c === rangeStart) {\n                ranges.push(braceEscape(c));\n            }\n            rangeStart = '';\n            i++;\n            continue;\n        }\n        // now might be the start of a range.\n        // can be either c-d or c-] or c<more...>] or c] at this point\n        if (glob.startsWith('-]', i + 1)) {\n            ranges.push(braceEscape(c + '-'));\n            i += 2;\n            continue;\n        }\n        if (glob.startsWith('-', i + 1)) {\n            rangeStart = c;\n            i += 2;\n            continue;\n        }\n        // not the start of a range, just a single character\n        ranges.push(braceEscape(c));\n        i++;\n    }\n    if (endPos < i) {\n        // didn't see the end of the class, not a valid class,\n        // but might still be valid as a literal match.\n        return ['', false, 0, false];\n    }\n    // if we got no ranges and no negates, then we have a range that\n    // cannot possibly match anything, and that poisons the whole glob\n    if (!ranges.length && !negs.length) {\n        return ['$.', false, glob.length - pos, true];\n    }\n    // if we got one positive range, and it's a single character, then that's\n    // not actually a magic pattern, it's just that one literal character.\n    // we should not treat that as \"magic\", we should just return the literal\n    // character. [_] is a perfectly valid way to escape glob magic chars.\n    if (negs.length === 0 &&\n        ranges.length === 1 &&\n        /^\\\\?.$/.test(ranges[0]) &&\n        !negate) {\n        const r = ranges[0].length === 2 ? ranges[0].slice(-1) : ranges[0];\n        return [regexpEscape(r), false, endPos - pos, false];\n    }\n    const sranges = '[' + (negate ? '^' : '') + rangesToString(ranges) + ']';\n    const snegs = '[' + (negate ? '' : '^') + rangesToString(negs) + ']';\n    const comb = ranges.length && negs.length\n        ? '(' + sranges + '|' + snegs + ')'\n        : ranges.length\n            ? sranges\n            : snegs;\n    return [comb, uflag, endPos - pos, true];\n};\nexports.parseClass = parseClass;\n//# sourceMappingURL=brace-expressions.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGluc3RydW1lbnQpLy4vbm9kZV9tb2R1bGVzL21pbmltYXRjaC9kaXN0L2NvbW1vbmpzL2JyYWNlLWV4cHJlc3Npb25zLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxrQkFBa0I7QUFDbEIsS0FBSztBQUNMO0FBQ0EsdUJBQXVCLEVBQUUsSUFBSSxHQUFHLElBQUksR0FBRztBQUN2Qyx1QkFBdUIsRUFBRSxJQUFJLEdBQUc7QUFDaEM7QUFDQSx1QkFBdUIsR0FBRztBQUMxQix1QkFBdUIsR0FBRztBQUMxQix1QkFBdUIsR0FBRztBQUMxQix1QkFBdUIsRUFBRSxJQUFJLEVBQUU7QUFDL0IsdUJBQXVCLEdBQUc7QUFDMUIsdUJBQXVCLEVBQUU7QUFDekIsdUJBQXVCLEVBQUU7QUFDekIsdUJBQXVCLEVBQUU7QUFDekIsdUJBQXVCLEdBQUc7QUFDMUIsc0JBQXNCLEVBQUUsSUFBSSxHQUFHLElBQUksR0FBRyxJQUFJLEdBQUc7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQiIsInNvdXJjZXMiOlsid2VicGFjazovL2F1dG8tbG9vcC1kZW1vLy4vbm9kZV9tb2R1bGVzL21pbmltYXRjaC9kaXN0L2NvbW1vbmpzL2JyYWNlLWV4cHJlc3Npb25zLmpzPzg5NDQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vLyB0cmFuc2xhdGUgdGhlIHZhcmlvdXMgcG9zaXggY2hhcmFjdGVyIGNsYXNzZXMgaW50byB1bmljb2RlIHByb3BlcnRpZXNcbi8vIHRoaXMgd29ya3MgYWNyb3NzIGFsbCB1bmljb2RlIGxvY2FsZXNcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMucGFyc2VDbGFzcyA9IHZvaWQgMDtcbi8vIHsgPHBvc2l4IGNsYXNzPjogWzx0cmFuc2xhdGlvbj4sIC91IGZsYWcgcmVxdWlyZWQsIG5lZ2F0ZWRdXG5jb25zdCBwb3NpeENsYXNzZXMgPSB7XG4gICAgJ1s6YWxudW06XSc6IFsnXFxcXHB7TH1cXFxccHtObH1cXFxccHtOZH0nLCB0cnVlXSxcbiAgICAnWzphbHBoYTpdJzogWydcXFxccHtMfVxcXFxwe05sfScsIHRydWVdLFxuICAgICdbOmFzY2lpOl0nOiBbJ1xcXFx4JyArICcwMC1cXFxceCcgKyAnN2YnLCBmYWxzZV0sXG4gICAgJ1s6Ymxhbms6XSc6IFsnXFxcXHB7WnN9XFxcXHQnLCB0cnVlXSxcbiAgICAnWzpjbnRybDpdJzogWydcXFxccHtDY30nLCB0cnVlXSxcbiAgICAnWzpkaWdpdDpdJzogWydcXFxccHtOZH0nLCB0cnVlXSxcbiAgICAnWzpncmFwaDpdJzogWydcXFxccHtafVxcXFxwe0N9JywgdHJ1ZSwgdHJ1ZV0sXG4gICAgJ1s6bG93ZXI6XSc6IFsnXFxcXHB7TGx9JywgdHJ1ZV0sXG4gICAgJ1s6cHJpbnQ6XSc6IFsnXFxcXHB7Q30nLCB0cnVlXSxcbiAgICAnWzpwdW5jdDpdJzogWydcXFxccHtQfScsIHRydWVdLFxuICAgICdbOnNwYWNlOl0nOiBbJ1xcXFxwe1p9XFxcXHRcXFxcclxcXFxuXFxcXHZcXFxcZicsIHRydWVdLFxuICAgICdbOnVwcGVyOl0nOiBbJ1xcXFxwe0x1fScsIHRydWVdLFxuICAgICdbOndvcmQ6XSc6IFsnXFxcXHB7TH1cXFxccHtObH1cXFxccHtOZH1cXFxccHtQY30nLCB0cnVlXSxcbiAgICAnWzp4ZGlnaXQ6XSc6IFsnQS1GYS1mMC05JywgZmFsc2VdLFxufTtcbi8vIG9ubHkgbmVlZCB0byBlc2NhcGUgYSBmZXcgdGhpbmdzIGluc2lkZSBvZiBicmFjZSBleHByZXNzaW9uc1xuLy8gZXNjYXBlczogWyBcXCBdIC1cbmNvbnN0IGJyYWNlRXNjYXBlID0gKHMpID0+IHMucmVwbGFjZSgvW1tcXF1cXFxcLV0vZywgJ1xcXFwkJicpO1xuLy8gZXNjYXBlIGFsbCByZWdleHAgbWFnaWMgY2hhcmFjdGVyc1xuY29uc3QgcmVnZXhwRXNjYXBlID0gKHMpID0+IHMucmVwbGFjZSgvWy1bXFxde30oKSorPy4sXFxcXF4kfCNcXHNdL2csICdcXFxcJCYnKTtcbi8vIGV2ZXJ5dGhpbmcgaGFzIGFscmVhZHkgYmVlbiBlc2NhcGVkLCB3ZSBqdXN0IGhhdmUgdG8gam9pblxuY29uc3QgcmFuZ2VzVG9TdHJpbmcgPSAocmFuZ2VzKSA9PiByYW5nZXMuam9pbignJyk7XG4vLyB0YWtlcyBhIGdsb2Igc3RyaW5nIGF0IGEgcG9zaXggYnJhY2UgZXhwcmVzc2lvbiwgYW5kIHJldHVybnNcbi8vIGFuIGVxdWl2YWxlbnQgcmVndWxhciBleHByZXNzaW9uIHNvdXJjZSwgYW5kIGJvb2xlYW4gaW5kaWNhdGluZ1xuLy8gd2hldGhlciB0aGUgL3UgZmxhZyBuZWVkcyB0byBiZSBhcHBsaWVkLCBhbmQgdGhlIG51bWJlciBvZiBjaGFyc1xuLy8gY29uc3VtZWQgdG8gcGFyc2UgdGhlIGNoYXJhY3RlciBjbGFzcy5cbi8vIFRoaXMgYWxzbyByZW1vdmVzIG91dCBvZiBvcmRlciByYW5nZXMsIGFuZCByZXR1cm5zICgkLikgaWYgdGhlXG4vLyBlbnRpcmUgY2xhc3MganVzdCBubyBnb29kLlxuY29uc3QgcGFyc2VDbGFzcyA9IChnbG9iLCBwb3NpdGlvbikgPT4ge1xuICAgIGNvbnN0IHBvcyA9IHBvc2l0aW9uO1xuICAgIC8qIGM4IGlnbm9yZSBzdGFydCAqL1xuICAgIGlmIChnbG9iLmNoYXJBdChwb3MpICE9PSAnWycpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdub3QgaW4gYSBicmFjZSBleHByZXNzaW9uJyk7XG4gICAgfVxuICAgIC8qIGM4IGlnbm9yZSBzdG9wICovXG4gICAgY29uc3QgcmFuZ2VzID0gW107XG4gICAgY29uc3QgbmVncyA9IFtdO1xuICAgIGxldCBpID0gcG9zICsgMTtcbiAgICBsZXQgc2F3U3RhcnQgPSBmYWxzZTtcbiAgICBsZXQgdWZsYWcgPSBmYWxzZTtcbiAgICBsZXQgZXNjYXBpbmcgPSBmYWxzZTtcbiAgICBsZXQgbmVnYXRlID0gZmFsc2U7XG4gICAgbGV0IGVuZFBvcyA9IHBvcztcbiAgICBsZXQgcmFuZ2VTdGFydCA9ICcnO1xuICAgIFdISUxFOiB3aGlsZSAoaSA8IGdsb2IubGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IGMgPSBnbG9iLmNoYXJBdChpKTtcbiAgICAgICAgaWYgKChjID09PSAnIScgfHwgYyA9PT0gJ14nKSAmJiBpID09PSBwb3MgKyAxKSB7XG4gICAgICAgICAgICBuZWdhdGUgPSB0cnVlO1xuICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGMgPT09ICddJyAmJiBzYXdTdGFydCAmJiAhZXNjYXBpbmcpIHtcbiAgICAgICAgICAgIGVuZFBvcyA9IGkgKyAxO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgc2F3U3RhcnQgPSB0cnVlO1xuICAgICAgICBpZiAoYyA9PT0gJ1xcXFwnKSB7XG4gICAgICAgICAgICBpZiAoIWVzY2FwaW5nKSB7XG4gICAgICAgICAgICAgICAgZXNjYXBpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGVzY2FwZWQgXFwgY2hhciwgZmFsbCB0aHJvdWdoIGFuZCB0cmVhdCBsaWtlIG5vcm1hbCBjaGFyXG4gICAgICAgIH1cbiAgICAgICAgaWYgKGMgPT09ICdbJyAmJiAhZXNjYXBpbmcpIHtcbiAgICAgICAgICAgIC8vIGVpdGhlciBhIHBvc2l4IGNsYXNzLCBhIGNvbGxhdGlvbiBlcXVpdmFsZW50LCBvciBqdXN0IGEgW1xuICAgICAgICAgICAgZm9yIChjb25zdCBbY2xzLCBbdW5pcCwgdSwgbmVnXV0gb2YgT2JqZWN0LmVudHJpZXMocG9zaXhDbGFzc2VzKSkge1xuICAgICAgICAgICAgICAgIGlmIChnbG9iLnN0YXJ0c1dpdGgoY2xzLCBpKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBpbnZhbGlkLCBbYS1bXSBpcyBmaW5lLCBidXQgbm90IFthLVs6YWxwaGFdXVxuICAgICAgICAgICAgICAgICAgICBpZiAocmFuZ2VTdGFydCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsnJC4nLCBmYWxzZSwgZ2xvYi5sZW5ndGggLSBwb3MsIHRydWVdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGkgKz0gY2xzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5lZylcbiAgICAgICAgICAgICAgICAgICAgICAgIG5lZ3MucHVzaCh1bmlwKTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgcmFuZ2VzLnB1c2godW5pcCk7XG4gICAgICAgICAgICAgICAgICAgIHVmbGFnID0gdWZsYWcgfHwgdTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWUgV0hJTEU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIG5vdyBpdCdzIGp1c3QgYSBub3JtYWwgY2hhcmFjdGVyLCBlZmZlY3RpdmVseVxuICAgICAgICBlc2NhcGluZyA9IGZhbHNlO1xuICAgICAgICBpZiAocmFuZ2VTdGFydCkge1xuICAgICAgICAgICAgLy8gdGhyb3cgdGhpcyByYW5nZSBhd2F5IGlmIGl0J3Mgbm90IHZhbGlkLCBidXQgb3RoZXJzXG4gICAgICAgICAgICAvLyBjYW4gc3RpbGwgbWF0Y2guXG4gICAgICAgICAgICBpZiAoYyA+IHJhbmdlU3RhcnQpIHtcbiAgICAgICAgICAgICAgICByYW5nZXMucHVzaChicmFjZUVzY2FwZShyYW5nZVN0YXJ0KSArICctJyArIGJyYWNlRXNjYXBlKGMpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGMgPT09IHJhbmdlU3RhcnQpIHtcbiAgICAgICAgICAgICAgICByYW5nZXMucHVzaChicmFjZUVzY2FwZShjKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByYW5nZVN0YXJ0ID0gJyc7XG4gICAgICAgICAgICBpKys7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBub3cgbWlnaHQgYmUgdGhlIHN0YXJ0IG9mIGEgcmFuZ2UuXG4gICAgICAgIC8vIGNhbiBiZSBlaXRoZXIgYy1kIG9yIGMtXSBvciBjPG1vcmUuLi4+XSBvciBjXSBhdCB0aGlzIHBvaW50XG4gICAgICAgIGlmIChnbG9iLnN0YXJ0c1dpdGgoJy1dJywgaSArIDEpKSB7XG4gICAgICAgICAgICByYW5nZXMucHVzaChicmFjZUVzY2FwZShjICsgJy0nKSk7XG4gICAgICAgICAgICBpICs9IDI7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZ2xvYi5zdGFydHNXaXRoKCctJywgaSArIDEpKSB7XG4gICAgICAgICAgICByYW5nZVN0YXJ0ID0gYztcbiAgICAgICAgICAgIGkgKz0gMjtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIG5vdCB0aGUgc3RhcnQgb2YgYSByYW5nZSwganVzdCBhIHNpbmdsZSBjaGFyYWN0ZXJcbiAgICAgICAgcmFuZ2VzLnB1c2goYnJhY2VFc2NhcGUoYykpO1xuICAgICAgICBpKys7XG4gICAgfVxuICAgIGlmIChlbmRQb3MgPCBpKSB7XG4gICAgICAgIC8vIGRpZG4ndCBzZWUgdGhlIGVuZCBvZiB0aGUgY2xhc3MsIG5vdCBhIHZhbGlkIGNsYXNzLFxuICAgICAgICAvLyBidXQgbWlnaHQgc3RpbGwgYmUgdmFsaWQgYXMgYSBsaXRlcmFsIG1hdGNoLlxuICAgICAgICByZXR1cm4gWycnLCBmYWxzZSwgMCwgZmFsc2VdO1xuICAgIH1cbiAgICAvLyBpZiB3ZSBnb3Qgbm8gcmFuZ2VzIGFuZCBubyBuZWdhdGVzLCB0aGVuIHdlIGhhdmUgYSByYW5nZSB0aGF0XG4gICAgLy8gY2Fubm90IHBvc3NpYmx5IG1hdGNoIGFueXRoaW5nLCBhbmQgdGhhdCBwb2lzb25zIHRoZSB3aG9sZSBnbG9iXG4gICAgaWYgKCFyYW5nZXMubGVuZ3RoICYmICFuZWdzLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gWyckLicsIGZhbHNlLCBnbG9iLmxlbmd0aCAtIHBvcywgdHJ1ZV07XG4gICAgfVxuICAgIC8vIGlmIHdlIGdvdCBvbmUgcG9zaXRpdmUgcmFuZ2UsIGFuZCBpdCdzIGEgc2luZ2xlIGNoYXJhY3RlciwgdGhlbiB0aGF0J3NcbiAgICAvLyBub3QgYWN0dWFsbHkgYSBtYWdpYyBwYXR0ZXJuLCBpdCdzIGp1c3QgdGhhdCBvbmUgbGl0ZXJhbCBjaGFyYWN0ZXIuXG4gICAgLy8gd2Ugc2hvdWxkIG5vdCB0cmVhdCB0aGF0IGFzIFwibWFnaWNcIiwgd2Ugc2hvdWxkIGp1c3QgcmV0dXJuIHRoZSBsaXRlcmFsXG4gICAgLy8gY2hhcmFjdGVyLiBbX10gaXMgYSBwZXJmZWN0bHkgdmFsaWQgd2F5IHRvIGVzY2FwZSBnbG9iIG1hZ2ljIGNoYXJzLlxuICAgIGlmIChuZWdzLmxlbmd0aCA9PT0gMCAmJlxuICAgICAgICByYW5nZXMubGVuZ3RoID09PSAxICYmXG4gICAgICAgIC9eXFxcXD8uJC8udGVzdChyYW5nZXNbMF0pICYmXG4gICAgICAgICFuZWdhdGUpIHtcbiAgICAgICAgY29uc3QgciA9IHJhbmdlc1swXS5sZW5ndGggPT09IDIgPyByYW5nZXNbMF0uc2xpY2UoLTEpIDogcmFuZ2VzWzBdO1xuICAgICAgICByZXR1cm4gW3JlZ2V4cEVzY2FwZShyKSwgZmFsc2UsIGVuZFBvcyAtIHBvcywgZmFsc2VdO1xuICAgIH1cbiAgICBjb25zdCBzcmFuZ2VzID0gJ1snICsgKG5lZ2F0ZSA/ICdeJyA6ICcnKSArIHJhbmdlc1RvU3RyaW5nKHJhbmdlcykgKyAnXSc7XG4gICAgY29uc3Qgc25lZ3MgPSAnWycgKyAobmVnYXRlID8gJycgOiAnXicpICsgcmFuZ2VzVG9TdHJpbmcobmVncykgKyAnXSc7XG4gICAgY29uc3QgY29tYiA9IHJhbmdlcy5sZW5ndGggJiYgbmVncy5sZW5ndGhcbiAgICAgICAgPyAnKCcgKyBzcmFuZ2VzICsgJ3wnICsgc25lZ3MgKyAnKSdcbiAgICAgICAgOiByYW5nZXMubGVuZ3RoXG4gICAgICAgICAgICA/IHNyYW5nZXNcbiAgICAgICAgICAgIDogc25lZ3M7XG4gICAgcmV0dXJuIFtjb21iLCB1ZmxhZywgZW5kUG9zIC0gcG9zLCB0cnVlXTtcbn07XG5leHBvcnRzLnBhcnNlQ2xhc3MgPSBwYXJzZUNsYXNzO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YnJhY2UtZXhwcmVzc2lvbnMuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(instrument)/./node_modules/minimatch/dist/commonjs/brace-expressions.js\n");

/***/ }),

/***/ "(instrument)/./node_modules/minimatch/dist/commonjs/escape.js":
/*!********************************************************!*\
  !*** ./node_modules/minimatch/dist/commonjs/escape.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.escape = void 0;\n/**\n * Escape all magic characters in a glob pattern.\n *\n * If the {@link windowsPathsNoEscape | GlobOptions.windowsPathsNoEscape}\n * option is used, then characters are escaped by wrapping in `[]`, because\n * a magic character wrapped in a character class can only be satisfied by\n * that exact character.  In this mode, `\\` is _not_ escaped, because it is\n * not interpreted as a magic character, but instead as a path separator.\n */\nconst escape = (s, { windowsPathsNoEscape = false, } = {}) => {\n    // don't need to escape +@! because we escape the parens\n    // that make those magic, and escaping ! as [!] isn't valid,\n    // because [!]] is a valid glob class meaning not ']'.\n    return windowsPathsNoEscape\n        ? s.replace(/[?*()[\\]]/g, '[$&]')\n        : s.replace(/[?*()[\\]\\\\]/g, '\\\\$&');\n};\nexports.escape = escape;\n//# sourceMappingURL=escape.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGluc3RydW1lbnQpLy4vbm9kZV9tb2R1bGVzL21pbmltYXRjaC9kaXN0L2NvbW1vbmpzL2VzY2FwZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsZ0NBQWdDLElBQUk7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hdXRvLWxvb3AtZGVtby8uL25vZGVfbW9kdWxlcy9taW5pbWF0Y2gvZGlzdC9jb21tb25qcy9lc2NhcGUuanM/N2Y2ZSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZXNjYXBlID0gdm9pZCAwO1xuLyoqXG4gKiBFc2NhcGUgYWxsIG1hZ2ljIGNoYXJhY3RlcnMgaW4gYSBnbG9iIHBhdHRlcm4uXG4gKlxuICogSWYgdGhlIHtAbGluayB3aW5kb3dzUGF0aHNOb0VzY2FwZSB8IEdsb2JPcHRpb25zLndpbmRvd3NQYXRoc05vRXNjYXBlfVxuICogb3B0aW9uIGlzIHVzZWQsIHRoZW4gY2hhcmFjdGVycyBhcmUgZXNjYXBlZCBieSB3cmFwcGluZyBpbiBgW11gLCBiZWNhdXNlXG4gKiBhIG1hZ2ljIGNoYXJhY3RlciB3cmFwcGVkIGluIGEgY2hhcmFjdGVyIGNsYXNzIGNhbiBvbmx5IGJlIHNhdGlzZmllZCBieVxuICogdGhhdCBleGFjdCBjaGFyYWN0ZXIuICBJbiB0aGlzIG1vZGUsIGBcXGAgaXMgX25vdF8gZXNjYXBlZCwgYmVjYXVzZSBpdCBpc1xuICogbm90IGludGVycHJldGVkIGFzIGEgbWFnaWMgY2hhcmFjdGVyLCBidXQgaW5zdGVhZCBhcyBhIHBhdGggc2VwYXJhdG9yLlxuICovXG5jb25zdCBlc2NhcGUgPSAocywgeyB3aW5kb3dzUGF0aHNOb0VzY2FwZSA9IGZhbHNlLCB9ID0ge30pID0+IHtcbiAgICAvLyBkb24ndCBuZWVkIHRvIGVzY2FwZSArQCEgYmVjYXVzZSB3ZSBlc2NhcGUgdGhlIHBhcmVuc1xuICAgIC8vIHRoYXQgbWFrZSB0aG9zZSBtYWdpYywgYW5kIGVzY2FwaW5nICEgYXMgWyFdIGlzbid0IHZhbGlkLFxuICAgIC8vIGJlY2F1c2UgWyFdXSBpcyBhIHZhbGlkIGdsb2IgY2xhc3MgbWVhbmluZyBub3QgJ10nLlxuICAgIHJldHVybiB3aW5kb3dzUGF0aHNOb0VzY2FwZVxuICAgICAgICA/IHMucmVwbGFjZSgvWz8qKClbXFxdXS9nLCAnWyQmXScpXG4gICAgICAgIDogcy5yZXBsYWNlKC9bPyooKVtcXF1cXFxcXS9nLCAnXFxcXCQmJyk7XG59O1xuZXhwb3J0cy5lc2NhcGUgPSBlc2NhcGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1lc2NhcGUuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(instrument)/./node_modules/minimatch/dist/commonjs/escape.js\n");

/***/ }),

/***/ "(instrument)/./node_modules/minimatch/dist/commonjs/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/minimatch/dist/commonjs/index.js ***!
  \*******************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.unescape = exports.escape = exports.AST = exports.Minimatch = exports.match = exports.makeRe = exports.braceExpand = exports.defaults = exports.filter = exports.GLOBSTAR = exports.sep = exports.minimatch = void 0;\nconst brace_expansion_1 = __importDefault(__webpack_require__(/*! brace-expansion */ \"(instrument)/./node_modules/brace-expansion/index.js\"));\nconst assert_valid_pattern_js_1 = __webpack_require__(/*! ./assert-valid-pattern.js */ \"(instrument)/./node_modules/minimatch/dist/commonjs/assert-valid-pattern.js\");\nconst ast_js_1 = __webpack_require__(/*! ./ast.js */ \"(instrument)/./node_modules/minimatch/dist/commonjs/ast.js\");\nconst escape_js_1 = __webpack_require__(/*! ./escape.js */ \"(instrument)/./node_modules/minimatch/dist/commonjs/escape.js\");\nconst unescape_js_1 = __webpack_require__(/*! ./unescape.js */ \"(instrument)/./node_modules/minimatch/dist/commonjs/unescape.js\");\nconst minimatch = (p, pattern, options = {}) => {\n    (0, assert_valid_pattern_js_1.assertValidPattern)(pattern);\n    // shortcut: comments match nothing.\n    if (!options.nocomment && pattern.charAt(0) === '#') {\n        return false;\n    }\n    return new Minimatch(pattern, options).match(p);\n};\nexports.minimatch = minimatch;\n// Optimized checking for the most common glob patterns.\nconst starDotExtRE = /^\\*+([^+@!?\\*\\[\\(]*)$/;\nconst starDotExtTest = (ext) => (f) => !f.startsWith('.') && f.endsWith(ext);\nconst starDotExtTestDot = (ext) => (f) => f.endsWith(ext);\nconst starDotExtTestNocase = (ext) => {\n    ext = ext.toLowerCase();\n    return (f) => !f.startsWith('.') && f.toLowerCase().endsWith(ext);\n};\nconst starDotExtTestNocaseDot = (ext) => {\n    ext = ext.toLowerCase();\n    return (f) => f.toLowerCase().endsWith(ext);\n};\nconst starDotStarRE = /^\\*+\\.\\*+$/;\nconst starDotStarTest = (f) => !f.startsWith('.') && f.includes('.');\nconst starDotStarTestDot = (f) => f !== '.' && f !== '..' && f.includes('.');\nconst dotStarRE = /^\\.\\*+$/;\nconst dotStarTest = (f) => f !== '.' && f !== '..' && f.startsWith('.');\nconst starRE = /^\\*+$/;\nconst starTest = (f) => f.length !== 0 && !f.startsWith('.');\nconst starTestDot = (f) => f.length !== 0 && f !== '.' && f !== '..';\nconst qmarksRE = /^\\?+([^+@!?\\*\\[\\(]*)?$/;\nconst qmarksTestNocase = ([$0, ext = '']) => {\n    const noext = qmarksTestNoExt([$0]);\n    if (!ext)\n        return noext;\n    ext = ext.toLowerCase();\n    return (f) => noext(f) && f.toLowerCase().endsWith(ext);\n};\nconst qmarksTestNocaseDot = ([$0, ext = '']) => {\n    const noext = qmarksTestNoExtDot([$0]);\n    if (!ext)\n        return noext;\n    ext = ext.toLowerCase();\n    return (f) => noext(f) && f.toLowerCase().endsWith(ext);\n};\nconst qmarksTestDot = ([$0, ext = '']) => {\n    const noext = qmarksTestNoExtDot([$0]);\n    return !ext ? noext : (f) => noext(f) && f.endsWith(ext);\n};\nconst qmarksTest = ([$0, ext = '']) => {\n    const noext = qmarksTestNoExt([$0]);\n    return !ext ? noext : (f) => noext(f) && f.endsWith(ext);\n};\nconst qmarksTestNoExt = ([$0]) => {\n    const len = $0.length;\n    return (f) => f.length === len && !f.startsWith('.');\n};\nconst qmarksTestNoExtDot = ([$0]) => {\n    const len = $0.length;\n    return (f) => f.length === len && f !== '.' && f !== '..';\n};\n/* c8 ignore start */\nconst defaultPlatform = (typeof process === 'object' && process\n    ? (typeof process.env === 'object' &&\n        process.env &&\n        process.env.__MINIMATCH_TESTING_PLATFORM__) ||\n        process.platform\n    : 'posix');\nconst path = {\n    win32: { sep: '\\\\' },\n    posix: { sep: '/' },\n};\n/* c8 ignore stop */\nexports.sep = defaultPlatform === 'win32' ? path.win32.sep : path.posix.sep;\nexports.minimatch.sep = exports.sep;\nexports.GLOBSTAR = Symbol('globstar **');\nexports.minimatch.GLOBSTAR = exports.GLOBSTAR;\n// any single thing other than /\n// don't need to escape / when using new RegExp()\nconst qmark = '[^/]';\n// * => any number of characters\nconst star = qmark + '*?';\n// ** when dots are allowed.  Anything goes, except .. and .\n// not (^ or / followed by one or two dots followed by $ or /),\n// followed by anything, any number of times.\nconst twoStarDot = '(?:(?!(?:\\\\/|^)(?:\\\\.{1,2})($|\\\\/)).)*?';\n// not a ^ or / followed by a dot,\n// followed by anything, any number of times.\nconst twoStarNoDot = '(?:(?!(?:\\\\/|^)\\\\.).)*?';\nconst filter = (pattern, options = {}) => (p) => (0, exports.minimatch)(p, pattern, options);\nexports.filter = filter;\nexports.minimatch.filter = exports.filter;\nconst ext = (a, b = {}) => Object.assign({}, a, b);\nconst defaults = (def) => {\n    if (!def || typeof def !== 'object' || !Object.keys(def).length) {\n        return exports.minimatch;\n    }\n    const orig = exports.minimatch;\n    const m = (p, pattern, options = {}) => orig(p, pattern, ext(def, options));\n    return Object.assign(m, {\n        Minimatch: class Minimatch extends orig.Minimatch {\n            constructor(pattern, options = {}) {\n                super(pattern, ext(def, options));\n            }\n            static defaults(options) {\n                return orig.defaults(ext(def, options)).Minimatch;\n            }\n        },\n        AST: class AST extends orig.AST {\n            /* c8 ignore start */\n            constructor(type, parent, options = {}) {\n                super(type, parent, ext(def, options));\n            }\n            /* c8 ignore stop */\n            static fromGlob(pattern, options = {}) {\n                return orig.AST.fromGlob(pattern, ext(def, options));\n            }\n        },\n        unescape: (s, options = {}) => orig.unescape(s, ext(def, options)),\n        escape: (s, options = {}) => orig.escape(s, ext(def, options)),\n        filter: (pattern, options = {}) => orig.filter(pattern, ext(def, options)),\n        defaults: (options) => orig.defaults(ext(def, options)),\n        makeRe: (pattern, options = {}) => orig.makeRe(pattern, ext(def, options)),\n        braceExpand: (pattern, options = {}) => orig.braceExpand(pattern, ext(def, options)),\n        match: (list, pattern, options = {}) => orig.match(list, pattern, ext(def, options)),\n        sep: orig.sep,\n        GLOBSTAR: exports.GLOBSTAR,\n    });\n};\nexports.defaults = defaults;\nexports.minimatch.defaults = exports.defaults;\n// Brace expansion:\n// a{b,c}d -> abd acd\n// a{b,}c -> abc ac\n// a{0..3}d -> a0d a1d a2d a3d\n// a{b,c{d,e}f}g -> abg acdfg acefg\n// a{b,c}d{e,f}g -> abdeg acdeg abdeg abdfg\n//\n// Invalid sets are not expanded.\n// a{2..}b -> a{2..}b\n// a{b}c -> a{b}c\nconst braceExpand = (pattern, options = {}) => {\n    (0, assert_valid_pattern_js_1.assertValidPattern)(pattern);\n    // Thanks to Yeting Li <https://github.com/yetingli> for\n    // improving this regexp to avoid a ReDOS vulnerability.\n    if (options.nobrace || !/\\{(?:(?!\\{).)*\\}/.test(pattern)) {\n        // shortcut. no need to expand.\n        return [pattern];\n    }\n    return (0, brace_expansion_1.default)(pattern);\n};\nexports.braceExpand = braceExpand;\nexports.minimatch.braceExpand = exports.braceExpand;\n// parse a component of the expanded set.\n// At this point, no pattern may contain \"/\" in it\n// so we're going to return a 2d array, where each entry is the full\n// pattern, split on '/', and then turned into a regular expression.\n// A regexp is made at the end which joins each array with an\n// escaped /, and another full one which joins each regexp with |.\n//\n// Following the lead of Bash 4.1, note that \"**\" only has special meaning\n// when it is the *only* thing in a path portion.  Otherwise, any series\n// of * is equivalent to a single *.  Globstar behavior is enabled by\n// default, and can be disabled by setting options.noglobstar.\nconst makeRe = (pattern, options = {}) => new Minimatch(pattern, options).makeRe();\nexports.makeRe = makeRe;\nexports.minimatch.makeRe = exports.makeRe;\nconst match = (list, pattern, options = {}) => {\n    const mm = new Minimatch(pattern, options);\n    list = list.filter(f => mm.match(f));\n    if (mm.options.nonull && !list.length) {\n        list.push(pattern);\n    }\n    return list;\n};\nexports.match = match;\nexports.minimatch.match = exports.match;\n// replace stuff like \\* with *\nconst globMagic = /[?*]|[+@!]\\(.*?\\)|\\[|\\]/;\nconst regExpEscape = (s) => s.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, '\\\\$&');\nclass Minimatch {\n    options;\n    set;\n    pattern;\n    windowsPathsNoEscape;\n    nonegate;\n    negate;\n    comment;\n    empty;\n    preserveMultipleSlashes;\n    partial;\n    globSet;\n    globParts;\n    nocase;\n    isWindows;\n    platform;\n    windowsNoMagicRoot;\n    regexp;\n    constructor(pattern, options = {}) {\n        (0, assert_valid_pattern_js_1.assertValidPattern)(pattern);\n        options = options || {};\n        this.options = options;\n        this.pattern = pattern;\n        this.platform = options.platform || defaultPlatform;\n        this.isWindows = this.platform === 'win32';\n        this.windowsPathsNoEscape =\n            !!options.windowsPathsNoEscape || options.allowWindowsEscape === false;\n        if (this.windowsPathsNoEscape) {\n            this.pattern = this.pattern.replace(/\\\\/g, '/');\n        }\n        this.preserveMultipleSlashes = !!options.preserveMultipleSlashes;\n        this.regexp = null;\n        this.negate = false;\n        this.nonegate = !!options.nonegate;\n        this.comment = false;\n        this.empty = false;\n        this.partial = !!options.partial;\n        this.nocase = !!this.options.nocase;\n        this.windowsNoMagicRoot =\n            options.windowsNoMagicRoot !== undefined\n                ? options.windowsNoMagicRoot\n                : !!(this.isWindows && this.nocase);\n        this.globSet = [];\n        this.globParts = [];\n        this.set = [];\n        // make the set of regexps etc.\n        this.make();\n    }\n    hasMagic() {\n        if (this.options.magicalBraces && this.set.length > 1) {\n            return true;\n        }\n        for (const pattern of this.set) {\n            for (const part of pattern) {\n                if (typeof part !== 'string')\n                    return true;\n            }\n        }\n        return false;\n    }\n    debug(..._) { }\n    make() {\n        const pattern = this.pattern;\n        const options = this.options;\n        // empty patterns and comments match nothing.\n        if (!options.nocomment && pattern.charAt(0) === '#') {\n            this.comment = true;\n            return;\n        }\n        if (!pattern) {\n            this.empty = true;\n            return;\n        }\n        // step 1: figure out negation, etc.\n        this.parseNegate();\n        // step 2: expand braces\n        this.globSet = [...new Set(this.braceExpand())];\n        if (options.debug) {\n            this.debug = (...args) => console.error(...args);\n        }\n        this.debug(this.pattern, this.globSet);\n        // step 3: now we have a set, so turn each one into a series of\n        // path-portion matching patterns.\n        // These will be regexps, except in the case of \"**\", which is\n        // set to the GLOBSTAR object for globstar behavior,\n        // and will not contain any / characters\n        //\n        // First, we preprocess to make the glob pattern sets a bit simpler\n        // and deduped.  There are some perf-killing patterns that can cause\n        // problems with a glob walk, but we can simplify them down a bit.\n        const rawGlobParts = this.globSet.map(s => this.slashSplit(s));\n        this.globParts = this.preprocess(rawGlobParts);\n        this.debug(this.pattern, this.globParts);\n        // glob --> regexps\n        let set = this.globParts.map((s, _, __) => {\n            if (this.isWindows && this.windowsNoMagicRoot) {\n                // check if it's a drive or unc path.\n                const isUNC = s[0] === '' &&\n                    s[1] === '' &&\n                    (s[2] === '?' || !globMagic.test(s[2])) &&\n                    !globMagic.test(s[3]);\n                const isDrive = /^[a-z]:/i.test(s[0]);\n                if (isUNC) {\n                    return [...s.slice(0, 4), ...s.slice(4).map(ss => this.parse(ss))];\n                }\n                else if (isDrive) {\n                    return [s[0], ...s.slice(1).map(ss => this.parse(ss))];\n                }\n            }\n            return s.map(ss => this.parse(ss));\n        });\n        this.debug(this.pattern, set);\n        // filter out everything that didn't compile properly.\n        this.set = set.filter(s => s.indexOf(false) === -1);\n        // do not treat the ? in UNC paths as magic\n        if (this.isWindows) {\n            for (let i = 0; i < this.set.length; i++) {\n                const p = this.set[i];\n                if (p[0] === '' &&\n                    p[1] === '' &&\n                    this.globParts[i][2] === '?' &&\n                    typeof p[3] === 'string' &&\n                    /^[a-z]:$/i.test(p[3])) {\n                    p[2] = '?';\n                }\n            }\n        }\n        this.debug(this.pattern, this.set);\n    }\n    // various transforms to equivalent pattern sets that are\n    // faster to process in a filesystem walk.  The goal is to\n    // eliminate what we can, and push all ** patterns as far\n    // to the right as possible, even if it increases the number\n    // of patterns that we have to process.\n    preprocess(globParts) {\n        // if we're not in globstar mode, then turn all ** into *\n        if (this.options.noglobstar) {\n            for (let i = 0; i < globParts.length; i++) {\n                for (let j = 0; j < globParts[i].length; j++) {\n                    if (globParts[i][j] === '**') {\n                        globParts[i][j] = '*';\n                    }\n                }\n            }\n        }\n        const { optimizationLevel = 1 } = this.options;\n        if (optimizationLevel >= 2) {\n            // aggressive optimization for the purpose of fs walking\n            globParts = this.firstPhasePreProcess(globParts);\n            globParts = this.secondPhasePreProcess(globParts);\n        }\n        else if (optimizationLevel >= 1) {\n            // just basic optimizations to remove some .. parts\n            globParts = this.levelOneOptimize(globParts);\n        }\n        else {\n            // just collapse multiple ** portions into one\n            globParts = this.adjascentGlobstarOptimize(globParts);\n        }\n        return globParts;\n    }\n    // just get rid of adjascent ** portions\n    adjascentGlobstarOptimize(globParts) {\n        return globParts.map(parts => {\n            let gs = -1;\n            while (-1 !== (gs = parts.indexOf('**', gs + 1))) {\n                let i = gs;\n                while (parts[i + 1] === '**') {\n                    i++;\n                }\n                if (i !== gs) {\n                    parts.splice(gs, i - gs);\n                }\n            }\n            return parts;\n        });\n    }\n    // get rid of adjascent ** and resolve .. portions\n    levelOneOptimize(globParts) {\n        return globParts.map(parts => {\n            parts = parts.reduce((set, part) => {\n                const prev = set[set.length - 1];\n                if (part === '**' && prev === '**') {\n                    return set;\n                }\n                if (part === '..') {\n                    if (prev && prev !== '..' && prev !== '.' && prev !== '**') {\n                        set.pop();\n                        return set;\n                    }\n                }\n                set.push(part);\n                return set;\n            }, []);\n            return parts.length === 0 ? [''] : parts;\n        });\n    }\n    levelTwoFileOptimize(parts) {\n        if (!Array.isArray(parts)) {\n            parts = this.slashSplit(parts);\n        }\n        let didSomething = false;\n        do {\n            didSomething = false;\n            // <pre>/<e>/<rest> -> <pre>/<rest>\n            if (!this.preserveMultipleSlashes) {\n                for (let i = 1; i < parts.length - 1; i++) {\n                    const p = parts[i];\n                    // don't squeeze out UNC patterns\n                    if (i === 1 && p === '' && parts[0] === '')\n                        continue;\n                    if (p === '.' || p === '') {\n                        didSomething = true;\n                        parts.splice(i, 1);\n                        i--;\n                    }\n                }\n                if (parts[0] === '.' &&\n                    parts.length === 2 &&\n                    (parts[1] === '.' || parts[1] === '')) {\n                    didSomething = true;\n                    parts.pop();\n                }\n            }\n            // <pre>/<p>/../<rest> -> <pre>/<rest>\n            let dd = 0;\n            while (-1 !== (dd = parts.indexOf('..', dd + 1))) {\n                const p = parts[dd - 1];\n                if (p && p !== '.' && p !== '..' && p !== '**') {\n                    didSomething = true;\n                    parts.splice(dd - 1, 2);\n                    dd -= 2;\n                }\n            }\n        } while (didSomething);\n        return parts.length === 0 ? [''] : parts;\n    }\n    // First phase: single-pattern processing\n    // <pre> is 1 or more portions\n    // <rest> is 1 or more portions\n    // <p> is any portion other than ., .., '', or **\n    // <e> is . or ''\n    //\n    // **/.. is *brutal* for filesystem walking performance, because\n    // it effectively resets the recursive walk each time it occurs,\n    // and ** cannot be reduced out by a .. pattern part like a regexp\n    // or most strings (other than .., ., and '') can be.\n    //\n    // <pre>/**/../<p>/<p>/<rest> -> {<pre>/../<p>/<p>/<rest>,<pre>/**/<p>/<p>/<rest>}\n    // <pre>/<e>/<rest> -> <pre>/<rest>\n    // <pre>/<p>/../<rest> -> <pre>/<rest>\n    // **/**/<rest> -> **/<rest>\n    //\n    // **/*/<rest> -> */**/<rest> <== not valid because ** doesn't follow\n    // this WOULD be allowed if ** did follow symlinks, or * didn't\n    firstPhasePreProcess(globParts) {\n        let didSomething = false;\n        do {\n            didSomething = false;\n            // <pre>/**/../<p>/<p>/<rest> -> {<pre>/../<p>/<p>/<rest>,<pre>/**/<p>/<p>/<rest>}\n            for (let parts of globParts) {\n                let gs = -1;\n                while (-1 !== (gs = parts.indexOf('**', gs + 1))) {\n                    let gss = gs;\n                    while (parts[gss + 1] === '**') {\n                        // <pre>/**/**/<rest> -> <pre>/**/<rest>\n                        gss++;\n                    }\n                    // eg, if gs is 2 and gss is 4, that means we have 3 **\n                    // parts, and can remove 2 of them.\n                    if (gss > gs) {\n                        parts.splice(gs + 1, gss - gs);\n                    }\n                    let next = parts[gs + 1];\n                    const p = parts[gs + 2];\n                    const p2 = parts[gs + 3];\n                    if (next !== '..')\n                        continue;\n                    if (!p ||\n                        p === '.' ||\n                        p === '..' ||\n                        !p2 ||\n                        p2 === '.' ||\n                        p2 === '..') {\n                        continue;\n                    }\n                    didSomething = true;\n                    // edit parts in place, and push the new one\n                    parts.splice(gs, 1);\n                    const other = parts.slice(0);\n                    other[gs] = '**';\n                    globParts.push(other);\n                    gs--;\n                }\n                // <pre>/<e>/<rest> -> <pre>/<rest>\n                if (!this.preserveMultipleSlashes) {\n                    for (let i = 1; i < parts.length - 1; i++) {\n                        const p = parts[i];\n                        // don't squeeze out UNC patterns\n                        if (i === 1 && p === '' && parts[0] === '')\n                            continue;\n                        if (p === '.' || p === '') {\n                            didSomething = true;\n                            parts.splice(i, 1);\n                            i--;\n                        }\n                    }\n                    if (parts[0] === '.' &&\n                        parts.length === 2 &&\n                        (parts[1] === '.' || parts[1] === '')) {\n                        didSomething = true;\n                        parts.pop();\n                    }\n                }\n                // <pre>/<p>/../<rest> -> <pre>/<rest>\n                let dd = 0;\n                while (-1 !== (dd = parts.indexOf('..', dd + 1))) {\n                    const p = parts[dd - 1];\n                    if (p && p !== '.' && p !== '..' && p !== '**') {\n                        didSomething = true;\n                        const needDot = dd === 1 && parts[dd + 1] === '**';\n                        const splin = needDot ? ['.'] : [];\n                        parts.splice(dd - 1, 2, ...splin);\n                        if (parts.length === 0)\n                            parts.push('');\n                        dd -= 2;\n                    }\n                }\n            }\n        } while (didSomething);\n        return globParts;\n    }\n    // second phase: multi-pattern dedupes\n    // {<pre>/*/<rest>,<pre>/<p>/<rest>} -> <pre>/*/<rest>\n    // {<pre>/<rest>,<pre>/<rest>} -> <pre>/<rest>\n    // {<pre>/**/<rest>,<pre>/<rest>} -> <pre>/**/<rest>\n    //\n    // {<pre>/**/<rest>,<pre>/**/<p>/<rest>} -> <pre>/**/<rest>\n    // ^-- not valid because ** doens't follow symlinks\n    secondPhasePreProcess(globParts) {\n        for (let i = 0; i < globParts.length - 1; i++) {\n            for (let j = i + 1; j < globParts.length; j++) {\n                const matched = this.partsMatch(globParts[i], globParts[j], !this.preserveMultipleSlashes);\n                if (matched) {\n                    globParts[i] = [];\n                    globParts[j] = matched;\n                    break;\n                }\n            }\n        }\n        return globParts.filter(gs => gs.length);\n    }\n    partsMatch(a, b, emptyGSMatch = false) {\n        let ai = 0;\n        let bi = 0;\n        let result = [];\n        let which = '';\n        while (ai < a.length && bi < b.length) {\n            if (a[ai] === b[bi]) {\n                result.push(which === 'b' ? b[bi] : a[ai]);\n                ai++;\n                bi++;\n            }\n            else if (emptyGSMatch && a[ai] === '**' && b[bi] === a[ai + 1]) {\n                result.push(a[ai]);\n                ai++;\n            }\n            else if (emptyGSMatch && b[bi] === '**' && a[ai] === b[bi + 1]) {\n                result.push(b[bi]);\n                bi++;\n            }\n            else if (a[ai] === '*' &&\n                b[bi] &&\n                (this.options.dot || !b[bi].startsWith('.')) &&\n                b[bi] !== '**') {\n                if (which === 'b')\n                    return false;\n                which = 'a';\n                result.push(a[ai]);\n                ai++;\n                bi++;\n            }\n            else if (b[bi] === '*' &&\n                a[ai] &&\n                (this.options.dot || !a[ai].startsWith('.')) &&\n                a[ai] !== '**') {\n                if (which === 'a')\n                    return false;\n                which = 'b';\n                result.push(b[bi]);\n                ai++;\n                bi++;\n            }\n            else {\n                return false;\n            }\n        }\n        // if we fall out of the loop, it means they two are identical\n        // as long as their lengths match\n        return a.length === b.length && result;\n    }\n    parseNegate() {\n        if (this.nonegate)\n            return;\n        const pattern = this.pattern;\n        let negate = false;\n        let negateOffset = 0;\n        for (let i = 0; i < pattern.length && pattern.charAt(i) === '!'; i++) {\n            negate = !negate;\n            negateOffset++;\n        }\n        if (negateOffset)\n            this.pattern = pattern.slice(negateOffset);\n        this.negate = negate;\n    }\n    // set partial to true to test if, for example,\n    // \"/a/b\" matches the start of \"/*/b/*/d\"\n    // Partial means, if you run out of file before you run\n    // out of pattern, then that's fine, as long as all\n    // the parts match.\n    matchOne(file, pattern, partial = false) {\n        const options = this.options;\n        // UNC paths like //?/X:/... can match X:/... and vice versa\n        // Drive letters in absolute drive or unc paths are always compared\n        // case-insensitively.\n        if (this.isWindows) {\n            const fileDrive = typeof file[0] === 'string' && /^[a-z]:$/i.test(file[0]);\n            const fileUNC = !fileDrive &&\n                file[0] === '' &&\n                file[1] === '' &&\n                file[2] === '?' &&\n                /^[a-z]:$/i.test(file[3]);\n            const patternDrive = typeof pattern[0] === 'string' && /^[a-z]:$/i.test(pattern[0]);\n            const patternUNC = !patternDrive &&\n                pattern[0] === '' &&\n                pattern[1] === '' &&\n                pattern[2] === '?' &&\n                typeof pattern[3] === 'string' &&\n                /^[a-z]:$/i.test(pattern[3]);\n            const fdi = fileUNC ? 3 : fileDrive ? 0 : undefined;\n            const pdi = patternUNC ? 3 : patternDrive ? 0 : undefined;\n            if (typeof fdi === 'number' && typeof pdi === 'number') {\n                const [fd, pd] = [file[fdi], pattern[pdi]];\n                if (fd.toLowerCase() === pd.toLowerCase()) {\n                    pattern[pdi] = fd;\n                    if (pdi > fdi) {\n                        pattern = pattern.slice(pdi);\n                    }\n                    else if (fdi > pdi) {\n                        file = file.slice(fdi);\n                    }\n                }\n            }\n        }\n        // resolve and reduce . and .. portions in the file as well.\n        // dont' need to do the second phase, because it's only one string[]\n        const { optimizationLevel = 1 } = this.options;\n        if (optimizationLevel >= 2) {\n            file = this.levelTwoFileOptimize(file);\n        }\n        this.debug('matchOne', this, { file, pattern });\n        this.debug('matchOne', file.length, pattern.length);\n        for (var fi = 0, pi = 0, fl = file.length, pl = pattern.length; fi < fl && pi < pl; fi++, pi++) {\n            this.debug('matchOne loop');\n            var p = pattern[pi];\n            var f = file[fi];\n            this.debug(pattern, p, f);\n            // should be impossible.\n            // some invalid regexp stuff in the set.\n            /* c8 ignore start */\n            if (p === false) {\n                return false;\n            }\n            /* c8 ignore stop */\n            if (p === exports.GLOBSTAR) {\n                this.debug('GLOBSTAR', [pattern, p, f]);\n                // \"**\"\n                // a/**/b/**/c would match the following:\n                // a/b/x/y/z/c\n                // a/x/y/z/b/c\n                // a/b/x/b/x/c\n                // a/b/c\n                // To do this, take the rest of the pattern after\n                // the **, and see if it would match the file remainder.\n                // If so, return success.\n                // If not, the ** \"swallows\" a segment, and try again.\n                // This is recursively awful.\n                //\n                // a/**/b/**/c matching a/b/x/y/z/c\n                // - a matches a\n                // - doublestar\n                //   - matchOne(b/x/y/z/c, b/**/c)\n                //     - b matches b\n                //     - doublestar\n                //       - matchOne(x/y/z/c, c) -> no\n                //       - matchOne(y/z/c, c) -> no\n                //       - matchOne(z/c, c) -> no\n                //       - matchOne(c, c) yes, hit\n                var fr = fi;\n                var pr = pi + 1;\n                if (pr === pl) {\n                    this.debug('** at the end');\n                    // a ** at the end will just swallow the rest.\n                    // We have found a match.\n                    // however, it will not swallow /.x, unless\n                    // options.dot is set.\n                    // . and .. are *never* matched by **, for explosively\n                    // exponential reasons.\n                    for (; fi < fl; fi++) {\n                        if (file[fi] === '.' ||\n                            file[fi] === '..' ||\n                            (!options.dot && file[fi].charAt(0) === '.'))\n                            return false;\n                    }\n                    return true;\n                }\n                // ok, let's see if we can swallow whatever we can.\n                while (fr < fl) {\n                    var swallowee = file[fr];\n                    this.debug('\\nglobstar while', file, fr, pattern, pr, swallowee);\n                    // XXX remove this slice.  Just pass the start index.\n                    if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {\n                        this.debug('globstar found match!', fr, fl, swallowee);\n                        // found a match.\n                        return true;\n                    }\n                    else {\n                        // can't swallow \".\" or \"..\" ever.\n                        // can only swallow \".foo\" when explicitly asked.\n                        if (swallowee === '.' ||\n                            swallowee === '..' ||\n                            (!options.dot && swallowee.charAt(0) === '.')) {\n                            this.debug('dot detected!', file, fr, pattern, pr);\n                            break;\n                        }\n                        // ** swallows a segment, and continue.\n                        this.debug('globstar swallow a segment, and continue');\n                        fr++;\n                    }\n                }\n                // no match was found.\n                // However, in partial mode, we can't say this is necessarily over.\n                /* c8 ignore start */\n                if (partial) {\n                    // ran out of file\n                    this.debug('\\n>>> no match, partial?', file, fr, pattern, pr);\n                    if (fr === fl) {\n                        return true;\n                    }\n                }\n                /* c8 ignore stop */\n                return false;\n            }\n            // something other than **\n            // non-magic patterns just have to match exactly\n            // patterns with magic have been turned into regexps.\n            let hit;\n            if (typeof p === 'string') {\n                hit = f === p;\n                this.debug('string match', p, f, hit);\n            }\n            else {\n                hit = p.test(f);\n                this.debug('pattern match', p, f, hit);\n            }\n            if (!hit)\n                return false;\n        }\n        // Note: ending in / means that we'll get a final \"\"\n        // at the end of the pattern.  This can only match a\n        // corresponding \"\" at the end of the file.\n        // If the file ends in /, then it can only match a\n        // a pattern that ends in /, unless the pattern just\n        // doesn't have any more for it. But, a/b/ should *not*\n        // match \"a/b/*\", even though \"\" matches against the\n        // [^/]*? pattern, except in partial mode, where it might\n        // simply not be reached yet.\n        // However, a/b/ should still satisfy a/*\n        // now either we fell off the end of the pattern, or we're done.\n        if (fi === fl && pi === pl) {\n            // ran out of pattern and filename at the same time.\n            // an exact hit!\n            return true;\n        }\n        else if (fi === fl) {\n            // ran out of file, but still had pattern left.\n            // this is ok if we're doing the match as part of\n            // a glob fs traversal.\n            return partial;\n        }\n        else if (pi === pl) {\n            // ran out of pattern, still have file left.\n            // this is only acceptable if we're on the very last\n            // empty segment of a file with a trailing slash.\n            // a/* should match a/b/\n            return fi === fl - 1 && file[fi] === '';\n            /* c8 ignore start */\n        }\n        else {\n            // should be unreachable.\n            throw new Error('wtf?');\n        }\n        /* c8 ignore stop */\n    }\n    braceExpand() {\n        return (0, exports.braceExpand)(this.pattern, this.options);\n    }\n    parse(pattern) {\n        (0, assert_valid_pattern_js_1.assertValidPattern)(pattern);\n        const options = this.options;\n        // shortcuts\n        if (pattern === '**')\n            return exports.GLOBSTAR;\n        if (pattern === '')\n            return '';\n        // far and away, the most common glob pattern parts are\n        // *, *.*, and *.<ext>  Add a fast check method for those.\n        let m;\n        let fastTest = null;\n        if ((m = pattern.match(starRE))) {\n            fastTest = options.dot ? starTestDot : starTest;\n        }\n        else if ((m = pattern.match(starDotExtRE))) {\n            fastTest = (options.nocase\n                ? options.dot\n                    ? starDotExtTestNocaseDot\n                    : starDotExtTestNocase\n                : options.dot\n                    ? starDotExtTestDot\n                    : starDotExtTest)(m[1]);\n        }\n        else if ((m = pattern.match(qmarksRE))) {\n            fastTest = (options.nocase\n                ? options.dot\n                    ? qmarksTestNocaseDot\n                    : qmarksTestNocase\n                : options.dot\n                    ? qmarksTestDot\n                    : qmarksTest)(m);\n        }\n        else if ((m = pattern.match(starDotStarRE))) {\n            fastTest = options.dot ? starDotStarTestDot : starDotStarTest;\n        }\n        else if ((m = pattern.match(dotStarRE))) {\n            fastTest = dotStarTest;\n        }\n        const re = ast_js_1.AST.fromGlob(pattern, this.options).toMMPattern();\n        if (fastTest && typeof re === 'object') {\n            // Avoids overriding in frozen environments\n            Reflect.defineProperty(re, 'test', { value: fastTest });\n        }\n        return re;\n    }\n    makeRe() {\n        if (this.regexp || this.regexp === false)\n            return this.regexp;\n        // at this point, this.set is a 2d array of partial\n        // pattern strings, or \"**\".\n        //\n        // It's better to use .match().  This function shouldn't\n        // be used, really, but it's pretty convenient sometimes,\n        // when you just want to work with a regex.\n        const set = this.set;\n        if (!set.length) {\n            this.regexp = false;\n            return this.regexp;\n        }\n        const options = this.options;\n        const twoStar = options.noglobstar\n            ? star\n            : options.dot\n                ? twoStarDot\n                : twoStarNoDot;\n        const flags = new Set(options.nocase ? ['i'] : []);\n        // regexpify non-globstar patterns\n        // if ** is only item, then we just do one twoStar\n        // if ** is first, and there are more, prepend (\\/|twoStar\\/)? to next\n        // if ** is last, append (\\/twoStar|) to previous\n        // if ** is in the middle, append (\\/|\\/twoStar\\/) to previous\n        // then filter out GLOBSTAR symbols\n        let re = set\n            .map(pattern => {\n            const pp = pattern.map(p => {\n                if (p instanceof RegExp) {\n                    for (const f of p.flags.split(''))\n                        flags.add(f);\n                }\n                return typeof p === 'string'\n                    ? regExpEscape(p)\n                    : p === exports.GLOBSTAR\n                        ? exports.GLOBSTAR\n                        : p._src;\n            });\n            pp.forEach((p, i) => {\n                const next = pp[i + 1];\n                const prev = pp[i - 1];\n                if (p !== exports.GLOBSTAR || prev === exports.GLOBSTAR) {\n                    return;\n                }\n                if (prev === undefined) {\n                    if (next !== undefined && next !== exports.GLOBSTAR) {\n                        pp[i + 1] = '(?:\\\\/|' + twoStar + '\\\\/)?' + next;\n                    }\n                    else {\n                        pp[i] = twoStar;\n                    }\n                }\n                else if (next === undefined) {\n                    pp[i - 1] = prev + '(?:\\\\/|' + twoStar + ')?';\n                }\n                else if (next !== exports.GLOBSTAR) {\n                    pp[i - 1] = prev + '(?:\\\\/|\\\\/' + twoStar + '\\\\/)' + next;\n                    pp[i + 1] = exports.GLOBSTAR;\n                }\n            });\n            return pp.filter(p => p !== exports.GLOBSTAR).join('/');\n        })\n            .join('|');\n        // need to wrap in parens if we had more than one thing with |,\n        // otherwise only the first will be anchored to ^ and the last to $\n        const [open, close] = set.length > 1 ? ['(?:', ')'] : ['', ''];\n        // must match entire pattern\n        // ending in a * or ** will make it less strict.\n        re = '^' + open + re + close + '$';\n        // can match anything, as long as it's not this.\n        if (this.negate)\n            re = '^(?!' + re + ').+$';\n        try {\n            this.regexp = new RegExp(re, [...flags].join(''));\n            /* c8 ignore start */\n        }\n        catch (ex) {\n            // should be impossible\n            this.regexp = false;\n        }\n        /* c8 ignore stop */\n        return this.regexp;\n    }\n    slashSplit(p) {\n        // if p starts with // on windows, we preserve that\n        // so that UNC paths aren't broken.  Otherwise, any number of\n        // / characters are coalesced into one, unless\n        // preserveMultipleSlashes is set to true.\n        if (this.preserveMultipleSlashes) {\n            return p.split('/');\n        }\n        else if (this.isWindows && /^\\/\\/[^\\/]+/.test(p)) {\n            // add an extra '' for the one we lose\n            return ['', ...p.split(/\\/+/)];\n        }\n        else {\n            return p.split(/\\/+/);\n        }\n    }\n    match(f, partial = this.partial) {\n        this.debug('match', f, this.pattern);\n        // short-circuit in the case of busted things.\n        // comments, etc.\n        if (this.comment) {\n            return false;\n        }\n        if (this.empty) {\n            return f === '';\n        }\n        if (f === '/' && partial) {\n            return true;\n        }\n        const options = this.options;\n        // windows: need to use /, not \\\n        if (this.isWindows) {\n            f = f.split('\\\\').join('/');\n        }\n        // treat the test path as a set of pathparts.\n        const ff = this.slashSplit(f);\n        this.debug(this.pattern, 'split', ff);\n        // just ONE of the pattern sets in this.set needs to match\n        // in order for it to be valid.  If negating, then just one\n        // match means that we have failed.\n        // Either way, return on the first hit.\n        const set = this.set;\n        this.debug(this.pattern, 'set', set);\n        // Find the basename of the path by looking for the last non-empty segment\n        let filename = ff[ff.length - 1];\n        if (!filename) {\n            for (let i = ff.length - 2; !filename && i >= 0; i--) {\n                filename = ff[i];\n            }\n        }\n        for (let i = 0; i < set.length; i++) {\n            const pattern = set[i];\n            let file = ff;\n            if (options.matchBase && pattern.length === 1) {\n                file = [filename];\n            }\n            const hit = this.matchOne(file, pattern, partial);\n            if (hit) {\n                if (options.flipNegate) {\n                    return true;\n                }\n                return !this.negate;\n            }\n        }\n        // didn't get any hits.  this is success if it's a negative\n        // pattern, failure otherwise.\n        if (options.flipNegate) {\n            return false;\n        }\n        return this.negate;\n    }\n    static defaults(def) {\n        return exports.minimatch.defaults(def).Minimatch;\n    }\n}\nexports.Minimatch = Minimatch;\n/* c8 ignore start */\nvar ast_js_2 = __webpack_require__(/*! ./ast.js */ \"(instrument)/./node_modules/minimatch/dist/commonjs/ast.js\");\nObject.defineProperty(exports, \"AST\", ({ enumerable: true, get: function () { return ast_js_2.AST; } }));\nvar escape_js_2 = __webpack_require__(/*! ./escape.js */ \"(instrument)/./node_modules/minimatch/dist/commonjs/escape.js\");\nObject.defineProperty(exports, \"escape\", ({ enumerable: true, get: function () { return escape_js_2.escape; } }));\nvar unescape_js_2 = __webpack_require__(/*! ./unescape.js */ \"(instrument)/./node_modules/minimatch/dist/commonjs/unescape.js\");\nObject.defineProperty(exports, \"unescape\", ({ enumerable: true, get: function () { return unescape_js_2.unescape; } }));\n/* c8 ignore stop */\nexports.minimatch.AST = ast_js_1.AST;\nexports.minimatch.Minimatch = Minimatch;\nexports.minimatch.escape = escape_js_1.escape;\nexports.minimatch.unescape = unescape_js_1.unescape;\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGluc3RydW1lbnQpLy4vbm9kZV9tb2R1bGVzL21pbmltYXRjaC9kaXN0L2NvbW1vbmpzL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsZ0JBQWdCLEdBQUcsY0FBYyxHQUFHLFdBQVcsR0FBRyxpQkFBaUIsR0FBRyxhQUFhLEdBQUcsY0FBYyxHQUFHLG1CQUFtQixHQUFHLGdCQUFnQixHQUFHLGNBQWMsR0FBRyxnQkFBZ0IsR0FBRyxXQUFXLEdBQUcsaUJBQWlCO0FBQ25OLDBDQUEwQyxtQkFBTyxDQUFDLDZFQUFpQjtBQUNuRSxrQ0FBa0MsbUJBQU8sQ0FBQyw4R0FBMkI7QUFDckUsaUJBQWlCLG1CQUFPLENBQUMsNEVBQVU7QUFDbkMsb0JBQW9CLG1CQUFPLENBQUMsa0ZBQWE7QUFDekMsc0JBQXNCLG1CQUFPLENBQUMsc0ZBQWU7QUFDN0MsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFdBQVc7QUFDeEIsYUFBYSxVQUFVO0FBQ3ZCO0FBQ0E7QUFDQSxXQUFXO0FBQ1gscUJBQXFCO0FBQ3JCLGdCQUFnQjtBQUNoQiwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxJQUFJO0FBQzlDO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQyxjQUFjO0FBQ2Qsd0JBQXdCO0FBQ3hCLHNCQUFzQixxQkFBcUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLGtEQUFrRDtBQUNsRDtBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBLFNBQVM7QUFDVCxrQ0FBa0M7QUFDbEMsZ0NBQWdDO0FBQ2hDLHNDQUFzQztBQUN0QztBQUNBLHNDQUFzQztBQUN0QywyQ0FBMkM7QUFDM0MsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxnQkFBZ0I7QUFDaEIsMEJBQTBCO0FBQzFCO0FBQ0EsS0FBSyxJQUFJO0FBQ1QsS0FBSyxHQUFHO0FBQ1IsS0FBSyxLQUFLO0FBQ1YsS0FBSyxJQUFJLElBQUksRUFBRTtBQUNmLEtBQUssSUFBSSxFQUFFLElBQUk7QUFDZjtBQUNBO0FBQ0EsS0FBSyxJQUFJLE9BQU8sSUFBSTtBQUNwQixLQUFLLEVBQUUsT0FBTyxFQUFFO0FBQ2hCLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsUUFBUSxNQUFNO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkIsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckMsY0FBYztBQUNkLHdCQUF3QjtBQUN4QiwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIscUJBQXFCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsc0JBQXNCO0FBQ2xELGdDQUFnQyx5QkFBeUI7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHdCQUF3QjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0Msc0JBQXNCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0Msc0JBQXNCO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsUUFBUSxpQ0FBaUM7QUFDekMsUUFBUSwyQkFBMkI7QUFDbkMsUUFBUSw4QkFBOEI7QUFDdEM7QUFDQSxRQUFRLHFDQUFxQztBQUM3QztBQUNBO0FBQ0Esd0JBQXdCLDBCQUEwQjtBQUNsRCxnQ0FBZ0Msc0JBQXNCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsaURBQWlEO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQix3QkFBd0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLGVBQWU7QUFDdEQ7QUFDQSx3RUFBd0Usb0JBQW9CO0FBQzVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixTQUFTO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsaUJBQWlCO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MscUJBQXFCO0FBQzdEO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixnQkFBZ0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsZUFBZSxtQkFBTyxDQUFDLDRFQUFVO0FBQ2pDLHVDQUFzQyxFQUFFLHFDQUFxQyx3QkFBd0IsRUFBQztBQUN0RyxrQkFBa0IsbUJBQU8sQ0FBQyxrRkFBYTtBQUN2QywwQ0FBeUMsRUFBRSxxQ0FBcUMsOEJBQThCLEVBQUM7QUFDL0csb0JBQW9CLG1CQUFPLENBQUMsc0ZBQWU7QUFDM0MsNENBQTJDLEVBQUUscUNBQXFDLGtDQUFrQyxFQUFDO0FBQ3JIO0FBQ0EscUJBQXFCO0FBQ3JCLDJCQUEyQjtBQUMzQix3QkFBd0I7QUFDeEIsMEJBQTBCO0FBQzFCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYXV0by1sb29wLWRlbW8vLi9ub2RlX21vZHVsZXMvbWluaW1hdGNoL2Rpc3QvY29tbW9uanMvaW5kZXguanM/MTQ2NCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMudW5lc2NhcGUgPSBleHBvcnRzLmVzY2FwZSA9IGV4cG9ydHMuQVNUID0gZXhwb3J0cy5NaW5pbWF0Y2ggPSBleHBvcnRzLm1hdGNoID0gZXhwb3J0cy5tYWtlUmUgPSBleHBvcnRzLmJyYWNlRXhwYW5kID0gZXhwb3J0cy5kZWZhdWx0cyA9IGV4cG9ydHMuZmlsdGVyID0gZXhwb3J0cy5HTE9CU1RBUiA9IGV4cG9ydHMuc2VwID0gZXhwb3J0cy5taW5pbWF0Y2ggPSB2b2lkIDA7XG5jb25zdCBicmFjZV9leHBhbnNpb25fMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiYnJhY2UtZXhwYW5zaW9uXCIpKTtcbmNvbnN0IGFzc2VydF92YWxpZF9wYXR0ZXJuX2pzXzEgPSByZXF1aXJlKFwiLi9hc3NlcnQtdmFsaWQtcGF0dGVybi5qc1wiKTtcbmNvbnN0IGFzdF9qc18xID0gcmVxdWlyZShcIi4vYXN0LmpzXCIpO1xuY29uc3QgZXNjYXBlX2pzXzEgPSByZXF1aXJlKFwiLi9lc2NhcGUuanNcIik7XG5jb25zdCB1bmVzY2FwZV9qc18xID0gcmVxdWlyZShcIi4vdW5lc2NhcGUuanNcIik7XG5jb25zdCBtaW5pbWF0Y2ggPSAocCwgcGF0dGVybiwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgKDAsIGFzc2VydF92YWxpZF9wYXR0ZXJuX2pzXzEuYXNzZXJ0VmFsaWRQYXR0ZXJuKShwYXR0ZXJuKTtcbiAgICAvLyBzaG9ydGN1dDogY29tbWVudHMgbWF0Y2ggbm90aGluZy5cbiAgICBpZiAoIW9wdGlvbnMubm9jb21tZW50ICYmIHBhdHRlcm4uY2hhckF0KDApID09PSAnIycpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IE1pbmltYXRjaChwYXR0ZXJuLCBvcHRpb25zKS5tYXRjaChwKTtcbn07XG5leHBvcnRzLm1pbmltYXRjaCA9IG1pbmltYXRjaDtcbi8vIE9wdGltaXplZCBjaGVja2luZyBmb3IgdGhlIG1vc3QgY29tbW9uIGdsb2IgcGF0dGVybnMuXG5jb25zdCBzdGFyRG90RXh0UkUgPSAvXlxcKisoW14rQCE/XFwqXFxbXFwoXSopJC87XG5jb25zdCBzdGFyRG90RXh0VGVzdCA9IChleHQpID0+IChmKSA9PiAhZi5zdGFydHNXaXRoKCcuJykgJiYgZi5lbmRzV2l0aChleHQpO1xuY29uc3Qgc3RhckRvdEV4dFRlc3REb3QgPSAoZXh0KSA9PiAoZikgPT4gZi5lbmRzV2l0aChleHQpO1xuY29uc3Qgc3RhckRvdEV4dFRlc3ROb2Nhc2UgPSAoZXh0KSA9PiB7XG4gICAgZXh0ID0gZXh0LnRvTG93ZXJDYXNlKCk7XG4gICAgcmV0dXJuIChmKSA9PiAhZi5zdGFydHNXaXRoKCcuJykgJiYgZi50b0xvd2VyQ2FzZSgpLmVuZHNXaXRoKGV4dCk7XG59O1xuY29uc3Qgc3RhckRvdEV4dFRlc3ROb2Nhc2VEb3QgPSAoZXh0KSA9PiB7XG4gICAgZXh0ID0gZXh0LnRvTG93ZXJDYXNlKCk7XG4gICAgcmV0dXJuIChmKSA9PiBmLnRvTG93ZXJDYXNlKCkuZW5kc1dpdGgoZXh0KTtcbn07XG5jb25zdCBzdGFyRG90U3RhclJFID0gL15cXCorXFwuXFwqKyQvO1xuY29uc3Qgc3RhckRvdFN0YXJUZXN0ID0gKGYpID0+ICFmLnN0YXJ0c1dpdGgoJy4nKSAmJiBmLmluY2x1ZGVzKCcuJyk7XG5jb25zdCBzdGFyRG90U3RhclRlc3REb3QgPSAoZikgPT4gZiAhPT0gJy4nICYmIGYgIT09ICcuLicgJiYgZi5pbmNsdWRlcygnLicpO1xuY29uc3QgZG90U3RhclJFID0gL15cXC5cXCorJC87XG5jb25zdCBkb3RTdGFyVGVzdCA9IChmKSA9PiBmICE9PSAnLicgJiYgZiAhPT0gJy4uJyAmJiBmLnN0YXJ0c1dpdGgoJy4nKTtcbmNvbnN0IHN0YXJSRSA9IC9eXFwqKyQvO1xuY29uc3Qgc3RhclRlc3QgPSAoZikgPT4gZi5sZW5ndGggIT09IDAgJiYgIWYuc3RhcnRzV2l0aCgnLicpO1xuY29uc3Qgc3RhclRlc3REb3QgPSAoZikgPT4gZi5sZW5ndGggIT09IDAgJiYgZiAhPT0gJy4nICYmIGYgIT09ICcuLic7XG5jb25zdCBxbWFya3NSRSA9IC9eXFw/KyhbXitAIT9cXCpcXFtcXChdKik/JC87XG5jb25zdCBxbWFya3NUZXN0Tm9jYXNlID0gKFskMCwgZXh0ID0gJyddKSA9PiB7XG4gICAgY29uc3Qgbm9leHQgPSBxbWFya3NUZXN0Tm9FeHQoWyQwXSk7XG4gICAgaWYgKCFleHQpXG4gICAgICAgIHJldHVybiBub2V4dDtcbiAgICBleHQgPSBleHQudG9Mb3dlckNhc2UoKTtcbiAgICByZXR1cm4gKGYpID0+IG5vZXh0KGYpICYmIGYudG9Mb3dlckNhc2UoKS5lbmRzV2l0aChleHQpO1xufTtcbmNvbnN0IHFtYXJrc1Rlc3ROb2Nhc2VEb3QgPSAoWyQwLCBleHQgPSAnJ10pID0+IHtcbiAgICBjb25zdCBub2V4dCA9IHFtYXJrc1Rlc3ROb0V4dERvdChbJDBdKTtcbiAgICBpZiAoIWV4dClcbiAgICAgICAgcmV0dXJuIG5vZXh0O1xuICAgIGV4dCA9IGV4dC50b0xvd2VyQ2FzZSgpO1xuICAgIHJldHVybiAoZikgPT4gbm9leHQoZikgJiYgZi50b0xvd2VyQ2FzZSgpLmVuZHNXaXRoKGV4dCk7XG59O1xuY29uc3QgcW1hcmtzVGVzdERvdCA9IChbJDAsIGV4dCA9ICcnXSkgPT4ge1xuICAgIGNvbnN0IG5vZXh0ID0gcW1hcmtzVGVzdE5vRXh0RG90KFskMF0pO1xuICAgIHJldHVybiAhZXh0ID8gbm9leHQgOiAoZikgPT4gbm9leHQoZikgJiYgZi5lbmRzV2l0aChleHQpO1xufTtcbmNvbnN0IHFtYXJrc1Rlc3QgPSAoWyQwLCBleHQgPSAnJ10pID0+IHtcbiAgICBjb25zdCBub2V4dCA9IHFtYXJrc1Rlc3ROb0V4dChbJDBdKTtcbiAgICByZXR1cm4gIWV4dCA/IG5vZXh0IDogKGYpID0+IG5vZXh0KGYpICYmIGYuZW5kc1dpdGgoZXh0KTtcbn07XG5jb25zdCBxbWFya3NUZXN0Tm9FeHQgPSAoWyQwXSkgPT4ge1xuICAgIGNvbnN0IGxlbiA9ICQwLmxlbmd0aDtcbiAgICByZXR1cm4gKGYpID0+IGYubGVuZ3RoID09PSBsZW4gJiYgIWYuc3RhcnRzV2l0aCgnLicpO1xufTtcbmNvbnN0IHFtYXJrc1Rlc3ROb0V4dERvdCA9IChbJDBdKSA9PiB7XG4gICAgY29uc3QgbGVuID0gJDAubGVuZ3RoO1xuICAgIHJldHVybiAoZikgPT4gZi5sZW5ndGggPT09IGxlbiAmJiBmICE9PSAnLicgJiYgZiAhPT0gJy4uJztcbn07XG4vKiBjOCBpZ25vcmUgc3RhcnQgKi9cbmNvbnN0IGRlZmF1bHRQbGF0Zm9ybSA9ICh0eXBlb2YgcHJvY2VzcyA9PT0gJ29iamVjdCcgJiYgcHJvY2Vzc1xuICAgID8gKHR5cGVvZiBwcm9jZXNzLmVudiA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgcHJvY2Vzcy5lbnYgJiZcbiAgICAgICAgcHJvY2Vzcy5lbnYuX19NSU5JTUFUQ0hfVEVTVElOR19QTEFURk9STV9fKSB8fFxuICAgICAgICBwcm9jZXNzLnBsYXRmb3JtXG4gICAgOiAncG9zaXgnKTtcbmNvbnN0IHBhdGggPSB7XG4gICAgd2luMzI6IHsgc2VwOiAnXFxcXCcgfSxcbiAgICBwb3NpeDogeyBzZXA6ICcvJyB9LFxufTtcbi8qIGM4IGlnbm9yZSBzdG9wICovXG5leHBvcnRzLnNlcCA9IGRlZmF1bHRQbGF0Zm9ybSA9PT0gJ3dpbjMyJyA/IHBhdGgud2luMzIuc2VwIDogcGF0aC5wb3NpeC5zZXA7XG5leHBvcnRzLm1pbmltYXRjaC5zZXAgPSBleHBvcnRzLnNlcDtcbmV4cG9ydHMuR0xPQlNUQVIgPSBTeW1ib2woJ2dsb2JzdGFyICoqJyk7XG5leHBvcnRzLm1pbmltYXRjaC5HTE9CU1RBUiA9IGV4cG9ydHMuR0xPQlNUQVI7XG4vLyBhbnkgc2luZ2xlIHRoaW5nIG90aGVyIHRoYW4gL1xuLy8gZG9uJ3QgbmVlZCB0byBlc2NhcGUgLyB3aGVuIHVzaW5nIG5ldyBSZWdFeHAoKVxuY29uc3QgcW1hcmsgPSAnW14vXSc7XG4vLyAqID0+IGFueSBudW1iZXIgb2YgY2hhcmFjdGVyc1xuY29uc3Qgc3RhciA9IHFtYXJrICsgJyo/Jztcbi8vICoqIHdoZW4gZG90cyBhcmUgYWxsb3dlZC4gIEFueXRoaW5nIGdvZXMsIGV4Y2VwdCAuLiBhbmQgLlxuLy8gbm90ICheIG9yIC8gZm9sbG93ZWQgYnkgb25lIG9yIHR3byBkb3RzIGZvbGxvd2VkIGJ5ICQgb3IgLyksXG4vLyBmb2xsb3dlZCBieSBhbnl0aGluZywgYW55IG51bWJlciBvZiB0aW1lcy5cbmNvbnN0IHR3b1N0YXJEb3QgPSAnKD86KD8hKD86XFxcXC98XikoPzpcXFxcLnsxLDJ9KSgkfFxcXFwvKSkuKSo/Jztcbi8vIG5vdCBhIF4gb3IgLyBmb2xsb3dlZCBieSBhIGRvdCxcbi8vIGZvbGxvd2VkIGJ5IGFueXRoaW5nLCBhbnkgbnVtYmVyIG9mIHRpbWVzLlxuY29uc3QgdHdvU3Rhck5vRG90ID0gJyg/Oig/ISg/OlxcXFwvfF4pXFxcXC4pLikqPyc7XG5jb25zdCBmaWx0ZXIgPSAocGF0dGVybiwgb3B0aW9ucyA9IHt9KSA9PiAocCkgPT4gKDAsIGV4cG9ydHMubWluaW1hdGNoKShwLCBwYXR0ZXJuLCBvcHRpb25zKTtcbmV4cG9ydHMuZmlsdGVyID0gZmlsdGVyO1xuZXhwb3J0cy5taW5pbWF0Y2guZmlsdGVyID0gZXhwb3J0cy5maWx0ZXI7XG5jb25zdCBleHQgPSAoYSwgYiA9IHt9KSA9PiBPYmplY3QuYXNzaWduKHt9LCBhLCBiKTtcbmNvbnN0IGRlZmF1bHRzID0gKGRlZikgPT4ge1xuICAgIGlmICghZGVmIHx8IHR5cGVvZiBkZWYgIT09ICdvYmplY3QnIHx8ICFPYmplY3Qua2V5cyhkZWYpLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gZXhwb3J0cy5taW5pbWF0Y2g7XG4gICAgfVxuICAgIGNvbnN0IG9yaWcgPSBleHBvcnRzLm1pbmltYXRjaDtcbiAgICBjb25zdCBtID0gKHAsIHBhdHRlcm4sIG9wdGlvbnMgPSB7fSkgPT4gb3JpZyhwLCBwYXR0ZXJuLCBleHQoZGVmLCBvcHRpb25zKSk7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24obSwge1xuICAgICAgICBNaW5pbWF0Y2g6IGNsYXNzIE1pbmltYXRjaCBleHRlbmRzIG9yaWcuTWluaW1hdGNoIHtcbiAgICAgICAgICAgIGNvbnN0cnVjdG9yKHBhdHRlcm4sIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICAgICAgICAgIHN1cGVyKHBhdHRlcm4sIGV4dChkZWYsIG9wdGlvbnMpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0YXRpYyBkZWZhdWx0cyhvcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9yaWcuZGVmYXVsdHMoZXh0KGRlZiwgb3B0aW9ucykpLk1pbmltYXRjaDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgQVNUOiBjbGFzcyBBU1QgZXh0ZW5kcyBvcmlnLkFTVCB7XG4gICAgICAgICAgICAvKiBjOCBpZ25vcmUgc3RhcnQgKi9cbiAgICAgICAgICAgIGNvbnN0cnVjdG9yKHR5cGUsIHBhcmVudCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgICAgICAgICAgc3VwZXIodHlwZSwgcGFyZW50LCBleHQoZGVmLCBvcHRpb25zKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvKiBjOCBpZ25vcmUgc3RvcCAqL1xuICAgICAgICAgICAgc3RhdGljIGZyb21HbG9iKHBhdHRlcm4sIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBvcmlnLkFTVC5mcm9tR2xvYihwYXR0ZXJuLCBleHQoZGVmLCBvcHRpb25zKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHVuZXNjYXBlOiAocywgb3B0aW9ucyA9IHt9KSA9PiBvcmlnLnVuZXNjYXBlKHMsIGV4dChkZWYsIG9wdGlvbnMpKSxcbiAgICAgICAgZXNjYXBlOiAocywgb3B0aW9ucyA9IHt9KSA9PiBvcmlnLmVzY2FwZShzLCBleHQoZGVmLCBvcHRpb25zKSksXG4gICAgICAgIGZpbHRlcjogKHBhdHRlcm4sIG9wdGlvbnMgPSB7fSkgPT4gb3JpZy5maWx0ZXIocGF0dGVybiwgZXh0KGRlZiwgb3B0aW9ucykpLFxuICAgICAgICBkZWZhdWx0czogKG9wdGlvbnMpID0+IG9yaWcuZGVmYXVsdHMoZXh0KGRlZiwgb3B0aW9ucykpLFxuICAgICAgICBtYWtlUmU6IChwYXR0ZXJuLCBvcHRpb25zID0ge30pID0+IG9yaWcubWFrZVJlKHBhdHRlcm4sIGV4dChkZWYsIG9wdGlvbnMpKSxcbiAgICAgICAgYnJhY2VFeHBhbmQ6IChwYXR0ZXJuLCBvcHRpb25zID0ge30pID0+IG9yaWcuYnJhY2VFeHBhbmQocGF0dGVybiwgZXh0KGRlZiwgb3B0aW9ucykpLFxuICAgICAgICBtYXRjaDogKGxpc3QsIHBhdHRlcm4sIG9wdGlvbnMgPSB7fSkgPT4gb3JpZy5tYXRjaChsaXN0LCBwYXR0ZXJuLCBleHQoZGVmLCBvcHRpb25zKSksXG4gICAgICAgIHNlcDogb3JpZy5zZXAsXG4gICAgICAgIEdMT0JTVEFSOiBleHBvcnRzLkdMT0JTVEFSLFxuICAgIH0pO1xufTtcbmV4cG9ydHMuZGVmYXVsdHMgPSBkZWZhdWx0cztcbmV4cG9ydHMubWluaW1hdGNoLmRlZmF1bHRzID0gZXhwb3J0cy5kZWZhdWx0cztcbi8vIEJyYWNlIGV4cGFuc2lvbjpcbi8vIGF7YixjfWQgLT4gYWJkIGFjZFxuLy8gYXtiLH1jIC0+IGFiYyBhY1xuLy8gYXswLi4zfWQgLT4gYTBkIGExZCBhMmQgYTNkXG4vLyBhe2IsY3tkLGV9Zn1nIC0+IGFiZyBhY2RmZyBhY2VmZ1xuLy8gYXtiLGN9ZHtlLGZ9ZyAtPiBhYmRlZyBhY2RlZyBhYmRlZyBhYmRmZ1xuLy9cbi8vIEludmFsaWQgc2V0cyBhcmUgbm90IGV4cGFuZGVkLlxuLy8gYXsyLi59YiAtPiBhezIuLn1iXG4vLyBhe2J9YyAtPiBhe2J9Y1xuY29uc3QgYnJhY2VFeHBhbmQgPSAocGF0dGVybiwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgKDAsIGFzc2VydF92YWxpZF9wYXR0ZXJuX2pzXzEuYXNzZXJ0VmFsaWRQYXR0ZXJuKShwYXR0ZXJuKTtcbiAgICAvLyBUaGFua3MgdG8gWWV0aW5nIExpIDxodHRwczovL2dpdGh1Yi5jb20veWV0aW5nbGk+IGZvclxuICAgIC8vIGltcHJvdmluZyB0aGlzIHJlZ2V4cCB0byBhdm9pZCBhIFJlRE9TIHZ1bG5lcmFiaWxpdHkuXG4gICAgaWYgKG9wdGlvbnMubm9icmFjZSB8fCAhL1xceyg/Oig/IVxceykuKSpcXH0vLnRlc3QocGF0dGVybikpIHtcbiAgICAgICAgLy8gc2hvcnRjdXQuIG5vIG5lZWQgdG8gZXhwYW5kLlxuICAgICAgICByZXR1cm4gW3BhdHRlcm5dO1xuICAgIH1cbiAgICByZXR1cm4gKDAsIGJyYWNlX2V4cGFuc2lvbl8xLmRlZmF1bHQpKHBhdHRlcm4pO1xufTtcbmV4cG9ydHMuYnJhY2VFeHBhbmQgPSBicmFjZUV4cGFuZDtcbmV4cG9ydHMubWluaW1hdGNoLmJyYWNlRXhwYW5kID0gZXhwb3J0cy5icmFjZUV4cGFuZDtcbi8vIHBhcnNlIGEgY29tcG9uZW50IG9mIHRoZSBleHBhbmRlZCBzZXQuXG4vLyBBdCB0aGlzIHBvaW50LCBubyBwYXR0ZXJuIG1heSBjb250YWluIFwiL1wiIGluIGl0XG4vLyBzbyB3ZSdyZSBnb2luZyB0byByZXR1cm4gYSAyZCBhcnJheSwgd2hlcmUgZWFjaCBlbnRyeSBpcyB0aGUgZnVsbFxuLy8gcGF0dGVybiwgc3BsaXQgb24gJy8nLCBhbmQgdGhlbiB0dXJuZWQgaW50byBhIHJlZ3VsYXIgZXhwcmVzc2lvbi5cbi8vIEEgcmVnZXhwIGlzIG1hZGUgYXQgdGhlIGVuZCB3aGljaCBqb2lucyBlYWNoIGFycmF5IHdpdGggYW5cbi8vIGVzY2FwZWQgLywgYW5kIGFub3RoZXIgZnVsbCBvbmUgd2hpY2ggam9pbnMgZWFjaCByZWdleHAgd2l0aCB8LlxuLy9cbi8vIEZvbGxvd2luZyB0aGUgbGVhZCBvZiBCYXNoIDQuMSwgbm90ZSB0aGF0IFwiKipcIiBvbmx5IGhhcyBzcGVjaWFsIG1lYW5pbmdcbi8vIHdoZW4gaXQgaXMgdGhlICpvbmx5KiB0aGluZyBpbiBhIHBhdGggcG9ydGlvbi4gIE90aGVyd2lzZSwgYW55IHNlcmllc1xuLy8gb2YgKiBpcyBlcXVpdmFsZW50IHRvIGEgc2luZ2xlICouICBHbG9ic3RhciBiZWhhdmlvciBpcyBlbmFibGVkIGJ5XG4vLyBkZWZhdWx0LCBhbmQgY2FuIGJlIGRpc2FibGVkIGJ5IHNldHRpbmcgb3B0aW9ucy5ub2dsb2JzdGFyLlxuY29uc3QgbWFrZVJlID0gKHBhdHRlcm4sIG9wdGlvbnMgPSB7fSkgPT4gbmV3IE1pbmltYXRjaChwYXR0ZXJuLCBvcHRpb25zKS5tYWtlUmUoKTtcbmV4cG9ydHMubWFrZVJlID0gbWFrZVJlO1xuZXhwb3J0cy5taW5pbWF0Y2gubWFrZVJlID0gZXhwb3J0cy5tYWtlUmU7XG5jb25zdCBtYXRjaCA9IChsaXN0LCBwYXR0ZXJuLCBvcHRpb25zID0ge30pID0+IHtcbiAgICBjb25zdCBtbSA9IG5ldyBNaW5pbWF0Y2gocGF0dGVybiwgb3B0aW9ucyk7XG4gICAgbGlzdCA9IGxpc3QuZmlsdGVyKGYgPT4gbW0ubWF0Y2goZikpO1xuICAgIGlmIChtbS5vcHRpb25zLm5vbnVsbCAmJiAhbGlzdC5sZW5ndGgpIHtcbiAgICAgICAgbGlzdC5wdXNoKHBhdHRlcm4pO1xuICAgIH1cbiAgICByZXR1cm4gbGlzdDtcbn07XG5leHBvcnRzLm1hdGNoID0gbWF0Y2g7XG5leHBvcnRzLm1pbmltYXRjaC5tYXRjaCA9IGV4cG9ydHMubWF0Y2g7XG4vLyByZXBsYWNlIHN0dWZmIGxpa2UgXFwqIHdpdGggKlxuY29uc3QgZ2xvYk1hZ2ljID0gL1s/Kl18WytAIV1cXCguKj9cXCl8XFxbfFxcXS87XG5jb25zdCByZWdFeHBFc2NhcGUgPSAocykgPT4gcy5yZXBsYWNlKC9bLVtcXF17fSgpKis/LixcXFxcXiR8I1xcc10vZywgJ1xcXFwkJicpO1xuY2xhc3MgTWluaW1hdGNoIHtcbiAgICBvcHRpb25zO1xuICAgIHNldDtcbiAgICBwYXR0ZXJuO1xuICAgIHdpbmRvd3NQYXRoc05vRXNjYXBlO1xuICAgIG5vbmVnYXRlO1xuICAgIG5lZ2F0ZTtcbiAgICBjb21tZW50O1xuICAgIGVtcHR5O1xuICAgIHByZXNlcnZlTXVsdGlwbGVTbGFzaGVzO1xuICAgIHBhcnRpYWw7XG4gICAgZ2xvYlNldDtcbiAgICBnbG9iUGFydHM7XG4gICAgbm9jYXNlO1xuICAgIGlzV2luZG93cztcbiAgICBwbGF0Zm9ybTtcbiAgICB3aW5kb3dzTm9NYWdpY1Jvb3Q7XG4gICAgcmVnZXhwO1xuICAgIGNvbnN0cnVjdG9yKHBhdHRlcm4sIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICAoMCwgYXNzZXJ0X3ZhbGlkX3BhdHRlcm5fanNfMS5hc3NlcnRWYWxpZFBhdHRlcm4pKHBhdHRlcm4pO1xuICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgdGhpcy5wYXR0ZXJuID0gcGF0dGVybjtcbiAgICAgICAgdGhpcy5wbGF0Zm9ybSA9IG9wdGlvbnMucGxhdGZvcm0gfHwgZGVmYXVsdFBsYXRmb3JtO1xuICAgICAgICB0aGlzLmlzV2luZG93cyA9IHRoaXMucGxhdGZvcm0gPT09ICd3aW4zMic7XG4gICAgICAgIHRoaXMud2luZG93c1BhdGhzTm9Fc2NhcGUgPVxuICAgICAgICAgICAgISFvcHRpb25zLndpbmRvd3NQYXRoc05vRXNjYXBlIHx8IG9wdGlvbnMuYWxsb3dXaW5kb3dzRXNjYXBlID09PSBmYWxzZTtcbiAgICAgICAgaWYgKHRoaXMud2luZG93c1BhdGhzTm9Fc2NhcGUpIHtcbiAgICAgICAgICAgIHRoaXMucGF0dGVybiA9IHRoaXMucGF0dGVybi5yZXBsYWNlKC9cXFxcL2csICcvJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wcmVzZXJ2ZU11bHRpcGxlU2xhc2hlcyA9ICEhb3B0aW9ucy5wcmVzZXJ2ZU11bHRpcGxlU2xhc2hlcztcbiAgICAgICAgdGhpcy5yZWdleHAgPSBudWxsO1xuICAgICAgICB0aGlzLm5lZ2F0ZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLm5vbmVnYXRlID0gISFvcHRpb25zLm5vbmVnYXRlO1xuICAgICAgICB0aGlzLmNvbW1lbnQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5lbXB0eSA9IGZhbHNlO1xuICAgICAgICB0aGlzLnBhcnRpYWwgPSAhIW9wdGlvbnMucGFydGlhbDtcbiAgICAgICAgdGhpcy5ub2Nhc2UgPSAhIXRoaXMub3B0aW9ucy5ub2Nhc2U7XG4gICAgICAgIHRoaXMud2luZG93c05vTWFnaWNSb290ID1cbiAgICAgICAgICAgIG9wdGlvbnMud2luZG93c05vTWFnaWNSb290ICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICA/IG9wdGlvbnMud2luZG93c05vTWFnaWNSb290XG4gICAgICAgICAgICAgICAgOiAhISh0aGlzLmlzV2luZG93cyAmJiB0aGlzLm5vY2FzZSk7XG4gICAgICAgIHRoaXMuZ2xvYlNldCA9IFtdO1xuICAgICAgICB0aGlzLmdsb2JQYXJ0cyA9IFtdO1xuICAgICAgICB0aGlzLnNldCA9IFtdO1xuICAgICAgICAvLyBtYWtlIHRoZSBzZXQgb2YgcmVnZXhwcyBldGMuXG4gICAgICAgIHRoaXMubWFrZSgpO1xuICAgIH1cbiAgICBoYXNNYWdpYygpIHtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5tYWdpY2FsQnJhY2VzICYmIHRoaXMuc2V0Lmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgcGF0dGVybiBvZiB0aGlzLnNldCkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBwYXJ0IG9mIHBhdHRlcm4pIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHBhcnQgIT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGRlYnVnKC4uLl8pIHsgfVxuICAgIG1ha2UoKSB7XG4gICAgICAgIGNvbnN0IHBhdHRlcm4gPSB0aGlzLnBhdHRlcm47XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgICAgIC8vIGVtcHR5IHBhdHRlcm5zIGFuZCBjb21tZW50cyBtYXRjaCBub3RoaW5nLlxuICAgICAgICBpZiAoIW9wdGlvbnMubm9jb21tZW50ICYmIHBhdHRlcm4uY2hhckF0KDApID09PSAnIycpIHtcbiAgICAgICAgICAgIHRoaXMuY29tbWVudCA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFwYXR0ZXJuKSB7XG4gICAgICAgICAgICB0aGlzLmVtcHR5ID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBzdGVwIDE6IGZpZ3VyZSBvdXQgbmVnYXRpb24sIGV0Yy5cbiAgICAgICAgdGhpcy5wYXJzZU5lZ2F0ZSgpO1xuICAgICAgICAvLyBzdGVwIDI6IGV4cGFuZCBicmFjZXNcbiAgICAgICAgdGhpcy5nbG9iU2V0ID0gWy4uLm5ldyBTZXQodGhpcy5icmFjZUV4cGFuZCgpKV07XG4gICAgICAgIGlmIChvcHRpb25zLmRlYnVnKSB7XG4gICAgICAgICAgICB0aGlzLmRlYnVnID0gKC4uLmFyZ3MpID0+IGNvbnNvbGUuZXJyb3IoLi4uYXJncyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kZWJ1Zyh0aGlzLnBhdHRlcm4sIHRoaXMuZ2xvYlNldCk7XG4gICAgICAgIC8vIHN0ZXAgMzogbm93IHdlIGhhdmUgYSBzZXQsIHNvIHR1cm4gZWFjaCBvbmUgaW50byBhIHNlcmllcyBvZlxuICAgICAgICAvLyBwYXRoLXBvcnRpb24gbWF0Y2hpbmcgcGF0dGVybnMuXG4gICAgICAgIC8vIFRoZXNlIHdpbGwgYmUgcmVnZXhwcywgZXhjZXB0IGluIHRoZSBjYXNlIG9mIFwiKipcIiwgd2hpY2ggaXNcbiAgICAgICAgLy8gc2V0IHRvIHRoZSBHTE9CU1RBUiBvYmplY3QgZm9yIGdsb2JzdGFyIGJlaGF2aW9yLFxuICAgICAgICAvLyBhbmQgd2lsbCBub3QgY29udGFpbiBhbnkgLyBjaGFyYWN0ZXJzXG4gICAgICAgIC8vXG4gICAgICAgIC8vIEZpcnN0LCB3ZSBwcmVwcm9jZXNzIHRvIG1ha2UgdGhlIGdsb2IgcGF0dGVybiBzZXRzIGEgYml0IHNpbXBsZXJcbiAgICAgICAgLy8gYW5kIGRlZHVwZWQuICBUaGVyZSBhcmUgc29tZSBwZXJmLWtpbGxpbmcgcGF0dGVybnMgdGhhdCBjYW4gY2F1c2VcbiAgICAgICAgLy8gcHJvYmxlbXMgd2l0aCBhIGdsb2Igd2FsaywgYnV0IHdlIGNhbiBzaW1wbGlmeSB0aGVtIGRvd24gYSBiaXQuXG4gICAgICAgIGNvbnN0IHJhd0dsb2JQYXJ0cyA9IHRoaXMuZ2xvYlNldC5tYXAocyA9PiB0aGlzLnNsYXNoU3BsaXQocykpO1xuICAgICAgICB0aGlzLmdsb2JQYXJ0cyA9IHRoaXMucHJlcHJvY2VzcyhyYXdHbG9iUGFydHMpO1xuICAgICAgICB0aGlzLmRlYnVnKHRoaXMucGF0dGVybiwgdGhpcy5nbG9iUGFydHMpO1xuICAgICAgICAvLyBnbG9iIC0tPiByZWdleHBzXG4gICAgICAgIGxldCBzZXQgPSB0aGlzLmdsb2JQYXJ0cy5tYXAoKHMsIF8sIF9fKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5pc1dpbmRvd3MgJiYgdGhpcy53aW5kb3dzTm9NYWdpY1Jvb3QpIHtcbiAgICAgICAgICAgICAgICAvLyBjaGVjayBpZiBpdCdzIGEgZHJpdmUgb3IgdW5jIHBhdGguXG4gICAgICAgICAgICAgICAgY29uc3QgaXNVTkMgPSBzWzBdID09PSAnJyAmJlxuICAgICAgICAgICAgICAgICAgICBzWzFdID09PSAnJyAmJlxuICAgICAgICAgICAgICAgICAgICAoc1syXSA9PT0gJz8nIHx8ICFnbG9iTWFnaWMudGVzdChzWzJdKSkgJiZcbiAgICAgICAgICAgICAgICAgICAgIWdsb2JNYWdpYy50ZXN0KHNbM10pO1xuICAgICAgICAgICAgICAgIGNvbnN0IGlzRHJpdmUgPSAvXlthLXpdOi9pLnRlc3Qoc1swXSk7XG4gICAgICAgICAgICAgICAgaWYgKGlzVU5DKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbLi4ucy5zbGljZSgwLCA0KSwgLi4ucy5zbGljZSg0KS5tYXAoc3MgPT4gdGhpcy5wYXJzZShzcykpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoaXNEcml2ZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW3NbMF0sIC4uLnMuc2xpY2UoMSkubWFwKHNzID0+IHRoaXMucGFyc2Uoc3MpKV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHMubWFwKHNzID0+IHRoaXMucGFyc2Uoc3MpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuZGVidWcodGhpcy5wYXR0ZXJuLCBzZXQpO1xuICAgICAgICAvLyBmaWx0ZXIgb3V0IGV2ZXJ5dGhpbmcgdGhhdCBkaWRuJ3QgY29tcGlsZSBwcm9wZXJseS5cbiAgICAgICAgdGhpcy5zZXQgPSBzZXQuZmlsdGVyKHMgPT4gcy5pbmRleE9mKGZhbHNlKSA9PT0gLTEpO1xuICAgICAgICAvLyBkbyBub3QgdHJlYXQgdGhlID8gaW4gVU5DIHBhdGhzIGFzIG1hZ2ljXG4gICAgICAgIGlmICh0aGlzLmlzV2luZG93cykge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnNldC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHAgPSB0aGlzLnNldFtpXTtcbiAgICAgICAgICAgICAgICBpZiAocFswXSA9PT0gJycgJiZcbiAgICAgICAgICAgICAgICAgICAgcFsxXSA9PT0gJycgJiZcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5nbG9iUGFydHNbaV1bMl0gPT09ICc/JyAmJlxuICAgICAgICAgICAgICAgICAgICB0eXBlb2YgcFszXSA9PT0gJ3N0cmluZycgJiZcbiAgICAgICAgICAgICAgICAgICAgL15bYS16XTokL2kudGVzdChwWzNdKSkge1xuICAgICAgICAgICAgICAgICAgICBwWzJdID0gJz8nO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRlYnVnKHRoaXMucGF0dGVybiwgdGhpcy5zZXQpO1xuICAgIH1cbiAgICAvLyB2YXJpb3VzIHRyYW5zZm9ybXMgdG8gZXF1aXZhbGVudCBwYXR0ZXJuIHNldHMgdGhhdCBhcmVcbiAgICAvLyBmYXN0ZXIgdG8gcHJvY2VzcyBpbiBhIGZpbGVzeXN0ZW0gd2Fsay4gIFRoZSBnb2FsIGlzIHRvXG4gICAgLy8gZWxpbWluYXRlIHdoYXQgd2UgY2FuLCBhbmQgcHVzaCBhbGwgKiogcGF0dGVybnMgYXMgZmFyXG4gICAgLy8gdG8gdGhlIHJpZ2h0IGFzIHBvc3NpYmxlLCBldmVuIGlmIGl0IGluY3JlYXNlcyB0aGUgbnVtYmVyXG4gICAgLy8gb2YgcGF0dGVybnMgdGhhdCB3ZSBoYXZlIHRvIHByb2Nlc3MuXG4gICAgcHJlcHJvY2VzcyhnbG9iUGFydHMpIHtcbiAgICAgICAgLy8gaWYgd2UncmUgbm90IGluIGdsb2JzdGFyIG1vZGUsIHRoZW4gdHVybiBhbGwgKiogaW50byAqXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMubm9nbG9ic3Rhcikge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBnbG9iUGFydHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGdsb2JQYXJ0c1tpXS5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZ2xvYlBhcnRzW2ldW2pdID09PSAnKionKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBnbG9iUGFydHNbaV1bal0gPSAnKic7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBvcHRpbWl6YXRpb25MZXZlbCA9IDEgfSA9IHRoaXMub3B0aW9ucztcbiAgICAgICAgaWYgKG9wdGltaXphdGlvbkxldmVsID49IDIpIHtcbiAgICAgICAgICAgIC8vIGFnZ3Jlc3NpdmUgb3B0aW1pemF0aW9uIGZvciB0aGUgcHVycG9zZSBvZiBmcyB3YWxraW5nXG4gICAgICAgICAgICBnbG9iUGFydHMgPSB0aGlzLmZpcnN0UGhhc2VQcmVQcm9jZXNzKGdsb2JQYXJ0cyk7XG4gICAgICAgICAgICBnbG9iUGFydHMgPSB0aGlzLnNlY29uZFBoYXNlUHJlUHJvY2VzcyhnbG9iUGFydHMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG9wdGltaXphdGlvbkxldmVsID49IDEpIHtcbiAgICAgICAgICAgIC8vIGp1c3QgYmFzaWMgb3B0aW1pemF0aW9ucyB0byByZW1vdmUgc29tZSAuLiBwYXJ0c1xuICAgICAgICAgICAgZ2xvYlBhcnRzID0gdGhpcy5sZXZlbE9uZU9wdGltaXplKGdsb2JQYXJ0cyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBqdXN0IGNvbGxhcHNlIG11bHRpcGxlICoqIHBvcnRpb25zIGludG8gb25lXG4gICAgICAgICAgICBnbG9iUGFydHMgPSB0aGlzLmFkamFzY2VudEdsb2JzdGFyT3B0aW1pemUoZ2xvYlBhcnRzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZ2xvYlBhcnRzO1xuICAgIH1cbiAgICAvLyBqdXN0IGdldCByaWQgb2YgYWRqYXNjZW50ICoqIHBvcnRpb25zXG4gICAgYWRqYXNjZW50R2xvYnN0YXJPcHRpbWl6ZShnbG9iUGFydHMpIHtcbiAgICAgICAgcmV0dXJuIGdsb2JQYXJ0cy5tYXAocGFydHMgPT4ge1xuICAgICAgICAgICAgbGV0IGdzID0gLTE7XG4gICAgICAgICAgICB3aGlsZSAoLTEgIT09IChncyA9IHBhcnRzLmluZGV4T2YoJyoqJywgZ3MgKyAxKSkpIHtcbiAgICAgICAgICAgICAgICBsZXQgaSA9IGdzO1xuICAgICAgICAgICAgICAgIHdoaWxlIChwYXJ0c1tpICsgMV0gPT09ICcqKicpIHtcbiAgICAgICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaSAhPT0gZ3MpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFydHMuc3BsaWNlKGdzLCBpIC0gZ3MpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBwYXJ0cztcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8vIGdldCByaWQgb2YgYWRqYXNjZW50ICoqIGFuZCByZXNvbHZlIC4uIHBvcnRpb25zXG4gICAgbGV2ZWxPbmVPcHRpbWl6ZShnbG9iUGFydHMpIHtcbiAgICAgICAgcmV0dXJuIGdsb2JQYXJ0cy5tYXAocGFydHMgPT4ge1xuICAgICAgICAgICAgcGFydHMgPSBwYXJ0cy5yZWR1Y2UoKHNldCwgcGFydCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHByZXYgPSBzZXRbc2V0Lmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgICAgIGlmIChwYXJ0ID09PSAnKionICYmIHByZXYgPT09ICcqKicpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNldDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHBhcnQgPT09ICcuLicpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByZXYgJiYgcHJldiAhPT0gJy4uJyAmJiBwcmV2ICE9PSAnLicgJiYgcHJldiAhPT0gJyoqJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2V0LnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNldDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzZXQucHVzaChwYXJ0KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2V0O1xuICAgICAgICAgICAgfSwgW10pO1xuICAgICAgICAgICAgcmV0dXJuIHBhcnRzLmxlbmd0aCA9PT0gMCA/IFsnJ10gOiBwYXJ0cztcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGxldmVsVHdvRmlsZU9wdGltaXplKHBhcnRzKSB7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShwYXJ0cykpIHtcbiAgICAgICAgICAgIHBhcnRzID0gdGhpcy5zbGFzaFNwbGl0KHBhcnRzKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgZGlkU29tZXRoaW5nID0gZmFsc2U7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIGRpZFNvbWV0aGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgLy8gPHByZT4vPGU+LzxyZXN0PiAtPiA8cHJlPi88cmVzdD5cbiAgICAgICAgICAgIGlmICghdGhpcy5wcmVzZXJ2ZU11bHRpcGxlU2xhc2hlcykge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgcGFydHMubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHAgPSBwYXJ0c1tpXTtcbiAgICAgICAgICAgICAgICAgICAgLy8gZG9uJ3Qgc3F1ZWV6ZSBvdXQgVU5DIHBhdHRlcm5zXG4gICAgICAgICAgICAgICAgICAgIGlmIChpID09PSAxICYmIHAgPT09ICcnICYmIHBhcnRzWzBdID09PSAnJylcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICBpZiAocCA9PT0gJy4nIHx8IHAgPT09ICcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkaWRTb21ldGhpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFydHMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaS0tO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChwYXJ0c1swXSA9PT0gJy4nICYmXG4gICAgICAgICAgICAgICAgICAgIHBhcnRzLmxlbmd0aCA9PT0gMiAmJlxuICAgICAgICAgICAgICAgICAgICAocGFydHNbMV0gPT09ICcuJyB8fCBwYXJ0c1sxXSA9PT0gJycpKSB7XG4gICAgICAgICAgICAgICAgICAgIGRpZFNvbWV0aGluZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHBhcnRzLnBvcCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIDxwcmU+LzxwPi8uLi88cmVzdD4gLT4gPHByZT4vPHJlc3Q+XG4gICAgICAgICAgICBsZXQgZGQgPSAwO1xuICAgICAgICAgICAgd2hpbGUgKC0xICE9PSAoZGQgPSBwYXJ0cy5pbmRleE9mKCcuLicsIGRkICsgMSkpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcCA9IHBhcnRzW2RkIC0gMV07XG4gICAgICAgICAgICAgICAgaWYgKHAgJiYgcCAhPT0gJy4nICYmIHAgIT09ICcuLicgJiYgcCAhPT0gJyoqJykge1xuICAgICAgICAgICAgICAgICAgICBkaWRTb21ldGhpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBwYXJ0cy5zcGxpY2UoZGQgLSAxLCAyKTtcbiAgICAgICAgICAgICAgICAgICAgZGQgLT0gMjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gd2hpbGUgKGRpZFNvbWV0aGluZyk7XG4gICAgICAgIHJldHVybiBwYXJ0cy5sZW5ndGggPT09IDAgPyBbJyddIDogcGFydHM7XG4gICAgfVxuICAgIC8vIEZpcnN0IHBoYXNlOiBzaW5nbGUtcGF0dGVybiBwcm9jZXNzaW5nXG4gICAgLy8gPHByZT4gaXMgMSBvciBtb3JlIHBvcnRpb25zXG4gICAgLy8gPHJlc3Q+IGlzIDEgb3IgbW9yZSBwb3J0aW9uc1xuICAgIC8vIDxwPiBpcyBhbnkgcG9ydGlvbiBvdGhlciB0aGFuIC4sIC4uLCAnJywgb3IgKipcbiAgICAvLyA8ZT4gaXMgLiBvciAnJ1xuICAgIC8vXG4gICAgLy8gKiovLi4gaXMgKmJydXRhbCogZm9yIGZpbGVzeXN0ZW0gd2Fsa2luZyBwZXJmb3JtYW5jZSwgYmVjYXVzZVxuICAgIC8vIGl0IGVmZmVjdGl2ZWx5IHJlc2V0cyB0aGUgcmVjdXJzaXZlIHdhbGsgZWFjaCB0aW1lIGl0IG9jY3VycyxcbiAgICAvLyBhbmQgKiogY2Fubm90IGJlIHJlZHVjZWQgb3V0IGJ5IGEgLi4gcGF0dGVybiBwYXJ0IGxpa2UgYSByZWdleHBcbiAgICAvLyBvciBtb3N0IHN0cmluZ3MgKG90aGVyIHRoYW4gLi4sIC4sIGFuZCAnJykgY2FuIGJlLlxuICAgIC8vXG4gICAgLy8gPHByZT4vKiovLi4vPHA+LzxwPi88cmVzdD4gLT4gezxwcmU+Ly4uLzxwPi88cD4vPHJlc3Q+LDxwcmU+LyoqLzxwPi88cD4vPHJlc3Q+fVxuICAgIC8vIDxwcmU+LzxlPi88cmVzdD4gLT4gPHByZT4vPHJlc3Q+XG4gICAgLy8gPHByZT4vPHA+Ly4uLzxyZXN0PiAtPiA8cHJlPi88cmVzdD5cbiAgICAvLyAqKi8qKi88cmVzdD4gLT4gKiovPHJlc3Q+XG4gICAgLy9cbiAgICAvLyAqKi8qLzxyZXN0PiAtPiAqLyoqLzxyZXN0PiA8PT0gbm90IHZhbGlkIGJlY2F1c2UgKiogZG9lc24ndCBmb2xsb3dcbiAgICAvLyB0aGlzIFdPVUxEIGJlIGFsbG93ZWQgaWYgKiogZGlkIGZvbGxvdyBzeW1saW5rcywgb3IgKiBkaWRuJ3RcbiAgICBmaXJzdFBoYXNlUHJlUHJvY2VzcyhnbG9iUGFydHMpIHtcbiAgICAgICAgbGV0IGRpZFNvbWV0aGluZyA9IGZhbHNlO1xuICAgICAgICBkbyB7XG4gICAgICAgICAgICBkaWRTb21ldGhpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIC8vIDxwcmU+LyoqLy4uLzxwPi88cD4vPHJlc3Q+IC0+IHs8cHJlPi8uLi88cD4vPHA+LzxyZXN0Piw8cHJlPi8qKi88cD4vPHA+LzxyZXN0Pn1cbiAgICAgICAgICAgIGZvciAobGV0IHBhcnRzIG9mIGdsb2JQYXJ0cykge1xuICAgICAgICAgICAgICAgIGxldCBncyA9IC0xO1xuICAgICAgICAgICAgICAgIHdoaWxlICgtMSAhPT0gKGdzID0gcGFydHMuaW5kZXhPZignKionLCBncyArIDEpKSkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgZ3NzID0gZ3M7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChwYXJ0c1tnc3MgKyAxXSA9PT0gJyoqJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gPHByZT4vKiovKiovPHJlc3Q+IC0+IDxwcmU+LyoqLzxyZXN0PlxuICAgICAgICAgICAgICAgICAgICAgICAgZ3NzKys7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gZWcsIGlmIGdzIGlzIDIgYW5kIGdzcyBpcyA0LCB0aGF0IG1lYW5zIHdlIGhhdmUgMyAqKlxuICAgICAgICAgICAgICAgICAgICAvLyBwYXJ0cywgYW5kIGNhbiByZW1vdmUgMiBvZiB0aGVtLlxuICAgICAgICAgICAgICAgICAgICBpZiAoZ3NzID4gZ3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnRzLnNwbGljZShncyArIDEsIGdzcyAtIGdzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBsZXQgbmV4dCA9IHBhcnRzW2dzICsgMV07XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHAgPSBwYXJ0c1tncyArIDJdO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwMiA9IHBhcnRzW2dzICsgM107XG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXh0ICE9PSAnLi4nKVxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIGlmICghcCB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgcCA9PT0gJy4nIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBwID09PSAnLi4nIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAhcDIgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIHAyID09PSAnLicgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIHAyID09PSAnLi4nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBkaWRTb21ldGhpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAvLyBlZGl0IHBhcnRzIGluIHBsYWNlLCBhbmQgcHVzaCB0aGUgbmV3IG9uZVxuICAgICAgICAgICAgICAgICAgICBwYXJ0cy5zcGxpY2UoZ3MsIDEpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBvdGhlciA9IHBhcnRzLnNsaWNlKDApO1xuICAgICAgICAgICAgICAgICAgICBvdGhlcltnc10gPSAnKionO1xuICAgICAgICAgICAgICAgICAgICBnbG9iUGFydHMucHVzaChvdGhlcik7XG4gICAgICAgICAgICAgICAgICAgIGdzLS07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIDxwcmU+LzxlPi88cmVzdD4gLT4gPHByZT4vPHJlc3Q+XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLnByZXNlcnZlTXVsdGlwbGVTbGFzaGVzKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgcGFydHMubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwID0gcGFydHNbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBkb24ndCBzcXVlZXplIG91dCBVTkMgcGF0dGVybnNcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpID09PSAxICYmIHAgPT09ICcnICYmIHBhcnRzWzBdID09PSAnJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwID09PSAnLicgfHwgcCA9PT0gJycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaWRTb21ldGhpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnRzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpLS07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhcnRzWzBdID09PSAnLicgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnRzLmxlbmd0aCA9PT0gMiAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgKHBhcnRzWzFdID09PSAnLicgfHwgcGFydHNbMV0gPT09ICcnKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGlkU29tZXRoaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnRzLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIDxwcmU+LzxwPi8uLi88cmVzdD4gLT4gPHByZT4vPHJlc3Q+XG4gICAgICAgICAgICAgICAgbGV0IGRkID0gMDtcbiAgICAgICAgICAgICAgICB3aGlsZSAoLTEgIT09IChkZCA9IHBhcnRzLmluZGV4T2YoJy4uJywgZGQgKyAxKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcCA9IHBhcnRzW2RkIC0gMV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChwICYmIHAgIT09ICcuJyAmJiBwICE9PSAnLi4nICYmIHAgIT09ICcqKicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpZFNvbWV0aGluZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBuZWVkRG90ID0gZGQgPT09IDEgJiYgcGFydHNbZGQgKyAxXSA9PT0gJyoqJztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHNwbGluID0gbmVlZERvdCA/IFsnLiddIDogW107XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJ0cy5zcGxpY2UoZGQgLSAxLCAyLCAuLi5zcGxpbik7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocGFydHMubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnRzLnB1c2goJycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGQgLT0gMjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSB3aGlsZSAoZGlkU29tZXRoaW5nKTtcbiAgICAgICAgcmV0dXJuIGdsb2JQYXJ0cztcbiAgICB9XG4gICAgLy8gc2Vjb25kIHBoYXNlOiBtdWx0aS1wYXR0ZXJuIGRlZHVwZXNcbiAgICAvLyB7PHByZT4vKi88cmVzdD4sPHByZT4vPHA+LzxyZXN0Pn0gLT4gPHByZT4vKi88cmVzdD5cbiAgICAvLyB7PHByZT4vPHJlc3Q+LDxwcmU+LzxyZXN0Pn0gLT4gPHByZT4vPHJlc3Q+XG4gICAgLy8gezxwcmU+LyoqLzxyZXN0Piw8cHJlPi88cmVzdD59IC0+IDxwcmU+LyoqLzxyZXN0PlxuICAgIC8vXG4gICAgLy8gezxwcmU+LyoqLzxyZXN0Piw8cHJlPi8qKi88cD4vPHJlc3Q+fSAtPiA8cHJlPi8qKi88cmVzdD5cbiAgICAvLyBeLS0gbm90IHZhbGlkIGJlY2F1c2UgKiogZG9lbnMndCBmb2xsb3cgc3ltbGlua3NcbiAgICBzZWNvbmRQaGFzZVByZVByb2Nlc3MoZ2xvYlBhcnRzKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZ2xvYlBhcnRzLmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgICAgICAgZm9yIChsZXQgaiA9IGkgKyAxOyBqIDwgZ2xvYlBhcnRzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbWF0Y2hlZCA9IHRoaXMucGFydHNNYXRjaChnbG9iUGFydHNbaV0sIGdsb2JQYXJ0c1tqXSwgIXRoaXMucHJlc2VydmVNdWx0aXBsZVNsYXNoZXMpO1xuICAgICAgICAgICAgICAgIGlmIChtYXRjaGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGdsb2JQYXJ0c1tpXSA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBnbG9iUGFydHNbal0gPSBtYXRjaGVkO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGdsb2JQYXJ0cy5maWx0ZXIoZ3MgPT4gZ3MubGVuZ3RoKTtcbiAgICB9XG4gICAgcGFydHNNYXRjaChhLCBiLCBlbXB0eUdTTWF0Y2ggPSBmYWxzZSkge1xuICAgICAgICBsZXQgYWkgPSAwO1xuICAgICAgICBsZXQgYmkgPSAwO1xuICAgICAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgICAgIGxldCB3aGljaCA9ICcnO1xuICAgICAgICB3aGlsZSAoYWkgPCBhLmxlbmd0aCAmJiBiaSA8IGIubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoYVthaV0gPT09IGJbYmldKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2god2hpY2ggPT09ICdiJyA/IGJbYmldIDogYVthaV0pO1xuICAgICAgICAgICAgICAgIGFpKys7XG4gICAgICAgICAgICAgICAgYmkrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGVtcHR5R1NNYXRjaCAmJiBhW2FpXSA9PT0gJyoqJyAmJiBiW2JpXSA9PT0gYVthaSArIDFdKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goYVthaV0pO1xuICAgICAgICAgICAgICAgIGFpKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChlbXB0eUdTTWF0Y2ggJiYgYltiaV0gPT09ICcqKicgJiYgYVthaV0gPT09IGJbYmkgKyAxXSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGJbYmldKTtcbiAgICAgICAgICAgICAgICBiaSsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYVthaV0gPT09ICcqJyAmJlxuICAgICAgICAgICAgICAgIGJbYmldICYmXG4gICAgICAgICAgICAgICAgKHRoaXMub3B0aW9ucy5kb3QgfHwgIWJbYmldLnN0YXJ0c1dpdGgoJy4nKSkgJiZcbiAgICAgICAgICAgICAgICBiW2JpXSAhPT0gJyoqJykge1xuICAgICAgICAgICAgICAgIGlmICh3aGljaCA9PT0gJ2InKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgd2hpY2ggPSAnYSc7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goYVthaV0pO1xuICAgICAgICAgICAgICAgIGFpKys7XG4gICAgICAgICAgICAgICAgYmkrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGJbYmldID09PSAnKicgJiZcbiAgICAgICAgICAgICAgICBhW2FpXSAmJlxuICAgICAgICAgICAgICAgICh0aGlzLm9wdGlvbnMuZG90IHx8ICFhW2FpXS5zdGFydHNXaXRoKCcuJykpICYmXG4gICAgICAgICAgICAgICAgYVthaV0gIT09ICcqKicpIHtcbiAgICAgICAgICAgICAgICBpZiAod2hpY2ggPT09ICdhJylcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIHdoaWNoID0gJ2InO1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGJbYmldKTtcbiAgICAgICAgICAgICAgICBhaSsrO1xuICAgICAgICAgICAgICAgIGJpKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gaWYgd2UgZmFsbCBvdXQgb2YgdGhlIGxvb3AsIGl0IG1lYW5zIHRoZXkgdHdvIGFyZSBpZGVudGljYWxcbiAgICAgICAgLy8gYXMgbG9uZyBhcyB0aGVpciBsZW5ndGhzIG1hdGNoXG4gICAgICAgIHJldHVybiBhLmxlbmd0aCA9PT0gYi5sZW5ndGggJiYgcmVzdWx0O1xuICAgIH1cbiAgICBwYXJzZU5lZ2F0ZSgpIHtcbiAgICAgICAgaWYgKHRoaXMubm9uZWdhdGUpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IHBhdHRlcm4gPSB0aGlzLnBhdHRlcm47XG4gICAgICAgIGxldCBuZWdhdGUgPSBmYWxzZTtcbiAgICAgICAgbGV0IG5lZ2F0ZU9mZnNldCA9IDA7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGF0dGVybi5sZW5ndGggJiYgcGF0dGVybi5jaGFyQXQoaSkgPT09ICchJzsgaSsrKSB7XG4gICAgICAgICAgICBuZWdhdGUgPSAhbmVnYXRlO1xuICAgICAgICAgICAgbmVnYXRlT2Zmc2V0Kys7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5lZ2F0ZU9mZnNldClcbiAgICAgICAgICAgIHRoaXMucGF0dGVybiA9IHBhdHRlcm4uc2xpY2UobmVnYXRlT2Zmc2V0KTtcbiAgICAgICAgdGhpcy5uZWdhdGUgPSBuZWdhdGU7XG4gICAgfVxuICAgIC8vIHNldCBwYXJ0aWFsIHRvIHRydWUgdG8gdGVzdCBpZiwgZm9yIGV4YW1wbGUsXG4gICAgLy8gXCIvYS9iXCIgbWF0Y2hlcyB0aGUgc3RhcnQgb2YgXCIvKi9iLyovZFwiXG4gICAgLy8gUGFydGlhbCBtZWFucywgaWYgeW91IHJ1biBvdXQgb2YgZmlsZSBiZWZvcmUgeW91IHJ1blxuICAgIC8vIG91dCBvZiBwYXR0ZXJuLCB0aGVuIHRoYXQncyBmaW5lLCBhcyBsb25nIGFzIGFsbFxuICAgIC8vIHRoZSBwYXJ0cyBtYXRjaC5cbiAgICBtYXRjaE9uZShmaWxlLCBwYXR0ZXJuLCBwYXJ0aWFsID0gZmFsc2UpIHtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICAgICAgLy8gVU5DIHBhdGhzIGxpa2UgLy8/L1g6Ly4uLiBjYW4gbWF0Y2ggWDovLi4uIGFuZCB2aWNlIHZlcnNhXG4gICAgICAgIC8vIERyaXZlIGxldHRlcnMgaW4gYWJzb2x1dGUgZHJpdmUgb3IgdW5jIHBhdGhzIGFyZSBhbHdheXMgY29tcGFyZWRcbiAgICAgICAgLy8gY2FzZS1pbnNlbnNpdGl2ZWx5LlxuICAgICAgICBpZiAodGhpcy5pc1dpbmRvd3MpIHtcbiAgICAgICAgICAgIGNvbnN0IGZpbGVEcml2ZSA9IHR5cGVvZiBmaWxlWzBdID09PSAnc3RyaW5nJyAmJiAvXlthLXpdOiQvaS50ZXN0KGZpbGVbMF0pO1xuICAgICAgICAgICAgY29uc3QgZmlsZVVOQyA9ICFmaWxlRHJpdmUgJiZcbiAgICAgICAgICAgICAgICBmaWxlWzBdID09PSAnJyAmJlxuICAgICAgICAgICAgICAgIGZpbGVbMV0gPT09ICcnICYmXG4gICAgICAgICAgICAgICAgZmlsZVsyXSA9PT0gJz8nICYmXG4gICAgICAgICAgICAgICAgL15bYS16XTokL2kudGVzdChmaWxlWzNdKTtcbiAgICAgICAgICAgIGNvbnN0IHBhdHRlcm5Ecml2ZSA9IHR5cGVvZiBwYXR0ZXJuWzBdID09PSAnc3RyaW5nJyAmJiAvXlthLXpdOiQvaS50ZXN0KHBhdHRlcm5bMF0pO1xuICAgICAgICAgICAgY29uc3QgcGF0dGVyblVOQyA9ICFwYXR0ZXJuRHJpdmUgJiZcbiAgICAgICAgICAgICAgICBwYXR0ZXJuWzBdID09PSAnJyAmJlxuICAgICAgICAgICAgICAgIHBhdHRlcm5bMV0gPT09ICcnICYmXG4gICAgICAgICAgICAgICAgcGF0dGVyblsyXSA9PT0gJz8nICYmXG4gICAgICAgICAgICAgICAgdHlwZW9mIHBhdHRlcm5bM10gPT09ICdzdHJpbmcnICYmXG4gICAgICAgICAgICAgICAgL15bYS16XTokL2kudGVzdChwYXR0ZXJuWzNdKTtcbiAgICAgICAgICAgIGNvbnN0IGZkaSA9IGZpbGVVTkMgPyAzIDogZmlsZURyaXZlID8gMCA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGNvbnN0IHBkaSA9IHBhdHRlcm5VTkMgPyAzIDogcGF0dGVybkRyaXZlID8gMCA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZmRpID09PSAnbnVtYmVyJyAmJiB0eXBlb2YgcGRpID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgIGNvbnN0IFtmZCwgcGRdID0gW2ZpbGVbZmRpXSwgcGF0dGVybltwZGldXTtcbiAgICAgICAgICAgICAgICBpZiAoZmQudG9Mb3dlckNhc2UoKSA9PT0gcGQudG9Mb3dlckNhc2UoKSkge1xuICAgICAgICAgICAgICAgICAgICBwYXR0ZXJuW3BkaV0gPSBmZDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBkaSA+IGZkaSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGF0dGVybiA9IHBhdHRlcm4uc2xpY2UocGRpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChmZGkgPiBwZGkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbGUgPSBmaWxlLnNsaWNlKGZkaSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gcmVzb2x2ZSBhbmQgcmVkdWNlIC4gYW5kIC4uIHBvcnRpb25zIGluIHRoZSBmaWxlIGFzIHdlbGwuXG4gICAgICAgIC8vIGRvbnQnIG5lZWQgdG8gZG8gdGhlIHNlY29uZCBwaGFzZSwgYmVjYXVzZSBpdCdzIG9ubHkgb25lIHN0cmluZ1tdXG4gICAgICAgIGNvbnN0IHsgb3B0aW1pemF0aW9uTGV2ZWwgPSAxIH0gPSB0aGlzLm9wdGlvbnM7XG4gICAgICAgIGlmIChvcHRpbWl6YXRpb25MZXZlbCA+PSAyKSB7XG4gICAgICAgICAgICBmaWxlID0gdGhpcy5sZXZlbFR3b0ZpbGVPcHRpbWl6ZShmaWxlKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRlYnVnKCdtYXRjaE9uZScsIHRoaXMsIHsgZmlsZSwgcGF0dGVybiB9KTtcbiAgICAgICAgdGhpcy5kZWJ1ZygnbWF0Y2hPbmUnLCBmaWxlLmxlbmd0aCwgcGF0dGVybi5sZW5ndGgpO1xuICAgICAgICBmb3IgKHZhciBmaSA9IDAsIHBpID0gMCwgZmwgPSBmaWxlLmxlbmd0aCwgcGwgPSBwYXR0ZXJuLmxlbmd0aDsgZmkgPCBmbCAmJiBwaSA8IHBsOyBmaSsrLCBwaSsrKSB7XG4gICAgICAgICAgICB0aGlzLmRlYnVnKCdtYXRjaE9uZSBsb29wJyk7XG4gICAgICAgICAgICB2YXIgcCA9IHBhdHRlcm5bcGldO1xuICAgICAgICAgICAgdmFyIGYgPSBmaWxlW2ZpXTtcbiAgICAgICAgICAgIHRoaXMuZGVidWcocGF0dGVybiwgcCwgZik7XG4gICAgICAgICAgICAvLyBzaG91bGQgYmUgaW1wb3NzaWJsZS5cbiAgICAgICAgICAgIC8vIHNvbWUgaW52YWxpZCByZWdleHAgc3R1ZmYgaW4gdGhlIHNldC5cbiAgICAgICAgICAgIC8qIGM4IGlnbm9yZSBzdGFydCAqL1xuICAgICAgICAgICAgaWYgKHAgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLyogYzggaWdub3JlIHN0b3AgKi9cbiAgICAgICAgICAgIGlmIChwID09PSBleHBvcnRzLkdMT0JTVEFSKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kZWJ1ZygnR0xPQlNUQVInLCBbcGF0dGVybiwgcCwgZl0pO1xuICAgICAgICAgICAgICAgIC8vIFwiKipcIlxuICAgICAgICAgICAgICAgIC8vIGEvKiovYi8qKi9jIHdvdWxkIG1hdGNoIHRoZSBmb2xsb3dpbmc6XG4gICAgICAgICAgICAgICAgLy8gYS9iL3gveS96L2NcbiAgICAgICAgICAgICAgICAvLyBhL3gveS96L2IvY1xuICAgICAgICAgICAgICAgIC8vIGEvYi94L2IveC9jXG4gICAgICAgICAgICAgICAgLy8gYS9iL2NcbiAgICAgICAgICAgICAgICAvLyBUbyBkbyB0aGlzLCB0YWtlIHRoZSByZXN0IG9mIHRoZSBwYXR0ZXJuIGFmdGVyXG4gICAgICAgICAgICAgICAgLy8gdGhlICoqLCBhbmQgc2VlIGlmIGl0IHdvdWxkIG1hdGNoIHRoZSBmaWxlIHJlbWFpbmRlci5cbiAgICAgICAgICAgICAgICAvLyBJZiBzbywgcmV0dXJuIHN1Y2Nlc3MuXG4gICAgICAgICAgICAgICAgLy8gSWYgbm90LCB0aGUgKiogXCJzd2FsbG93c1wiIGEgc2VnbWVudCwgYW5kIHRyeSBhZ2Fpbi5cbiAgICAgICAgICAgICAgICAvLyBUaGlzIGlzIHJlY3Vyc2l2ZWx5IGF3ZnVsLlxuICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgLy8gYS8qKi9iLyoqL2MgbWF0Y2hpbmcgYS9iL3gveS96L2NcbiAgICAgICAgICAgICAgICAvLyAtIGEgbWF0Y2hlcyBhXG4gICAgICAgICAgICAgICAgLy8gLSBkb3VibGVzdGFyXG4gICAgICAgICAgICAgICAgLy8gICAtIG1hdGNoT25lKGIveC95L3ovYywgYi8qKi9jKVxuICAgICAgICAgICAgICAgIC8vICAgICAtIGIgbWF0Y2hlcyBiXG4gICAgICAgICAgICAgICAgLy8gICAgIC0gZG91Ymxlc3RhclxuICAgICAgICAgICAgICAgIC8vICAgICAgIC0gbWF0Y2hPbmUoeC95L3ovYywgYykgLT4gbm9cbiAgICAgICAgICAgICAgICAvLyAgICAgICAtIG1hdGNoT25lKHkvei9jLCBjKSAtPiBub1xuICAgICAgICAgICAgICAgIC8vICAgICAgIC0gbWF0Y2hPbmUoei9jLCBjKSAtPiBub1xuICAgICAgICAgICAgICAgIC8vICAgICAgIC0gbWF0Y2hPbmUoYywgYykgeWVzLCBoaXRcbiAgICAgICAgICAgICAgICB2YXIgZnIgPSBmaTtcbiAgICAgICAgICAgICAgICB2YXIgcHIgPSBwaSArIDE7XG4gICAgICAgICAgICAgICAgaWYgKHByID09PSBwbCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRlYnVnKCcqKiBhdCB0aGUgZW5kJyk7XG4gICAgICAgICAgICAgICAgICAgIC8vIGEgKiogYXQgdGhlIGVuZCB3aWxsIGp1c3Qgc3dhbGxvdyB0aGUgcmVzdC5cbiAgICAgICAgICAgICAgICAgICAgLy8gV2UgaGF2ZSBmb3VuZCBhIG1hdGNoLlxuICAgICAgICAgICAgICAgICAgICAvLyBob3dldmVyLCBpdCB3aWxsIG5vdCBzd2FsbG93IC8ueCwgdW5sZXNzXG4gICAgICAgICAgICAgICAgICAgIC8vIG9wdGlvbnMuZG90IGlzIHNldC5cbiAgICAgICAgICAgICAgICAgICAgLy8gLiBhbmQgLi4gYXJlICpuZXZlciogbWF0Y2hlZCBieSAqKiwgZm9yIGV4cGxvc2l2ZWx5XG4gICAgICAgICAgICAgICAgICAgIC8vIGV4cG9uZW50aWFsIHJlYXNvbnMuXG4gICAgICAgICAgICAgICAgICAgIGZvciAoOyBmaSA8IGZsOyBmaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZmlsZVtmaV0gPT09ICcuJyB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbGVbZmldID09PSAnLi4nIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKCFvcHRpb25zLmRvdCAmJiBmaWxlW2ZpXS5jaGFyQXQoMCkgPT09ICcuJykpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBvaywgbGV0J3Mgc2VlIGlmIHdlIGNhbiBzd2FsbG93IHdoYXRldmVyIHdlIGNhbi5cbiAgICAgICAgICAgICAgICB3aGlsZSAoZnIgPCBmbCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc3dhbGxvd2VlID0gZmlsZVtmcl07XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGVidWcoJ1xcbmdsb2JzdGFyIHdoaWxlJywgZmlsZSwgZnIsIHBhdHRlcm4sIHByLCBzd2FsbG93ZWUpO1xuICAgICAgICAgICAgICAgICAgICAvLyBYWFggcmVtb3ZlIHRoaXMgc2xpY2UuICBKdXN0IHBhc3MgdGhlIHN0YXJ0IGluZGV4LlxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5tYXRjaE9uZShmaWxlLnNsaWNlKGZyKSwgcGF0dGVybi5zbGljZShwciksIHBhcnRpYWwpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRlYnVnKCdnbG9ic3RhciBmb3VuZCBtYXRjaCEnLCBmciwgZmwsIHN3YWxsb3dlZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBmb3VuZCBhIG1hdGNoLlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjYW4ndCBzd2FsbG93IFwiLlwiIG9yIFwiLi5cIiBldmVyLlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2FuIG9ubHkgc3dhbGxvdyBcIi5mb29cIiB3aGVuIGV4cGxpY2l0bHkgYXNrZWQuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3dhbGxvd2VlID09PSAnLicgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzd2FsbG93ZWUgPT09ICcuLicgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoIW9wdGlvbnMuZG90ICYmIHN3YWxsb3dlZS5jaGFyQXQoMCkgPT09ICcuJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRlYnVnKCdkb3QgZGV0ZWN0ZWQhJywgZmlsZSwgZnIsIHBhdHRlcm4sIHByKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICoqIHN3YWxsb3dzIGEgc2VnbWVudCwgYW5kIGNvbnRpbnVlLlxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kZWJ1ZygnZ2xvYnN0YXIgc3dhbGxvdyBhIHNlZ21lbnQsIGFuZCBjb250aW51ZScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZnIrKztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBubyBtYXRjaCB3YXMgZm91bmQuXG4gICAgICAgICAgICAgICAgLy8gSG93ZXZlciwgaW4gcGFydGlhbCBtb2RlLCB3ZSBjYW4ndCBzYXkgdGhpcyBpcyBuZWNlc3NhcmlseSBvdmVyLlxuICAgICAgICAgICAgICAgIC8qIGM4IGlnbm9yZSBzdGFydCAqL1xuICAgICAgICAgICAgICAgIGlmIChwYXJ0aWFsKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHJhbiBvdXQgb2YgZmlsZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRlYnVnKCdcXG4+Pj4gbm8gbWF0Y2gsIHBhcnRpYWw/JywgZmlsZSwgZnIsIHBhdHRlcm4sIHByKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZyID09PSBmbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLyogYzggaWdub3JlIHN0b3AgKi9cbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBzb21ldGhpbmcgb3RoZXIgdGhhbiAqKlxuICAgICAgICAgICAgLy8gbm9uLW1hZ2ljIHBhdHRlcm5zIGp1c3QgaGF2ZSB0byBtYXRjaCBleGFjdGx5XG4gICAgICAgICAgICAvLyBwYXR0ZXJucyB3aXRoIG1hZ2ljIGhhdmUgYmVlbiB0dXJuZWQgaW50byByZWdleHBzLlxuICAgICAgICAgICAgbGV0IGhpdDtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBoaXQgPSBmID09PSBwO1xuICAgICAgICAgICAgICAgIHRoaXMuZGVidWcoJ3N0cmluZyBtYXRjaCcsIHAsIGYsIGhpdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBoaXQgPSBwLnRlc3QoZik7XG4gICAgICAgICAgICAgICAgdGhpcy5kZWJ1ZygncGF0dGVybiBtYXRjaCcsIHAsIGYsIGhpdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWhpdClcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTm90ZTogZW5kaW5nIGluIC8gbWVhbnMgdGhhdCB3ZSdsbCBnZXQgYSBmaW5hbCBcIlwiXG4gICAgICAgIC8vIGF0IHRoZSBlbmQgb2YgdGhlIHBhdHRlcm4uICBUaGlzIGNhbiBvbmx5IG1hdGNoIGFcbiAgICAgICAgLy8gY29ycmVzcG9uZGluZyBcIlwiIGF0IHRoZSBlbmQgb2YgdGhlIGZpbGUuXG4gICAgICAgIC8vIElmIHRoZSBmaWxlIGVuZHMgaW4gLywgdGhlbiBpdCBjYW4gb25seSBtYXRjaCBhXG4gICAgICAgIC8vIGEgcGF0dGVybiB0aGF0IGVuZHMgaW4gLywgdW5sZXNzIHRoZSBwYXR0ZXJuIGp1c3RcbiAgICAgICAgLy8gZG9lc24ndCBoYXZlIGFueSBtb3JlIGZvciBpdC4gQnV0LCBhL2IvIHNob3VsZCAqbm90KlxuICAgICAgICAvLyBtYXRjaCBcImEvYi8qXCIsIGV2ZW4gdGhvdWdoIFwiXCIgbWF0Y2hlcyBhZ2FpbnN0IHRoZVxuICAgICAgICAvLyBbXi9dKj8gcGF0dGVybiwgZXhjZXB0IGluIHBhcnRpYWwgbW9kZSwgd2hlcmUgaXQgbWlnaHRcbiAgICAgICAgLy8gc2ltcGx5IG5vdCBiZSByZWFjaGVkIHlldC5cbiAgICAgICAgLy8gSG93ZXZlciwgYS9iLyBzaG91bGQgc3RpbGwgc2F0aXNmeSBhLypcbiAgICAgICAgLy8gbm93IGVpdGhlciB3ZSBmZWxsIG9mZiB0aGUgZW5kIG9mIHRoZSBwYXR0ZXJuLCBvciB3ZSdyZSBkb25lLlxuICAgICAgICBpZiAoZmkgPT09IGZsICYmIHBpID09PSBwbCkge1xuICAgICAgICAgICAgLy8gcmFuIG91dCBvZiBwYXR0ZXJuIGFuZCBmaWxlbmFtZSBhdCB0aGUgc2FtZSB0aW1lLlxuICAgICAgICAgICAgLy8gYW4gZXhhY3QgaGl0IVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZmkgPT09IGZsKSB7XG4gICAgICAgICAgICAvLyByYW4gb3V0IG9mIGZpbGUsIGJ1dCBzdGlsbCBoYWQgcGF0dGVybiBsZWZ0LlxuICAgICAgICAgICAgLy8gdGhpcyBpcyBvayBpZiB3ZSdyZSBkb2luZyB0aGUgbWF0Y2ggYXMgcGFydCBvZlxuICAgICAgICAgICAgLy8gYSBnbG9iIGZzIHRyYXZlcnNhbC5cbiAgICAgICAgICAgIHJldHVybiBwYXJ0aWFsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHBpID09PSBwbCkge1xuICAgICAgICAgICAgLy8gcmFuIG91dCBvZiBwYXR0ZXJuLCBzdGlsbCBoYXZlIGZpbGUgbGVmdC5cbiAgICAgICAgICAgIC8vIHRoaXMgaXMgb25seSBhY2NlcHRhYmxlIGlmIHdlJ3JlIG9uIHRoZSB2ZXJ5IGxhc3RcbiAgICAgICAgICAgIC8vIGVtcHR5IHNlZ21lbnQgb2YgYSBmaWxlIHdpdGggYSB0cmFpbGluZyBzbGFzaC5cbiAgICAgICAgICAgIC8vIGEvKiBzaG91bGQgbWF0Y2ggYS9iL1xuICAgICAgICAgICAgcmV0dXJuIGZpID09PSBmbCAtIDEgJiYgZmlsZVtmaV0gPT09ICcnO1xuICAgICAgICAgICAgLyogYzggaWdub3JlIHN0YXJ0ICovXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBzaG91bGQgYmUgdW5yZWFjaGFibGUuXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3d0Zj8nKTtcbiAgICAgICAgfVxuICAgICAgICAvKiBjOCBpZ25vcmUgc3RvcCAqL1xuICAgIH1cbiAgICBicmFjZUV4cGFuZCgpIHtcbiAgICAgICAgcmV0dXJuICgwLCBleHBvcnRzLmJyYWNlRXhwYW5kKSh0aGlzLnBhdHRlcm4sIHRoaXMub3B0aW9ucyk7XG4gICAgfVxuICAgIHBhcnNlKHBhdHRlcm4pIHtcbiAgICAgICAgKDAsIGFzc2VydF92YWxpZF9wYXR0ZXJuX2pzXzEuYXNzZXJ0VmFsaWRQYXR0ZXJuKShwYXR0ZXJuKTtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICAgICAgLy8gc2hvcnRjdXRzXG4gICAgICAgIGlmIChwYXR0ZXJuID09PSAnKionKVxuICAgICAgICAgICAgcmV0dXJuIGV4cG9ydHMuR0xPQlNUQVI7XG4gICAgICAgIGlmIChwYXR0ZXJuID09PSAnJylcbiAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgLy8gZmFyIGFuZCBhd2F5LCB0aGUgbW9zdCBjb21tb24gZ2xvYiBwYXR0ZXJuIHBhcnRzIGFyZVxuICAgICAgICAvLyAqLCAqLiosIGFuZCAqLjxleHQ+ICBBZGQgYSBmYXN0IGNoZWNrIG1ldGhvZCBmb3IgdGhvc2UuXG4gICAgICAgIGxldCBtO1xuICAgICAgICBsZXQgZmFzdFRlc3QgPSBudWxsO1xuICAgICAgICBpZiAoKG0gPSBwYXR0ZXJuLm1hdGNoKHN0YXJSRSkpKSB7XG4gICAgICAgICAgICBmYXN0VGVzdCA9IG9wdGlvbnMuZG90ID8gc3RhclRlc3REb3QgOiBzdGFyVGVzdDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgobSA9IHBhdHRlcm4ubWF0Y2goc3RhckRvdEV4dFJFKSkpIHtcbiAgICAgICAgICAgIGZhc3RUZXN0ID0gKG9wdGlvbnMubm9jYXNlXG4gICAgICAgICAgICAgICAgPyBvcHRpb25zLmRvdFxuICAgICAgICAgICAgICAgICAgICA/IHN0YXJEb3RFeHRUZXN0Tm9jYXNlRG90XG4gICAgICAgICAgICAgICAgICAgIDogc3RhckRvdEV4dFRlc3ROb2Nhc2VcbiAgICAgICAgICAgICAgICA6IG9wdGlvbnMuZG90XG4gICAgICAgICAgICAgICAgICAgID8gc3RhckRvdEV4dFRlc3REb3RcbiAgICAgICAgICAgICAgICAgICAgOiBzdGFyRG90RXh0VGVzdCkobVsxXSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoKG0gPSBwYXR0ZXJuLm1hdGNoKHFtYXJrc1JFKSkpIHtcbiAgICAgICAgICAgIGZhc3RUZXN0ID0gKG9wdGlvbnMubm9jYXNlXG4gICAgICAgICAgICAgICAgPyBvcHRpb25zLmRvdFxuICAgICAgICAgICAgICAgICAgICA/IHFtYXJrc1Rlc3ROb2Nhc2VEb3RcbiAgICAgICAgICAgICAgICAgICAgOiBxbWFya3NUZXN0Tm9jYXNlXG4gICAgICAgICAgICAgICAgOiBvcHRpb25zLmRvdFxuICAgICAgICAgICAgICAgICAgICA/IHFtYXJrc1Rlc3REb3RcbiAgICAgICAgICAgICAgICAgICAgOiBxbWFya3NUZXN0KShtKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgobSA9IHBhdHRlcm4ubWF0Y2goc3RhckRvdFN0YXJSRSkpKSB7XG4gICAgICAgICAgICBmYXN0VGVzdCA9IG9wdGlvbnMuZG90ID8gc3RhckRvdFN0YXJUZXN0RG90IDogc3RhckRvdFN0YXJUZXN0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKChtID0gcGF0dGVybi5tYXRjaChkb3RTdGFyUkUpKSkge1xuICAgICAgICAgICAgZmFzdFRlc3QgPSBkb3RTdGFyVGVzdDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZSA9IGFzdF9qc18xLkFTVC5mcm9tR2xvYihwYXR0ZXJuLCB0aGlzLm9wdGlvbnMpLnRvTU1QYXR0ZXJuKCk7XG4gICAgICAgIGlmIChmYXN0VGVzdCAmJiB0eXBlb2YgcmUgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAvLyBBdm9pZHMgb3ZlcnJpZGluZyBpbiBmcm96ZW4gZW52aXJvbm1lbnRzXG4gICAgICAgICAgICBSZWZsZWN0LmRlZmluZVByb3BlcnR5KHJlLCAndGVzdCcsIHsgdmFsdWU6IGZhc3RUZXN0IH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZTtcbiAgICB9XG4gICAgbWFrZVJlKCkge1xuICAgICAgICBpZiAodGhpcy5yZWdleHAgfHwgdGhpcy5yZWdleHAgPT09IGZhbHNlKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVnZXhwO1xuICAgICAgICAvLyBhdCB0aGlzIHBvaW50LCB0aGlzLnNldCBpcyBhIDJkIGFycmF5IG9mIHBhcnRpYWxcbiAgICAgICAgLy8gcGF0dGVybiBzdHJpbmdzLCBvciBcIioqXCIuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIEl0J3MgYmV0dGVyIHRvIHVzZSAubWF0Y2goKS4gIFRoaXMgZnVuY3Rpb24gc2hvdWxkbid0XG4gICAgICAgIC8vIGJlIHVzZWQsIHJlYWxseSwgYnV0IGl0J3MgcHJldHR5IGNvbnZlbmllbnQgc29tZXRpbWVzLFxuICAgICAgICAvLyB3aGVuIHlvdSBqdXN0IHdhbnQgdG8gd29yayB3aXRoIGEgcmVnZXguXG4gICAgICAgIGNvbnN0IHNldCA9IHRoaXMuc2V0O1xuICAgICAgICBpZiAoIXNldC5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMucmVnZXhwID0gZmFsc2U7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZWdleHA7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICAgICAgY29uc3QgdHdvU3RhciA9IG9wdGlvbnMubm9nbG9ic3RhclxuICAgICAgICAgICAgPyBzdGFyXG4gICAgICAgICAgICA6IG9wdGlvbnMuZG90XG4gICAgICAgICAgICAgICAgPyB0d29TdGFyRG90XG4gICAgICAgICAgICAgICAgOiB0d29TdGFyTm9Eb3Q7XG4gICAgICAgIGNvbnN0IGZsYWdzID0gbmV3IFNldChvcHRpb25zLm5vY2FzZSA/IFsnaSddIDogW10pO1xuICAgICAgICAvLyByZWdleHBpZnkgbm9uLWdsb2JzdGFyIHBhdHRlcm5zXG4gICAgICAgIC8vIGlmICoqIGlzIG9ubHkgaXRlbSwgdGhlbiB3ZSBqdXN0IGRvIG9uZSB0d29TdGFyXG4gICAgICAgIC8vIGlmICoqIGlzIGZpcnN0LCBhbmQgdGhlcmUgYXJlIG1vcmUsIHByZXBlbmQgKFxcL3x0d29TdGFyXFwvKT8gdG8gbmV4dFxuICAgICAgICAvLyBpZiAqKiBpcyBsYXN0LCBhcHBlbmQgKFxcL3R3b1N0YXJ8KSB0byBwcmV2aW91c1xuICAgICAgICAvLyBpZiAqKiBpcyBpbiB0aGUgbWlkZGxlLCBhcHBlbmQgKFxcL3xcXC90d29TdGFyXFwvKSB0byBwcmV2aW91c1xuICAgICAgICAvLyB0aGVuIGZpbHRlciBvdXQgR0xPQlNUQVIgc3ltYm9sc1xuICAgICAgICBsZXQgcmUgPSBzZXRcbiAgICAgICAgICAgIC5tYXAocGF0dGVybiA9PiB7XG4gICAgICAgICAgICBjb25zdCBwcCA9IHBhdHRlcm4ubWFwKHAgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChwIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgZiBvZiBwLmZsYWdzLnNwbGl0KCcnKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGZsYWdzLmFkZChmKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiBwID09PSAnc3RyaW5nJ1xuICAgICAgICAgICAgICAgICAgICA/IHJlZ0V4cEVzY2FwZShwKVxuICAgICAgICAgICAgICAgICAgICA6IHAgPT09IGV4cG9ydHMuR0xPQlNUQVJcbiAgICAgICAgICAgICAgICAgICAgICAgID8gZXhwb3J0cy5HTE9CU1RBUlxuICAgICAgICAgICAgICAgICAgICAgICAgOiBwLl9zcmM7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHBwLmZvckVhY2goKHAsIGkpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBuZXh0ID0gcHBbaSArIDFdO1xuICAgICAgICAgICAgICAgIGNvbnN0IHByZXYgPSBwcFtpIC0gMV07XG4gICAgICAgICAgICAgICAgaWYgKHAgIT09IGV4cG9ydHMuR0xPQlNUQVIgfHwgcHJldiA9PT0gZXhwb3J0cy5HTE9CU1RBUikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChwcmV2ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5leHQgIT09IHVuZGVmaW5lZCAmJiBuZXh0ICE9PSBleHBvcnRzLkdMT0JTVEFSKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcFtpICsgMV0gPSAnKD86XFxcXC98JyArIHR3b1N0YXIgKyAnXFxcXC8pPycgKyBuZXh0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHBbaV0gPSB0d29TdGFyO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKG5leHQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBwcFtpIC0gMV0gPSBwcmV2ICsgJyg/OlxcXFwvfCcgKyB0d29TdGFyICsgJyk/JztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAobmV4dCAhPT0gZXhwb3J0cy5HTE9CU1RBUikge1xuICAgICAgICAgICAgICAgICAgICBwcFtpIC0gMV0gPSBwcmV2ICsgJyg/OlxcXFwvfFxcXFwvJyArIHR3b1N0YXIgKyAnXFxcXC8pJyArIG5leHQ7XG4gICAgICAgICAgICAgICAgICAgIHBwW2kgKyAxXSA9IGV4cG9ydHMuR0xPQlNUQVI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcHAuZmlsdGVyKHAgPT4gcCAhPT0gZXhwb3J0cy5HTE9CU1RBUikuam9pbignLycpO1xuICAgICAgICB9KVxuICAgICAgICAgICAgLmpvaW4oJ3wnKTtcbiAgICAgICAgLy8gbmVlZCB0byB3cmFwIGluIHBhcmVucyBpZiB3ZSBoYWQgbW9yZSB0aGFuIG9uZSB0aGluZyB3aXRoIHwsXG4gICAgICAgIC8vIG90aGVyd2lzZSBvbmx5IHRoZSBmaXJzdCB3aWxsIGJlIGFuY2hvcmVkIHRvIF4gYW5kIHRoZSBsYXN0IHRvICRcbiAgICAgICAgY29uc3QgW29wZW4sIGNsb3NlXSA9IHNldC5sZW5ndGggPiAxID8gWycoPzonLCAnKSddIDogWycnLCAnJ107XG4gICAgICAgIC8vIG11c3QgbWF0Y2ggZW50aXJlIHBhdHRlcm5cbiAgICAgICAgLy8gZW5kaW5nIGluIGEgKiBvciAqKiB3aWxsIG1ha2UgaXQgbGVzcyBzdHJpY3QuXG4gICAgICAgIHJlID0gJ14nICsgb3BlbiArIHJlICsgY2xvc2UgKyAnJCc7XG4gICAgICAgIC8vIGNhbiBtYXRjaCBhbnl0aGluZywgYXMgbG9uZyBhcyBpdCdzIG5vdCB0aGlzLlxuICAgICAgICBpZiAodGhpcy5uZWdhdGUpXG4gICAgICAgICAgICByZSA9ICdeKD8hJyArIHJlICsgJykuKyQnO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy5yZWdleHAgPSBuZXcgUmVnRXhwKHJlLCBbLi4uZmxhZ3NdLmpvaW4oJycpKTtcbiAgICAgICAgICAgIC8qIGM4IGlnbm9yZSBzdGFydCAqL1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChleCkge1xuICAgICAgICAgICAgLy8gc2hvdWxkIGJlIGltcG9zc2libGVcbiAgICAgICAgICAgIHRoaXMucmVnZXhwID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLyogYzggaWdub3JlIHN0b3AgKi9cbiAgICAgICAgcmV0dXJuIHRoaXMucmVnZXhwO1xuICAgIH1cbiAgICBzbGFzaFNwbGl0KHApIHtcbiAgICAgICAgLy8gaWYgcCBzdGFydHMgd2l0aCAvLyBvbiB3aW5kb3dzLCB3ZSBwcmVzZXJ2ZSB0aGF0XG4gICAgICAgIC8vIHNvIHRoYXQgVU5DIHBhdGhzIGFyZW4ndCBicm9rZW4uICBPdGhlcndpc2UsIGFueSBudW1iZXIgb2ZcbiAgICAgICAgLy8gLyBjaGFyYWN0ZXJzIGFyZSBjb2FsZXNjZWQgaW50byBvbmUsIHVubGVzc1xuICAgICAgICAvLyBwcmVzZXJ2ZU11bHRpcGxlU2xhc2hlcyBpcyBzZXQgdG8gdHJ1ZS5cbiAgICAgICAgaWYgKHRoaXMucHJlc2VydmVNdWx0aXBsZVNsYXNoZXMpIHtcbiAgICAgICAgICAgIHJldHVybiBwLnNwbGl0KCcvJyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5pc1dpbmRvd3MgJiYgL15cXC9cXC9bXlxcL10rLy50ZXN0KHApKSB7XG4gICAgICAgICAgICAvLyBhZGQgYW4gZXh0cmEgJycgZm9yIHRoZSBvbmUgd2UgbG9zZVxuICAgICAgICAgICAgcmV0dXJuIFsnJywgLi4ucC5zcGxpdCgvXFwvKy8pXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBwLnNwbGl0KC9cXC8rLyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbWF0Y2goZiwgcGFydGlhbCA9IHRoaXMucGFydGlhbCkge1xuICAgICAgICB0aGlzLmRlYnVnKCdtYXRjaCcsIGYsIHRoaXMucGF0dGVybik7XG4gICAgICAgIC8vIHNob3J0LWNpcmN1aXQgaW4gdGhlIGNhc2Ugb2YgYnVzdGVkIHRoaW5ncy5cbiAgICAgICAgLy8gY29tbWVudHMsIGV0Yy5cbiAgICAgICAgaWYgKHRoaXMuY29tbWVudCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmVtcHR5KSB7XG4gICAgICAgICAgICByZXR1cm4gZiA9PT0gJyc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGYgPT09ICcvJyAmJiBwYXJ0aWFsKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgICAgICAvLyB3aW5kb3dzOiBuZWVkIHRvIHVzZSAvLCBub3QgXFxcbiAgICAgICAgaWYgKHRoaXMuaXNXaW5kb3dzKSB7XG4gICAgICAgICAgICBmID0gZi5zcGxpdCgnXFxcXCcpLmpvaW4oJy8nKTtcbiAgICAgICAgfVxuICAgICAgICAvLyB0cmVhdCB0aGUgdGVzdCBwYXRoIGFzIGEgc2V0IG9mIHBhdGhwYXJ0cy5cbiAgICAgICAgY29uc3QgZmYgPSB0aGlzLnNsYXNoU3BsaXQoZik7XG4gICAgICAgIHRoaXMuZGVidWcodGhpcy5wYXR0ZXJuLCAnc3BsaXQnLCBmZik7XG4gICAgICAgIC8vIGp1c3QgT05FIG9mIHRoZSBwYXR0ZXJuIHNldHMgaW4gdGhpcy5zZXQgbmVlZHMgdG8gbWF0Y2hcbiAgICAgICAgLy8gaW4gb3JkZXIgZm9yIGl0IHRvIGJlIHZhbGlkLiAgSWYgbmVnYXRpbmcsIHRoZW4ganVzdCBvbmVcbiAgICAgICAgLy8gbWF0Y2ggbWVhbnMgdGhhdCB3ZSBoYXZlIGZhaWxlZC5cbiAgICAgICAgLy8gRWl0aGVyIHdheSwgcmV0dXJuIG9uIHRoZSBmaXJzdCBoaXQuXG4gICAgICAgIGNvbnN0IHNldCA9IHRoaXMuc2V0O1xuICAgICAgICB0aGlzLmRlYnVnKHRoaXMucGF0dGVybiwgJ3NldCcsIHNldCk7XG4gICAgICAgIC8vIEZpbmQgdGhlIGJhc2VuYW1lIG9mIHRoZSBwYXRoIGJ5IGxvb2tpbmcgZm9yIHRoZSBsYXN0IG5vbi1lbXB0eSBzZWdtZW50XG4gICAgICAgIGxldCBmaWxlbmFtZSA9IGZmW2ZmLmxlbmd0aCAtIDFdO1xuICAgICAgICBpZiAoIWZpbGVuYW1lKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gZmYubGVuZ3RoIC0gMjsgIWZpbGVuYW1lICYmIGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICAgICAgZmlsZW5hbWUgPSBmZltpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNldC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgcGF0dGVybiA9IHNldFtpXTtcbiAgICAgICAgICAgIGxldCBmaWxlID0gZmY7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5tYXRjaEJhc2UgJiYgcGF0dGVybi5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgICBmaWxlID0gW2ZpbGVuYW1lXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGhpdCA9IHRoaXMubWF0Y2hPbmUoZmlsZSwgcGF0dGVybiwgcGFydGlhbCk7XG4gICAgICAgICAgICBpZiAoaGl0KSB7XG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuZmxpcE5lZ2F0ZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuICF0aGlzLm5lZ2F0ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBkaWRuJ3QgZ2V0IGFueSBoaXRzLiAgdGhpcyBpcyBzdWNjZXNzIGlmIGl0J3MgYSBuZWdhdGl2ZVxuICAgICAgICAvLyBwYXR0ZXJuLCBmYWlsdXJlIG90aGVyd2lzZS5cbiAgICAgICAgaWYgKG9wdGlvbnMuZmxpcE5lZ2F0ZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLm5lZ2F0ZTtcbiAgICB9XG4gICAgc3RhdGljIGRlZmF1bHRzKGRlZikge1xuICAgICAgICByZXR1cm4gZXhwb3J0cy5taW5pbWF0Y2guZGVmYXVsdHMoZGVmKS5NaW5pbWF0Y2g7XG4gICAgfVxufVxuZXhwb3J0cy5NaW5pbWF0Y2ggPSBNaW5pbWF0Y2g7XG4vKiBjOCBpZ25vcmUgc3RhcnQgKi9cbnZhciBhc3RfanNfMiA9IHJlcXVpcmUoXCIuL2FzdC5qc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkFTVFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gYXN0X2pzXzIuQVNUOyB9IH0pO1xudmFyIGVzY2FwZV9qc18yID0gcmVxdWlyZShcIi4vZXNjYXBlLmpzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZXNjYXBlXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBlc2NhcGVfanNfMi5lc2NhcGU7IH0gfSk7XG52YXIgdW5lc2NhcGVfanNfMiA9IHJlcXVpcmUoXCIuL3VuZXNjYXBlLmpzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwidW5lc2NhcGVcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHVuZXNjYXBlX2pzXzIudW5lc2NhcGU7IH0gfSk7XG4vKiBjOCBpZ25vcmUgc3RvcCAqL1xuZXhwb3J0cy5taW5pbWF0Y2guQVNUID0gYXN0X2pzXzEuQVNUO1xuZXhwb3J0cy5taW5pbWF0Y2guTWluaW1hdGNoID0gTWluaW1hdGNoO1xuZXhwb3J0cy5taW5pbWF0Y2guZXNjYXBlID0gZXNjYXBlX2pzXzEuZXNjYXBlO1xuZXhwb3J0cy5taW5pbWF0Y2gudW5lc2NhcGUgPSB1bmVzY2FwZV9qc18xLnVuZXNjYXBlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(instrument)/./node_modules/minimatch/dist/commonjs/index.js\n");

/***/ }),

/***/ "(instrument)/./node_modules/minimatch/dist/commonjs/unescape.js":
/*!**********************************************************!*\
  !*** ./node_modules/minimatch/dist/commonjs/unescape.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.unescape = void 0;\n/**\n * Un-escape a string that has been escaped with {@link escape}.\n *\n * If the {@link windowsPathsNoEscape} option is used, then square-brace\n * escapes are removed, but not backslash escapes.  For example, it will turn\n * the string `'[*]'` into `*`, but it will not turn `'\\\\*'` into `'*'`,\n * becuase `\\` is a path separator in `windowsPathsNoEscape` mode.\n *\n * When `windowsPathsNoEscape` is not set, then both brace escapes and\n * backslash escapes are removed.\n *\n * Slashes (and backslashes in `windowsPathsNoEscape` mode) cannot be escaped\n * or unescaped.\n */\nconst unescape = (s, { windowsPathsNoEscape = false, } = {}) => {\n    return windowsPathsNoEscape\n        ? s.replace(/\\[([^\\/\\\\])\\]/g, '$1')\n        : s.replace(/((?!\\\\).|^)\\[([^\\/\\\\])\\]/g, '$1$2').replace(/\\\\([^\\/])/g, '$1');\n};\nexports.unescape = unescape;\n//# sourceMappingURL=unescape.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGluc3RydW1lbnQpLy4vbm9kZV9tb2R1bGVzL21pbmltYXRjaC9kaXN0L2NvbW1vbmpzL3VuZXNjYXBlLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGdCQUFnQjtBQUNoQjtBQUNBLGtEQUFrRCxhQUFhO0FBQy9EO0FBQ0EsV0FBVyw0QkFBNEI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsZ0NBQWdDLElBQUk7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hdXRvLWxvb3AtZGVtby8uL25vZGVfbW9kdWxlcy9taW5pbWF0Y2gvZGlzdC9jb21tb25qcy91bmVzY2FwZS5qcz8wZWQ4Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy51bmVzY2FwZSA9IHZvaWQgMDtcbi8qKlxuICogVW4tZXNjYXBlIGEgc3RyaW5nIHRoYXQgaGFzIGJlZW4gZXNjYXBlZCB3aXRoIHtAbGluayBlc2NhcGV9LlxuICpcbiAqIElmIHRoZSB7QGxpbmsgd2luZG93c1BhdGhzTm9Fc2NhcGV9IG9wdGlvbiBpcyB1c2VkLCB0aGVuIHNxdWFyZS1icmFjZVxuICogZXNjYXBlcyBhcmUgcmVtb3ZlZCwgYnV0IG5vdCBiYWNrc2xhc2ggZXNjYXBlcy4gIEZvciBleGFtcGxlLCBpdCB3aWxsIHR1cm5cbiAqIHRoZSBzdHJpbmcgYCdbKl0nYCBpbnRvIGAqYCwgYnV0IGl0IHdpbGwgbm90IHR1cm4gYCdcXFxcKidgIGludG8gYCcqJ2AsXG4gKiBiZWN1YXNlIGBcXGAgaXMgYSBwYXRoIHNlcGFyYXRvciBpbiBgd2luZG93c1BhdGhzTm9Fc2NhcGVgIG1vZGUuXG4gKlxuICogV2hlbiBgd2luZG93c1BhdGhzTm9Fc2NhcGVgIGlzIG5vdCBzZXQsIHRoZW4gYm90aCBicmFjZSBlc2NhcGVzIGFuZFxuICogYmFja3NsYXNoIGVzY2FwZXMgYXJlIHJlbW92ZWQuXG4gKlxuICogU2xhc2hlcyAoYW5kIGJhY2tzbGFzaGVzIGluIGB3aW5kb3dzUGF0aHNOb0VzY2FwZWAgbW9kZSkgY2Fubm90IGJlIGVzY2FwZWRcbiAqIG9yIHVuZXNjYXBlZC5cbiAqL1xuY29uc3QgdW5lc2NhcGUgPSAocywgeyB3aW5kb3dzUGF0aHNOb0VzY2FwZSA9IGZhbHNlLCB9ID0ge30pID0+IHtcbiAgICByZXR1cm4gd2luZG93c1BhdGhzTm9Fc2NhcGVcbiAgICAgICAgPyBzLnJlcGxhY2UoL1xcWyhbXlxcL1xcXFxdKVxcXS9nLCAnJDEnKVxuICAgICAgICA6IHMucmVwbGFjZSgvKCg/IVxcXFwpLnxeKVxcWyhbXlxcL1xcXFxdKVxcXS9nLCAnJDEkMicpLnJlcGxhY2UoL1xcXFwoW15cXC9dKS9nLCAnJDEnKTtcbn07XG5leHBvcnRzLnVuZXNjYXBlID0gdW5lc2NhcGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD11bmVzY2FwZS5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(instrument)/./node_modules/minimatch/dist/commonjs/unescape.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/minimatch/dist/commonjs/assert-valid-pattern.js":
/*!**********************************************************************!*\
  !*** ./node_modules/minimatch/dist/commonjs/assert-valid-pattern.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.assertValidPattern = void 0;\nconst MAX_PATTERN_LENGTH = 1024 * 64;\nconst assertValidPattern = (pattern) => {\n    if (typeof pattern !== 'string') {\n        throw new TypeError('invalid pattern');\n    }\n    if (pattern.length > MAX_PATTERN_LENGTH) {\n        throw new TypeError('pattern is too long');\n    }\n};\nexports.assertValidPattern = assertValidPattern;\n//# sourceMappingURL=assert-valid-pattern.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbWluaW1hdGNoL2Rpc3QvY29tbW9uanMvYXNzZXJ0LXZhbGlkLXBhdHRlcm4uanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQiIsInNvdXJjZXMiOlsid2VicGFjazovL2F1dG8tbG9vcC1kZW1vLy4vbm9kZV9tb2R1bGVzL21pbmltYXRjaC9kaXN0L2NvbW1vbmpzL2Fzc2VydC12YWxpZC1wYXR0ZXJuLmpzP2EwMTciXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmFzc2VydFZhbGlkUGF0dGVybiA9IHZvaWQgMDtcbmNvbnN0IE1BWF9QQVRURVJOX0xFTkdUSCA9IDEwMjQgKiA2NDtcbmNvbnN0IGFzc2VydFZhbGlkUGF0dGVybiA9IChwYXR0ZXJuKSA9PiB7XG4gICAgaWYgKHR5cGVvZiBwYXR0ZXJuICE9PSAnc3RyaW5nJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHBhdHRlcm4nKTtcbiAgICB9XG4gICAgaWYgKHBhdHRlcm4ubGVuZ3RoID4gTUFYX1BBVFRFUk5fTEVOR1RIKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3BhdHRlcm4gaXMgdG9vIGxvbmcnKTtcbiAgICB9XG59O1xuZXhwb3J0cy5hc3NlcnRWYWxpZFBhdHRlcm4gPSBhc3NlcnRWYWxpZFBhdHRlcm47XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hc3NlcnQtdmFsaWQtcGF0dGVybi5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/minimatch/dist/commonjs/assert-valid-pattern.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/minimatch/dist/commonjs/ast.js":
/*!*****************************************************!*\
  !*** ./node_modules/minimatch/dist/commonjs/ast.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n// parse a single path portion\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.AST = void 0;\nconst brace_expressions_js_1 = __webpack_require__(/*! ./brace-expressions.js */ \"(rsc)/./node_modules/minimatch/dist/commonjs/brace-expressions.js\");\nconst unescape_js_1 = __webpack_require__(/*! ./unescape.js */ \"(rsc)/./node_modules/minimatch/dist/commonjs/unescape.js\");\nconst types = new Set(['!', '?', '+', '*', '@']);\nconst isExtglobType = (c) => types.has(c);\n// Patterns that get prepended to bind to the start of either the\n// entire string, or just a single path portion, to prevent dots\n// and/or traversal patterns, when needed.\n// Exts don't need the ^ or / bit, because the root binds that already.\nconst startNoTraversal = '(?!(?:^|/)\\\\.\\\\.?(?:$|/))';\nconst startNoDot = '(?!\\\\.)';\n// characters that indicate a start of pattern needs the \"no dots\" bit,\n// because a dot *might* be matched. ( is not in the list, because in\n// the case of a child extglob, it will handle the prevention itself.\nconst addPatternStart = new Set(['[', '.']);\n// cases where traversal is A-OK, no dot prevention needed\nconst justDots = new Set(['..', '.']);\nconst reSpecials = new Set('().*{}+?[]^$\\\\!');\nconst regExpEscape = (s) => s.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, '\\\\$&');\n// any single thing other than /\nconst qmark = '[^/]';\n// * => any number of characters\nconst star = qmark + '*?';\n// use + when we need to ensure that *something* matches, because the * is\n// the only thing in the path portion.\nconst starNoEmpty = qmark + '+?';\n// remove the \\ chars that we added if we end up doing a nonmagic compare\n// const deslash = (s: string) => s.replace(/\\\\(.)/g, '$1')\nclass AST {\n    type;\n    #root;\n    #hasMagic;\n    #uflag = false;\n    #parts = [];\n    #parent;\n    #parentIndex;\n    #negs;\n    #filledNegs = false;\n    #options;\n    #toString;\n    // set to true if it's an extglob with no children\n    // (which really means one child of '')\n    #emptyExt = false;\n    constructor(type, parent, options = {}) {\n        this.type = type;\n        // extglobs are inherently magical\n        if (type)\n            this.#hasMagic = true;\n        this.#parent = parent;\n        this.#root = this.#parent ? this.#parent.#root : this;\n        this.#options = this.#root === this ? options : this.#root.#options;\n        this.#negs = this.#root === this ? [] : this.#root.#negs;\n        if (type === '!' && !this.#root.#filledNegs)\n            this.#negs.push(this);\n        this.#parentIndex = this.#parent ? this.#parent.#parts.length : 0;\n    }\n    get hasMagic() {\n        /* c8 ignore start */\n        if (this.#hasMagic !== undefined)\n            return this.#hasMagic;\n        /* c8 ignore stop */\n        for (const p of this.#parts) {\n            if (typeof p === 'string')\n                continue;\n            if (p.type || p.hasMagic)\n                return (this.#hasMagic = true);\n        }\n        // note: will be undefined until we generate the regexp src and find out\n        return this.#hasMagic;\n    }\n    // reconstructs the pattern\n    toString() {\n        if (this.#toString !== undefined)\n            return this.#toString;\n        if (!this.type) {\n            return (this.#toString = this.#parts.map(p => String(p)).join(''));\n        }\n        else {\n            return (this.#toString =\n                this.type + '(' + this.#parts.map(p => String(p)).join('|') + ')');\n        }\n    }\n    #fillNegs() {\n        /* c8 ignore start */\n        if (this !== this.#root)\n            throw new Error('should only call on root');\n        if (this.#filledNegs)\n            return this;\n        /* c8 ignore stop */\n        // call toString() once to fill this out\n        this.toString();\n        this.#filledNegs = true;\n        let n;\n        while ((n = this.#negs.pop())) {\n            if (n.type !== '!')\n                continue;\n            // walk up the tree, appending everthing that comes AFTER parentIndex\n            let p = n;\n            let pp = p.#parent;\n            while (pp) {\n                for (let i = p.#parentIndex + 1; !pp.type && i < pp.#parts.length; i++) {\n                    for (const part of n.#parts) {\n                        /* c8 ignore start */\n                        if (typeof part === 'string') {\n                            throw new Error('string part in extglob AST??');\n                        }\n                        /* c8 ignore stop */\n                        part.copyIn(pp.#parts[i]);\n                    }\n                }\n                p = pp;\n                pp = p.#parent;\n            }\n        }\n        return this;\n    }\n    push(...parts) {\n        for (const p of parts) {\n            if (p === '')\n                continue;\n            /* c8 ignore start */\n            if (typeof p !== 'string' && !(p instanceof AST && p.#parent === this)) {\n                throw new Error('invalid part: ' + p);\n            }\n            /* c8 ignore stop */\n            this.#parts.push(p);\n        }\n    }\n    toJSON() {\n        const ret = this.type === null\n            ? this.#parts.slice().map(p => (typeof p === 'string' ? p : p.toJSON()))\n            : [this.type, ...this.#parts.map(p => p.toJSON())];\n        if (this.isStart() && !this.type)\n            ret.unshift([]);\n        if (this.isEnd() &&\n            (this === this.#root ||\n                (this.#root.#filledNegs && this.#parent?.type === '!'))) {\n            ret.push({});\n        }\n        return ret;\n    }\n    isStart() {\n        if (this.#root === this)\n            return true;\n        // if (this.type) return !!this.#parent?.isStart()\n        if (!this.#parent?.isStart())\n            return false;\n        if (this.#parentIndex === 0)\n            return true;\n        // if everything AHEAD of this is a negation, then it's still the \"start\"\n        const p = this.#parent;\n        for (let i = 0; i < this.#parentIndex; i++) {\n            const pp = p.#parts[i];\n            if (!(pp instanceof AST && pp.type === '!')) {\n                return false;\n            }\n        }\n        return true;\n    }\n    isEnd() {\n        if (this.#root === this)\n            return true;\n        if (this.#parent?.type === '!')\n            return true;\n        if (!this.#parent?.isEnd())\n            return false;\n        if (!this.type)\n            return this.#parent?.isEnd();\n        // if not root, it'll always have a parent\n        /* c8 ignore start */\n        const pl = this.#parent ? this.#parent.#parts.length : 0;\n        /* c8 ignore stop */\n        return this.#parentIndex === pl - 1;\n    }\n    copyIn(part) {\n        if (typeof part === 'string')\n            this.push(part);\n        else\n            this.push(part.clone(this));\n    }\n    clone(parent) {\n        const c = new AST(this.type, parent);\n        for (const p of this.#parts) {\n            c.copyIn(p);\n        }\n        return c;\n    }\n    static #parseAST(str, ast, pos, opt) {\n        let escaping = false;\n        let inBrace = false;\n        let braceStart = -1;\n        let braceNeg = false;\n        if (ast.type === null) {\n            // outside of a extglob, append until we find a start\n            let i = pos;\n            let acc = '';\n            while (i < str.length) {\n                const c = str.charAt(i++);\n                // still accumulate escapes at this point, but we do ignore\n                // starts that are escaped\n                if (escaping || c === '\\\\') {\n                    escaping = !escaping;\n                    acc += c;\n                    continue;\n                }\n                if (inBrace) {\n                    if (i === braceStart + 1) {\n                        if (c === '^' || c === '!') {\n                            braceNeg = true;\n                        }\n                    }\n                    else if (c === ']' && !(i === braceStart + 2 && braceNeg)) {\n                        inBrace = false;\n                    }\n                    acc += c;\n                    continue;\n                }\n                else if (c === '[') {\n                    inBrace = true;\n                    braceStart = i;\n                    braceNeg = false;\n                    acc += c;\n                    continue;\n                }\n                if (!opt.noext && isExtglobType(c) && str.charAt(i) === '(') {\n                    ast.push(acc);\n                    acc = '';\n                    const ext = new AST(c, ast);\n                    i = AST.#parseAST(str, ext, i, opt);\n                    ast.push(ext);\n                    continue;\n                }\n                acc += c;\n            }\n            ast.push(acc);\n            return i;\n        }\n        // some kind of extglob, pos is at the (\n        // find the next | or )\n        let i = pos + 1;\n        let part = new AST(null, ast);\n        const parts = [];\n        let acc = '';\n        while (i < str.length) {\n            const c = str.charAt(i++);\n            // still accumulate escapes at this point, but we do ignore\n            // starts that are escaped\n            if (escaping || c === '\\\\') {\n                escaping = !escaping;\n                acc += c;\n                continue;\n            }\n            if (inBrace) {\n                if (i === braceStart + 1) {\n                    if (c === '^' || c === '!') {\n                        braceNeg = true;\n                    }\n                }\n                else if (c === ']' && !(i === braceStart + 2 && braceNeg)) {\n                    inBrace = false;\n                }\n                acc += c;\n                continue;\n            }\n            else if (c === '[') {\n                inBrace = true;\n                braceStart = i;\n                braceNeg = false;\n                acc += c;\n                continue;\n            }\n            if (isExtglobType(c) && str.charAt(i) === '(') {\n                part.push(acc);\n                acc = '';\n                const ext = new AST(c, part);\n                part.push(ext);\n                i = AST.#parseAST(str, ext, i, opt);\n                continue;\n            }\n            if (c === '|') {\n                part.push(acc);\n                acc = '';\n                parts.push(part);\n                part = new AST(null, ast);\n                continue;\n            }\n            if (c === ')') {\n                if (acc === '' && ast.#parts.length === 0) {\n                    ast.#emptyExt = true;\n                }\n                part.push(acc);\n                acc = '';\n                ast.push(...parts, part);\n                return i;\n            }\n            acc += c;\n        }\n        // unfinished extglob\n        // if we got here, it was a malformed extglob! not an extglob, but\n        // maybe something else in there.\n        ast.type = null;\n        ast.#hasMagic = undefined;\n        ast.#parts = [str.substring(pos - 1)];\n        return i;\n    }\n    static fromGlob(pattern, options = {}) {\n        const ast = new AST(null, undefined, options);\n        AST.#parseAST(pattern, ast, 0, options);\n        return ast;\n    }\n    // returns the regular expression if there's magic, or the unescaped\n    // string if not.\n    toMMPattern() {\n        // should only be called on root\n        /* c8 ignore start */\n        if (this !== this.#root)\n            return this.#root.toMMPattern();\n        /* c8 ignore stop */\n        const glob = this.toString();\n        const [re, body, hasMagic, uflag] = this.toRegExpSource();\n        // if we're in nocase mode, and not nocaseMagicOnly, then we do\n        // still need a regular expression if we have to case-insensitively\n        // match capital/lowercase characters.\n        const anyMagic = hasMagic ||\n            this.#hasMagic ||\n            (this.#options.nocase &&\n                !this.#options.nocaseMagicOnly &&\n                glob.toUpperCase() !== glob.toLowerCase());\n        if (!anyMagic) {\n            return body;\n        }\n        const flags = (this.#options.nocase ? 'i' : '') + (uflag ? 'u' : '');\n        return Object.assign(new RegExp(`^${re}$`, flags), {\n            _src: re,\n            _glob: glob,\n        });\n    }\n    get options() {\n        return this.#options;\n    }\n    // returns the string match, the regexp source, whether there's magic\n    // in the regexp (so a regular expression is required) and whether or\n    // not the uflag is needed for the regular expression (for posix classes)\n    // TODO: instead of injecting the start/end at this point, just return\n    // the BODY of the regexp, along with the start/end portions suitable\n    // for binding the start/end in either a joined full-path makeRe context\n    // (where we bind to (^|/), or a standalone matchPart context (where\n    // we bind to ^, and not /).  Otherwise slashes get duped!\n    //\n    // In part-matching mode, the start is:\n    // - if not isStart: nothing\n    // - if traversal possible, but not allowed: ^(?!\\.\\.?$)\n    // - if dots allowed or not possible: ^\n    // - if dots possible and not allowed: ^(?!\\.)\n    // end is:\n    // - if not isEnd(): nothing\n    // - else: $\n    //\n    // In full-path matching mode, we put the slash at the START of the\n    // pattern, so start is:\n    // - if first pattern: same as part-matching mode\n    // - if not isStart(): nothing\n    // - if traversal possible, but not allowed: /(?!\\.\\.?(?:$|/))\n    // - if dots allowed or not possible: /\n    // - if dots possible and not allowed: /(?!\\.)\n    // end is:\n    // - if last pattern, same as part-matching mode\n    // - else nothing\n    //\n    // Always put the (?:$|/) on negated tails, though, because that has to be\n    // there to bind the end of the negated pattern portion, and it's easier to\n    // just stick it in now rather than try to inject it later in the middle of\n    // the pattern.\n    //\n    // We can just always return the same end, and leave it up to the caller\n    // to know whether it's going to be used joined or in parts.\n    // And, if the start is adjusted slightly, can do the same there:\n    // - if not isStart: nothing\n    // - if traversal possible, but not allowed: (?:/|^)(?!\\.\\.?$)\n    // - if dots allowed or not possible: (?:/|^)\n    // - if dots possible and not allowed: (?:/|^)(?!\\.)\n    //\n    // But it's better to have a simpler binding without a conditional, for\n    // performance, so probably better to return both start options.\n    //\n    // Then the caller just ignores the end if it's not the first pattern,\n    // and the start always gets applied.\n    //\n    // But that's always going to be $ if it's the ending pattern, or nothing,\n    // so the caller can just attach $ at the end of the pattern when building.\n    //\n    // So the todo is:\n    // - better detect what kind of start is needed\n    // - return both flavors of starting pattern\n    // - attach $ at the end of the pattern when creating the actual RegExp\n    //\n    // Ah, but wait, no, that all only applies to the root when the first pattern\n    // is not an extglob. If the first pattern IS an extglob, then we need all\n    // that dot prevention biz to live in the extglob portions, because eg\n    // +(*|.x*) can match .xy but not .yx.\n    //\n    // So, return the two flavors if it's #root and the first child is not an\n    // AST, otherwise leave it to the child AST to handle it, and there,\n    // use the (?:^|/) style of start binding.\n    //\n    // Even simplified further:\n    // - Since the start for a join is eg /(?!\\.) and the start for a part\n    // is ^(?!\\.), we can just prepend (?!\\.) to the pattern (either root\n    // or start or whatever) and prepend ^ or / at the Regexp construction.\n    toRegExpSource(allowDot) {\n        const dot = allowDot ?? !!this.#options.dot;\n        if (this.#root === this)\n            this.#fillNegs();\n        if (!this.type) {\n            const noEmpty = this.isStart() && this.isEnd();\n            const src = this.#parts\n                .map(p => {\n                const [re, _, hasMagic, uflag] = typeof p === 'string'\n                    ? AST.#parseGlob(p, this.#hasMagic, noEmpty)\n                    : p.toRegExpSource(allowDot);\n                this.#hasMagic = this.#hasMagic || hasMagic;\n                this.#uflag = this.#uflag || uflag;\n                return re;\n            })\n                .join('');\n            let start = '';\n            if (this.isStart()) {\n                if (typeof this.#parts[0] === 'string') {\n                    // this is the string that will match the start of the pattern,\n                    // so we need to protect against dots and such.\n                    // '.' and '..' cannot match unless the pattern is that exactly,\n                    // even if it starts with . or dot:true is set.\n                    const dotTravAllowed = this.#parts.length === 1 && justDots.has(this.#parts[0]);\n                    if (!dotTravAllowed) {\n                        const aps = addPatternStart;\n                        // check if we have a possibility of matching . or ..,\n                        // and prevent that.\n                        const needNoTrav = \n                        // dots are allowed, and the pattern starts with [ or .\n                        (dot && aps.has(src.charAt(0))) ||\n                            // the pattern starts with \\., and then [ or .\n                            (src.startsWith('\\\\.') && aps.has(src.charAt(2))) ||\n                            // the pattern starts with \\.\\., and then [ or .\n                            (src.startsWith('\\\\.\\\\.') && aps.has(src.charAt(4)));\n                        // no need to prevent dots if it can't match a dot, or if a\n                        // sub-pattern will be preventing it anyway.\n                        const needNoDot = !dot && !allowDot && aps.has(src.charAt(0));\n                        start = needNoTrav ? startNoTraversal : needNoDot ? startNoDot : '';\n                    }\n                }\n            }\n            // append the \"end of path portion\" pattern to negation tails\n            let end = '';\n            if (this.isEnd() &&\n                this.#root.#filledNegs &&\n                this.#parent?.type === '!') {\n                end = '(?:$|\\\\/)';\n            }\n            const final = start + src + end;\n            return [\n                final,\n                (0, unescape_js_1.unescape)(src),\n                (this.#hasMagic = !!this.#hasMagic),\n                this.#uflag,\n            ];\n        }\n        // We need to calculate the body *twice* if it's a repeat pattern\n        // at the start, once in nodot mode, then again in dot mode, so a\n        // pattern like *(?) can match 'x.y'\n        const repeated = this.type === '*' || this.type === '+';\n        // some kind of extglob\n        const start = this.type === '!' ? '(?:(?!(?:' : '(?:';\n        let body = this.#partsToRegExp(dot);\n        if (this.isStart() && this.isEnd() && !body && this.type !== '!') {\n            // invalid extglob, has to at least be *something* present, if it's\n            // the entire path portion.\n            const s = this.toString();\n            this.#parts = [s];\n            this.type = null;\n            this.#hasMagic = undefined;\n            return [s, (0, unescape_js_1.unescape)(this.toString()), false, false];\n        }\n        // XXX abstract out this map method\n        let bodyDotAllowed = !repeated || allowDot || dot || !startNoDot\n            ? ''\n            : this.#partsToRegExp(true);\n        if (bodyDotAllowed === body) {\n            bodyDotAllowed = '';\n        }\n        if (bodyDotAllowed) {\n            body = `(?:${body})(?:${bodyDotAllowed})*?`;\n        }\n        // an empty !() is exactly equivalent to a starNoEmpty\n        let final = '';\n        if (this.type === '!' && this.#emptyExt) {\n            final = (this.isStart() && !dot ? startNoDot : '') + starNoEmpty;\n        }\n        else {\n            const close = this.type === '!'\n                ? // !() must match something,but !(x) can match ''\n                    '))' +\n                        (this.isStart() && !dot && !allowDot ? startNoDot : '') +\n                        star +\n                        ')'\n                : this.type === '@'\n                    ? ')'\n                    : this.type === '?'\n                        ? ')?'\n                        : this.type === '+' && bodyDotAllowed\n                            ? ')'\n                            : this.type === '*' && bodyDotAllowed\n                                ? `)?`\n                                : `)${this.type}`;\n            final = start + body + close;\n        }\n        return [\n            final,\n            (0, unescape_js_1.unescape)(body),\n            (this.#hasMagic = !!this.#hasMagic),\n            this.#uflag,\n        ];\n    }\n    #partsToRegExp(dot) {\n        return this.#parts\n            .map(p => {\n            // extglob ASTs should only contain parent ASTs\n            /* c8 ignore start */\n            if (typeof p === 'string') {\n                throw new Error('string type in extglob ast??');\n            }\n            /* c8 ignore stop */\n            // can ignore hasMagic, because extglobs are already always magic\n            const [re, _, _hasMagic, uflag] = p.toRegExpSource(dot);\n            this.#uflag = this.#uflag || uflag;\n            return re;\n        })\n            .filter(p => !(this.isStart() && this.isEnd()) || !!p)\n            .join('|');\n    }\n    static #parseGlob(glob, hasMagic, noEmpty = false) {\n        let escaping = false;\n        let re = '';\n        let uflag = false;\n        for (let i = 0; i < glob.length; i++) {\n            const c = glob.charAt(i);\n            if (escaping) {\n                escaping = false;\n                re += (reSpecials.has(c) ? '\\\\' : '') + c;\n                continue;\n            }\n            if (c === '\\\\') {\n                if (i === glob.length - 1) {\n                    re += '\\\\\\\\';\n                }\n                else {\n                    escaping = true;\n                }\n                continue;\n            }\n            if (c === '[') {\n                const [src, needUflag, consumed, magic] = (0, brace_expressions_js_1.parseClass)(glob, i);\n                if (consumed) {\n                    re += src;\n                    uflag = uflag || needUflag;\n                    i += consumed - 1;\n                    hasMagic = hasMagic || magic;\n                    continue;\n                }\n            }\n            if (c === '*') {\n                if (noEmpty && glob === '*')\n                    re += starNoEmpty;\n                else\n                    re += star;\n                hasMagic = true;\n                continue;\n            }\n            if (c === '?') {\n                re += qmark;\n                hasMagic = true;\n                continue;\n            }\n            re += regExpEscape(c);\n        }\n        return [re, (0, unescape_js_1.unescape)(glob), !!hasMagic, uflag];\n    }\n}\nexports.AST = AST;\n//# sourceMappingURL=ast.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbWluaW1hdGNoL2Rpc3QvY29tbW9uanMvYXN0LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsV0FBVztBQUNYLCtCQUErQixtQkFBTyxDQUFDLGlHQUF3QjtBQUMvRCxzQkFBc0IsbUJBQU8sQ0FBQywrRUFBZTtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDLDhDQUE4QztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxrQ0FBa0M7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHVCQUF1QjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxHQUFHO0FBQy9DO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixLQUFLLE1BQU0sZUFBZTtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsVUFBVTtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixpQkFBaUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1giLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hdXRvLWxvb3AtZGVtby8uL25vZGVfbW9kdWxlcy9taW5pbWF0Y2gvZGlzdC9jb21tb25qcy9hc3QuanM/YjBlNyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8vIHBhcnNlIGEgc2luZ2xlIHBhdGggcG9ydGlvblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5BU1QgPSB2b2lkIDA7XG5jb25zdCBicmFjZV9leHByZXNzaW9uc19qc18xID0gcmVxdWlyZShcIi4vYnJhY2UtZXhwcmVzc2lvbnMuanNcIik7XG5jb25zdCB1bmVzY2FwZV9qc18xID0gcmVxdWlyZShcIi4vdW5lc2NhcGUuanNcIik7XG5jb25zdCB0eXBlcyA9IG5ldyBTZXQoWychJywgJz8nLCAnKycsICcqJywgJ0AnXSk7XG5jb25zdCBpc0V4dGdsb2JUeXBlID0gKGMpID0+IHR5cGVzLmhhcyhjKTtcbi8vIFBhdHRlcm5zIHRoYXQgZ2V0IHByZXBlbmRlZCB0byBiaW5kIHRvIHRoZSBzdGFydCBvZiBlaXRoZXIgdGhlXG4vLyBlbnRpcmUgc3RyaW5nLCBvciBqdXN0IGEgc2luZ2xlIHBhdGggcG9ydGlvbiwgdG8gcHJldmVudCBkb3RzXG4vLyBhbmQvb3IgdHJhdmVyc2FsIHBhdHRlcm5zLCB3aGVuIG5lZWRlZC5cbi8vIEV4dHMgZG9uJ3QgbmVlZCB0aGUgXiBvciAvIGJpdCwgYmVjYXVzZSB0aGUgcm9vdCBiaW5kcyB0aGF0IGFscmVhZHkuXG5jb25zdCBzdGFydE5vVHJhdmVyc2FsID0gJyg/ISg/Ol58LylcXFxcLlxcXFwuPyg/OiR8LykpJztcbmNvbnN0IHN0YXJ0Tm9Eb3QgPSAnKD8hXFxcXC4pJztcbi8vIGNoYXJhY3RlcnMgdGhhdCBpbmRpY2F0ZSBhIHN0YXJ0IG9mIHBhdHRlcm4gbmVlZHMgdGhlIFwibm8gZG90c1wiIGJpdCxcbi8vIGJlY2F1c2UgYSBkb3QgKm1pZ2h0KiBiZSBtYXRjaGVkLiAoIGlzIG5vdCBpbiB0aGUgbGlzdCwgYmVjYXVzZSBpblxuLy8gdGhlIGNhc2Ugb2YgYSBjaGlsZCBleHRnbG9iLCBpdCB3aWxsIGhhbmRsZSB0aGUgcHJldmVudGlvbiBpdHNlbGYuXG5jb25zdCBhZGRQYXR0ZXJuU3RhcnQgPSBuZXcgU2V0KFsnWycsICcuJ10pO1xuLy8gY2FzZXMgd2hlcmUgdHJhdmVyc2FsIGlzIEEtT0ssIG5vIGRvdCBwcmV2ZW50aW9uIG5lZWRlZFxuY29uc3QganVzdERvdHMgPSBuZXcgU2V0KFsnLi4nLCAnLiddKTtcbmNvbnN0IHJlU3BlY2lhbHMgPSBuZXcgU2V0KCcoKS4qe30rP1tdXiRcXFxcIScpO1xuY29uc3QgcmVnRXhwRXNjYXBlID0gKHMpID0+IHMucmVwbGFjZSgvWy1bXFxde30oKSorPy4sXFxcXF4kfCNcXHNdL2csICdcXFxcJCYnKTtcbi8vIGFueSBzaW5nbGUgdGhpbmcgb3RoZXIgdGhhbiAvXG5jb25zdCBxbWFyayA9ICdbXi9dJztcbi8vICogPT4gYW55IG51bWJlciBvZiBjaGFyYWN0ZXJzXG5jb25zdCBzdGFyID0gcW1hcmsgKyAnKj8nO1xuLy8gdXNlICsgd2hlbiB3ZSBuZWVkIHRvIGVuc3VyZSB0aGF0ICpzb21ldGhpbmcqIG1hdGNoZXMsIGJlY2F1c2UgdGhlICogaXNcbi8vIHRoZSBvbmx5IHRoaW5nIGluIHRoZSBwYXRoIHBvcnRpb24uXG5jb25zdCBzdGFyTm9FbXB0eSA9IHFtYXJrICsgJys/Jztcbi8vIHJlbW92ZSB0aGUgXFwgY2hhcnMgdGhhdCB3ZSBhZGRlZCBpZiB3ZSBlbmQgdXAgZG9pbmcgYSBub25tYWdpYyBjb21wYXJlXG4vLyBjb25zdCBkZXNsYXNoID0gKHM6IHN0cmluZykgPT4gcy5yZXBsYWNlKC9cXFxcKC4pL2csICckMScpXG5jbGFzcyBBU1Qge1xuICAgIHR5cGU7XG4gICAgI3Jvb3Q7XG4gICAgI2hhc01hZ2ljO1xuICAgICN1ZmxhZyA9IGZhbHNlO1xuICAgICNwYXJ0cyA9IFtdO1xuICAgICNwYXJlbnQ7XG4gICAgI3BhcmVudEluZGV4O1xuICAgICNuZWdzO1xuICAgICNmaWxsZWROZWdzID0gZmFsc2U7XG4gICAgI29wdGlvbnM7XG4gICAgI3RvU3RyaW5nO1xuICAgIC8vIHNldCB0byB0cnVlIGlmIGl0J3MgYW4gZXh0Z2xvYiB3aXRoIG5vIGNoaWxkcmVuXG4gICAgLy8gKHdoaWNoIHJlYWxseSBtZWFucyBvbmUgY2hpbGQgb2YgJycpXG4gICAgI2VtcHR5RXh0ID0gZmFsc2U7XG4gICAgY29uc3RydWN0b3IodHlwZSwgcGFyZW50LCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICAgICAgLy8gZXh0Z2xvYnMgYXJlIGluaGVyZW50bHkgbWFnaWNhbFxuICAgICAgICBpZiAodHlwZSlcbiAgICAgICAgICAgIHRoaXMuI2hhc01hZ2ljID0gdHJ1ZTtcbiAgICAgICAgdGhpcy4jcGFyZW50ID0gcGFyZW50O1xuICAgICAgICB0aGlzLiNyb290ID0gdGhpcy4jcGFyZW50ID8gdGhpcy4jcGFyZW50LiNyb290IDogdGhpcztcbiAgICAgICAgdGhpcy4jb3B0aW9ucyA9IHRoaXMuI3Jvb3QgPT09IHRoaXMgPyBvcHRpb25zIDogdGhpcy4jcm9vdC4jb3B0aW9ucztcbiAgICAgICAgdGhpcy4jbmVncyA9IHRoaXMuI3Jvb3QgPT09IHRoaXMgPyBbXSA6IHRoaXMuI3Jvb3QuI25lZ3M7XG4gICAgICAgIGlmICh0eXBlID09PSAnIScgJiYgIXRoaXMuI3Jvb3QuI2ZpbGxlZE5lZ3MpXG4gICAgICAgICAgICB0aGlzLiNuZWdzLnB1c2godGhpcyk7XG4gICAgICAgIHRoaXMuI3BhcmVudEluZGV4ID0gdGhpcy4jcGFyZW50ID8gdGhpcy4jcGFyZW50LiNwYXJ0cy5sZW5ndGggOiAwO1xuICAgIH1cbiAgICBnZXQgaGFzTWFnaWMoKSB7XG4gICAgICAgIC8qIGM4IGlnbm9yZSBzdGFydCAqL1xuICAgICAgICBpZiAodGhpcy4jaGFzTWFnaWMgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHJldHVybiB0aGlzLiNoYXNNYWdpYztcbiAgICAgICAgLyogYzggaWdub3JlIHN0b3AgKi9cbiAgICAgICAgZm9yIChjb25zdCBwIG9mIHRoaXMuI3BhcnRzKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHAgPT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgaWYgKHAudHlwZSB8fCBwLmhhc01hZ2ljKVxuICAgICAgICAgICAgICAgIHJldHVybiAodGhpcy4jaGFzTWFnaWMgPSB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBub3RlOiB3aWxsIGJlIHVuZGVmaW5lZCB1bnRpbCB3ZSBnZW5lcmF0ZSB0aGUgcmVnZXhwIHNyYyBhbmQgZmluZCBvdXRcbiAgICAgICAgcmV0dXJuIHRoaXMuI2hhc01hZ2ljO1xuICAgIH1cbiAgICAvLyByZWNvbnN0cnVjdHMgdGhlIHBhdHRlcm5cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgaWYgKHRoaXMuI3RvU3RyaW5nICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy4jdG9TdHJpbmc7XG4gICAgICAgIGlmICghdGhpcy50eXBlKSB7XG4gICAgICAgICAgICByZXR1cm4gKHRoaXMuI3RvU3RyaW5nID0gdGhpcy4jcGFydHMubWFwKHAgPT4gU3RyaW5nKHApKS5qb2luKCcnKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gKHRoaXMuI3RvU3RyaW5nID1cbiAgICAgICAgICAgICAgICB0aGlzLnR5cGUgKyAnKCcgKyB0aGlzLiNwYXJ0cy5tYXAocCA9PiBTdHJpbmcocCkpLmpvaW4oJ3wnKSArICcpJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgI2ZpbGxOZWdzKCkge1xuICAgICAgICAvKiBjOCBpZ25vcmUgc3RhcnQgKi9cbiAgICAgICAgaWYgKHRoaXMgIT09IHRoaXMuI3Jvb3QpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Nob3VsZCBvbmx5IGNhbGwgb24gcm9vdCcpO1xuICAgICAgICBpZiAodGhpcy4jZmlsbGVkTmVncylcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAvKiBjOCBpZ25vcmUgc3RvcCAqL1xuICAgICAgICAvLyBjYWxsIHRvU3RyaW5nKCkgb25jZSB0byBmaWxsIHRoaXMgb3V0XG4gICAgICAgIHRoaXMudG9TdHJpbmcoKTtcbiAgICAgICAgdGhpcy4jZmlsbGVkTmVncyA9IHRydWU7XG4gICAgICAgIGxldCBuO1xuICAgICAgICB3aGlsZSAoKG4gPSB0aGlzLiNuZWdzLnBvcCgpKSkge1xuICAgICAgICAgICAgaWYgKG4udHlwZSAhPT0gJyEnKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgLy8gd2FsayB1cCB0aGUgdHJlZSwgYXBwZW5kaW5nIGV2ZXJ0aGluZyB0aGF0IGNvbWVzIEFGVEVSIHBhcmVudEluZGV4XG4gICAgICAgICAgICBsZXQgcCA9IG47XG4gICAgICAgICAgICBsZXQgcHAgPSBwLiNwYXJlbnQ7XG4gICAgICAgICAgICB3aGlsZSAocHApIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gcC4jcGFyZW50SW5kZXggKyAxOyAhcHAudHlwZSAmJiBpIDwgcHAuI3BhcnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgcGFydCBvZiBuLiNwYXJ0cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLyogYzggaWdub3JlIHN0YXJ0ICovXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHBhcnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzdHJpbmcgcGFydCBpbiBleHRnbG9iIEFTVD8/Jyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvKiBjOCBpZ25vcmUgc3RvcCAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFydC5jb3B5SW4ocHAuI3BhcnRzW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwID0gcHA7XG4gICAgICAgICAgICAgICAgcHAgPSBwLiNwYXJlbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHB1c2goLi4ucGFydHMpIHtcbiAgICAgICAgZm9yIChjb25zdCBwIG9mIHBhcnRzKSB7XG4gICAgICAgICAgICBpZiAocCA9PT0gJycpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAvKiBjOCBpZ25vcmUgc3RhcnQgKi9cbiAgICAgICAgICAgIGlmICh0eXBlb2YgcCAhPT0gJ3N0cmluZycgJiYgIShwIGluc3RhbmNlb2YgQVNUICYmIHAuI3BhcmVudCA9PT0gdGhpcykpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgcGFydDogJyArIHApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLyogYzggaWdub3JlIHN0b3AgKi9cbiAgICAgICAgICAgIHRoaXMuI3BhcnRzLnB1c2gocCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdG9KU09OKCkge1xuICAgICAgICBjb25zdCByZXQgPSB0aGlzLnR5cGUgPT09IG51bGxcbiAgICAgICAgICAgID8gdGhpcy4jcGFydHMuc2xpY2UoKS5tYXAocCA9PiAodHlwZW9mIHAgPT09ICdzdHJpbmcnID8gcCA6IHAudG9KU09OKCkpKVxuICAgICAgICAgICAgOiBbdGhpcy50eXBlLCAuLi50aGlzLiNwYXJ0cy5tYXAocCA9PiBwLnRvSlNPTigpKV07XG4gICAgICAgIGlmICh0aGlzLmlzU3RhcnQoKSAmJiAhdGhpcy50eXBlKVxuICAgICAgICAgICAgcmV0LnVuc2hpZnQoW10pO1xuICAgICAgICBpZiAodGhpcy5pc0VuZCgpICYmXG4gICAgICAgICAgICAodGhpcyA9PT0gdGhpcy4jcm9vdCB8fFxuICAgICAgICAgICAgICAgICh0aGlzLiNyb290LiNmaWxsZWROZWdzICYmIHRoaXMuI3BhcmVudD8udHlwZSA9PT0gJyEnKSkpIHtcbiAgICAgICAgICAgIHJldC5wdXNoKHt9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgICBpc1N0YXJ0KCkge1xuICAgICAgICBpZiAodGhpcy4jcm9vdCA9PT0gdGhpcylcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAvLyBpZiAodGhpcy50eXBlKSByZXR1cm4gISF0aGlzLiNwYXJlbnQ/LmlzU3RhcnQoKVxuICAgICAgICBpZiAoIXRoaXMuI3BhcmVudD8uaXNTdGFydCgpKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAodGhpcy4jcGFyZW50SW5kZXggPT09IDApXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgLy8gaWYgZXZlcnl0aGluZyBBSEVBRCBvZiB0aGlzIGlzIGEgbmVnYXRpb24sIHRoZW4gaXQncyBzdGlsbCB0aGUgXCJzdGFydFwiXG4gICAgICAgIGNvbnN0IHAgPSB0aGlzLiNwYXJlbnQ7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy4jcGFyZW50SW5kZXg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgcHAgPSBwLiNwYXJ0c1tpXTtcbiAgICAgICAgICAgIGlmICghKHBwIGluc3RhbmNlb2YgQVNUICYmIHBwLnR5cGUgPT09ICchJykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlzRW5kKCkge1xuICAgICAgICBpZiAodGhpcy4jcm9vdCA9PT0gdGhpcylcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBpZiAodGhpcy4jcGFyZW50Py50eXBlID09PSAnIScpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgaWYgKCF0aGlzLiNwYXJlbnQ/LmlzRW5kKCkpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmICghdGhpcy50eXBlKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuI3BhcmVudD8uaXNFbmQoKTtcbiAgICAgICAgLy8gaWYgbm90IHJvb3QsIGl0J2xsIGFsd2F5cyBoYXZlIGEgcGFyZW50XG4gICAgICAgIC8qIGM4IGlnbm9yZSBzdGFydCAqL1xuICAgICAgICBjb25zdCBwbCA9IHRoaXMuI3BhcmVudCA/IHRoaXMuI3BhcmVudC4jcGFydHMubGVuZ3RoIDogMDtcbiAgICAgICAgLyogYzggaWdub3JlIHN0b3AgKi9cbiAgICAgICAgcmV0dXJuIHRoaXMuI3BhcmVudEluZGV4ID09PSBwbCAtIDE7XG4gICAgfVxuICAgIGNvcHlJbihwYXJ0KSB7XG4gICAgICAgIGlmICh0eXBlb2YgcGFydCA9PT0gJ3N0cmluZycpXG4gICAgICAgICAgICB0aGlzLnB1c2gocGFydCk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRoaXMucHVzaChwYXJ0LmNsb25lKHRoaXMpKTtcbiAgICB9XG4gICAgY2xvbmUocGFyZW50KSB7XG4gICAgICAgIGNvbnN0IGMgPSBuZXcgQVNUKHRoaXMudHlwZSwgcGFyZW50KTtcbiAgICAgICAgZm9yIChjb25zdCBwIG9mIHRoaXMuI3BhcnRzKSB7XG4gICAgICAgICAgICBjLmNvcHlJbihwKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYztcbiAgICB9XG4gICAgc3RhdGljICNwYXJzZUFTVChzdHIsIGFzdCwgcG9zLCBvcHQpIHtcbiAgICAgICAgbGV0IGVzY2FwaW5nID0gZmFsc2U7XG4gICAgICAgIGxldCBpbkJyYWNlID0gZmFsc2U7XG4gICAgICAgIGxldCBicmFjZVN0YXJ0ID0gLTE7XG4gICAgICAgIGxldCBicmFjZU5lZyA9IGZhbHNlO1xuICAgICAgICBpZiAoYXN0LnR5cGUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIG91dHNpZGUgb2YgYSBleHRnbG9iLCBhcHBlbmQgdW50aWwgd2UgZmluZCBhIHN0YXJ0XG4gICAgICAgICAgICBsZXQgaSA9IHBvcztcbiAgICAgICAgICAgIGxldCBhY2MgPSAnJztcbiAgICAgICAgICAgIHdoaWxlIChpIDwgc3RyLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGMgPSBzdHIuY2hhckF0KGkrKyk7XG4gICAgICAgICAgICAgICAgLy8gc3RpbGwgYWNjdW11bGF0ZSBlc2NhcGVzIGF0IHRoaXMgcG9pbnQsIGJ1dCB3ZSBkbyBpZ25vcmVcbiAgICAgICAgICAgICAgICAvLyBzdGFydHMgdGhhdCBhcmUgZXNjYXBlZFxuICAgICAgICAgICAgICAgIGlmIChlc2NhcGluZyB8fCBjID09PSAnXFxcXCcpIHtcbiAgICAgICAgICAgICAgICAgICAgZXNjYXBpbmcgPSAhZXNjYXBpbmc7XG4gICAgICAgICAgICAgICAgICAgIGFjYyArPSBjO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGluQnJhY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGkgPT09IGJyYWNlU3RhcnQgKyAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYyA9PT0gJ14nIHx8IGMgPT09ICchJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyYWNlTmVnID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChjID09PSAnXScgJiYgIShpID09PSBicmFjZVN0YXJ0ICsgMiAmJiBicmFjZU5lZykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluQnJhY2UgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBhY2MgKz0gYztcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGMgPT09ICdbJykge1xuICAgICAgICAgICAgICAgICAgICBpbkJyYWNlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgYnJhY2VTdGFydCA9IGk7XG4gICAgICAgICAgICAgICAgICAgIGJyYWNlTmVnID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGFjYyArPSBjO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFvcHQubm9leHQgJiYgaXNFeHRnbG9iVHlwZShjKSAmJiBzdHIuY2hhckF0KGkpID09PSAnKCcpIHtcbiAgICAgICAgICAgICAgICAgICAgYXN0LnB1c2goYWNjKTtcbiAgICAgICAgICAgICAgICAgICAgYWNjID0gJyc7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGV4dCA9IG5ldyBBU1QoYywgYXN0KTtcbiAgICAgICAgICAgICAgICAgICAgaSA9IEFTVC4jcGFyc2VBU1Qoc3RyLCBleHQsIGksIG9wdCk7XG4gICAgICAgICAgICAgICAgICAgIGFzdC5wdXNoKGV4dCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhY2MgKz0gYztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFzdC5wdXNoKGFjYyk7XG4gICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgfVxuICAgICAgICAvLyBzb21lIGtpbmQgb2YgZXh0Z2xvYiwgcG9zIGlzIGF0IHRoZSAoXG4gICAgICAgIC8vIGZpbmQgdGhlIG5leHQgfCBvciApXG4gICAgICAgIGxldCBpID0gcG9zICsgMTtcbiAgICAgICAgbGV0IHBhcnQgPSBuZXcgQVNUKG51bGwsIGFzdCk7XG4gICAgICAgIGNvbnN0IHBhcnRzID0gW107XG4gICAgICAgIGxldCBhY2MgPSAnJztcbiAgICAgICAgd2hpbGUgKGkgPCBzdHIubGVuZ3RoKSB7XG4gICAgICAgICAgICBjb25zdCBjID0gc3RyLmNoYXJBdChpKyspO1xuICAgICAgICAgICAgLy8gc3RpbGwgYWNjdW11bGF0ZSBlc2NhcGVzIGF0IHRoaXMgcG9pbnQsIGJ1dCB3ZSBkbyBpZ25vcmVcbiAgICAgICAgICAgIC8vIHN0YXJ0cyB0aGF0IGFyZSBlc2NhcGVkXG4gICAgICAgICAgICBpZiAoZXNjYXBpbmcgfHwgYyA9PT0gJ1xcXFwnKSB7XG4gICAgICAgICAgICAgICAgZXNjYXBpbmcgPSAhZXNjYXBpbmc7XG4gICAgICAgICAgICAgICAgYWNjICs9IGM7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaW5CcmFjZSkge1xuICAgICAgICAgICAgICAgIGlmIChpID09PSBicmFjZVN0YXJ0ICsgMSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYyA9PT0gJ14nIHx8IGMgPT09ICchJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJhY2VOZWcgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGMgPT09ICddJyAmJiAhKGkgPT09IGJyYWNlU3RhcnQgKyAyICYmIGJyYWNlTmVnKSkge1xuICAgICAgICAgICAgICAgICAgICBpbkJyYWNlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGFjYyArPSBjO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYyA9PT0gJ1snKSB7XG4gICAgICAgICAgICAgICAgaW5CcmFjZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgYnJhY2VTdGFydCA9IGk7XG4gICAgICAgICAgICAgICAgYnJhY2VOZWcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBhY2MgKz0gYztcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc0V4dGdsb2JUeXBlKGMpICYmIHN0ci5jaGFyQXQoaSkgPT09ICcoJykge1xuICAgICAgICAgICAgICAgIHBhcnQucHVzaChhY2MpO1xuICAgICAgICAgICAgICAgIGFjYyA9ICcnO1xuICAgICAgICAgICAgICAgIGNvbnN0IGV4dCA9IG5ldyBBU1QoYywgcGFydCk7XG4gICAgICAgICAgICAgICAgcGFydC5wdXNoKGV4dCk7XG4gICAgICAgICAgICAgICAgaSA9IEFTVC4jcGFyc2VBU1Qoc3RyLCBleHQsIGksIG9wdCk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYyA9PT0gJ3wnKSB7XG4gICAgICAgICAgICAgICAgcGFydC5wdXNoKGFjYyk7XG4gICAgICAgICAgICAgICAgYWNjID0gJyc7XG4gICAgICAgICAgICAgICAgcGFydHMucHVzaChwYXJ0KTtcbiAgICAgICAgICAgICAgICBwYXJ0ID0gbmV3IEFTVChudWxsLCBhc3QpO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGMgPT09ICcpJykge1xuICAgICAgICAgICAgICAgIGlmIChhY2MgPT09ICcnICYmIGFzdC4jcGFydHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGFzdC4jZW1wdHlFeHQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwYXJ0LnB1c2goYWNjKTtcbiAgICAgICAgICAgICAgICBhY2MgPSAnJztcbiAgICAgICAgICAgICAgICBhc3QucHVzaCguLi5wYXJ0cywgcGFydCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhY2MgKz0gYztcbiAgICAgICAgfVxuICAgICAgICAvLyB1bmZpbmlzaGVkIGV4dGdsb2JcbiAgICAgICAgLy8gaWYgd2UgZ290IGhlcmUsIGl0IHdhcyBhIG1hbGZvcm1lZCBleHRnbG9iISBub3QgYW4gZXh0Z2xvYiwgYnV0XG4gICAgICAgIC8vIG1heWJlIHNvbWV0aGluZyBlbHNlIGluIHRoZXJlLlxuICAgICAgICBhc3QudHlwZSA9IG51bGw7XG4gICAgICAgIGFzdC4jaGFzTWFnaWMgPSB1bmRlZmluZWQ7XG4gICAgICAgIGFzdC4jcGFydHMgPSBbc3RyLnN1YnN0cmluZyhwb3MgLSAxKV07XG4gICAgICAgIHJldHVybiBpO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbUdsb2IocGF0dGVybiwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIGNvbnN0IGFzdCA9IG5ldyBBU1QobnVsbCwgdW5kZWZpbmVkLCBvcHRpb25zKTtcbiAgICAgICAgQVNULiNwYXJzZUFTVChwYXR0ZXJuLCBhc3QsIDAsIG9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gYXN0O1xuICAgIH1cbiAgICAvLyByZXR1cm5zIHRoZSByZWd1bGFyIGV4cHJlc3Npb24gaWYgdGhlcmUncyBtYWdpYywgb3IgdGhlIHVuZXNjYXBlZFxuICAgIC8vIHN0cmluZyBpZiBub3QuXG4gICAgdG9NTVBhdHRlcm4oKSB7XG4gICAgICAgIC8vIHNob3VsZCBvbmx5IGJlIGNhbGxlZCBvbiByb290XG4gICAgICAgIC8qIGM4IGlnbm9yZSBzdGFydCAqL1xuICAgICAgICBpZiAodGhpcyAhPT0gdGhpcy4jcm9vdClcbiAgICAgICAgICAgIHJldHVybiB0aGlzLiNyb290LnRvTU1QYXR0ZXJuKCk7XG4gICAgICAgIC8qIGM4IGlnbm9yZSBzdG9wICovXG4gICAgICAgIGNvbnN0IGdsb2IgPSB0aGlzLnRvU3RyaW5nKCk7XG4gICAgICAgIGNvbnN0IFtyZSwgYm9keSwgaGFzTWFnaWMsIHVmbGFnXSA9IHRoaXMudG9SZWdFeHBTb3VyY2UoKTtcbiAgICAgICAgLy8gaWYgd2UncmUgaW4gbm9jYXNlIG1vZGUsIGFuZCBub3Qgbm9jYXNlTWFnaWNPbmx5LCB0aGVuIHdlIGRvXG4gICAgICAgIC8vIHN0aWxsIG5lZWQgYSByZWd1bGFyIGV4cHJlc3Npb24gaWYgd2UgaGF2ZSB0byBjYXNlLWluc2Vuc2l0aXZlbHlcbiAgICAgICAgLy8gbWF0Y2ggY2FwaXRhbC9sb3dlcmNhc2UgY2hhcmFjdGVycy5cbiAgICAgICAgY29uc3QgYW55TWFnaWMgPSBoYXNNYWdpYyB8fFxuICAgICAgICAgICAgdGhpcy4jaGFzTWFnaWMgfHxcbiAgICAgICAgICAgICh0aGlzLiNvcHRpb25zLm5vY2FzZSAmJlxuICAgICAgICAgICAgICAgICF0aGlzLiNvcHRpb25zLm5vY2FzZU1hZ2ljT25seSAmJlxuICAgICAgICAgICAgICAgIGdsb2IudG9VcHBlckNhc2UoKSAhPT0gZ2xvYi50b0xvd2VyQ2FzZSgpKTtcbiAgICAgICAgaWYgKCFhbnlNYWdpYykge1xuICAgICAgICAgICAgcmV0dXJuIGJvZHk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZmxhZ3MgPSAodGhpcy4jb3B0aW9ucy5ub2Nhc2UgPyAnaScgOiAnJykgKyAodWZsYWcgPyAndScgOiAnJyk7XG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKG5ldyBSZWdFeHAoYF4ke3JlfSRgLCBmbGFncyksIHtcbiAgICAgICAgICAgIF9zcmM6IHJlLFxuICAgICAgICAgICAgX2dsb2I6IGdsb2IsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXQgb3B0aW9ucygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI29wdGlvbnM7XG4gICAgfVxuICAgIC8vIHJldHVybnMgdGhlIHN0cmluZyBtYXRjaCwgdGhlIHJlZ2V4cCBzb3VyY2UsIHdoZXRoZXIgdGhlcmUncyBtYWdpY1xuICAgIC8vIGluIHRoZSByZWdleHAgKHNvIGEgcmVndWxhciBleHByZXNzaW9uIGlzIHJlcXVpcmVkKSBhbmQgd2hldGhlciBvclxuICAgIC8vIG5vdCB0aGUgdWZsYWcgaXMgbmVlZGVkIGZvciB0aGUgcmVndWxhciBleHByZXNzaW9uIChmb3IgcG9zaXggY2xhc3NlcylcbiAgICAvLyBUT0RPOiBpbnN0ZWFkIG9mIGluamVjdGluZyB0aGUgc3RhcnQvZW5kIGF0IHRoaXMgcG9pbnQsIGp1c3QgcmV0dXJuXG4gICAgLy8gdGhlIEJPRFkgb2YgdGhlIHJlZ2V4cCwgYWxvbmcgd2l0aCB0aGUgc3RhcnQvZW5kIHBvcnRpb25zIHN1aXRhYmxlXG4gICAgLy8gZm9yIGJpbmRpbmcgdGhlIHN0YXJ0L2VuZCBpbiBlaXRoZXIgYSBqb2luZWQgZnVsbC1wYXRoIG1ha2VSZSBjb250ZXh0XG4gICAgLy8gKHdoZXJlIHdlIGJpbmQgdG8gKF58LyksIG9yIGEgc3RhbmRhbG9uZSBtYXRjaFBhcnQgY29udGV4dCAod2hlcmVcbiAgICAvLyB3ZSBiaW5kIHRvIF4sIGFuZCBub3QgLykuICBPdGhlcndpc2Ugc2xhc2hlcyBnZXQgZHVwZWQhXG4gICAgLy9cbiAgICAvLyBJbiBwYXJ0LW1hdGNoaW5nIG1vZGUsIHRoZSBzdGFydCBpczpcbiAgICAvLyAtIGlmIG5vdCBpc1N0YXJ0OiBub3RoaW5nXG4gICAgLy8gLSBpZiB0cmF2ZXJzYWwgcG9zc2libGUsIGJ1dCBub3QgYWxsb3dlZDogXig/IVxcLlxcLj8kKVxuICAgIC8vIC0gaWYgZG90cyBhbGxvd2VkIG9yIG5vdCBwb3NzaWJsZTogXlxuICAgIC8vIC0gaWYgZG90cyBwb3NzaWJsZSBhbmQgbm90IGFsbG93ZWQ6IF4oPyFcXC4pXG4gICAgLy8gZW5kIGlzOlxuICAgIC8vIC0gaWYgbm90IGlzRW5kKCk6IG5vdGhpbmdcbiAgICAvLyAtIGVsc2U6ICRcbiAgICAvL1xuICAgIC8vIEluIGZ1bGwtcGF0aCBtYXRjaGluZyBtb2RlLCB3ZSBwdXQgdGhlIHNsYXNoIGF0IHRoZSBTVEFSVCBvZiB0aGVcbiAgICAvLyBwYXR0ZXJuLCBzbyBzdGFydCBpczpcbiAgICAvLyAtIGlmIGZpcnN0IHBhdHRlcm46IHNhbWUgYXMgcGFydC1tYXRjaGluZyBtb2RlXG4gICAgLy8gLSBpZiBub3QgaXNTdGFydCgpOiBub3RoaW5nXG4gICAgLy8gLSBpZiB0cmF2ZXJzYWwgcG9zc2libGUsIGJ1dCBub3QgYWxsb3dlZDogLyg/IVxcLlxcLj8oPzokfC8pKVxuICAgIC8vIC0gaWYgZG90cyBhbGxvd2VkIG9yIG5vdCBwb3NzaWJsZTogL1xuICAgIC8vIC0gaWYgZG90cyBwb3NzaWJsZSBhbmQgbm90IGFsbG93ZWQ6IC8oPyFcXC4pXG4gICAgLy8gZW5kIGlzOlxuICAgIC8vIC0gaWYgbGFzdCBwYXR0ZXJuLCBzYW1lIGFzIHBhcnQtbWF0Y2hpbmcgbW9kZVxuICAgIC8vIC0gZWxzZSBub3RoaW5nXG4gICAgLy9cbiAgICAvLyBBbHdheXMgcHV0IHRoZSAoPzokfC8pIG9uIG5lZ2F0ZWQgdGFpbHMsIHRob3VnaCwgYmVjYXVzZSB0aGF0IGhhcyB0byBiZVxuICAgIC8vIHRoZXJlIHRvIGJpbmQgdGhlIGVuZCBvZiB0aGUgbmVnYXRlZCBwYXR0ZXJuIHBvcnRpb24sIGFuZCBpdCdzIGVhc2llciB0b1xuICAgIC8vIGp1c3Qgc3RpY2sgaXQgaW4gbm93IHJhdGhlciB0aGFuIHRyeSB0byBpbmplY3QgaXQgbGF0ZXIgaW4gdGhlIG1pZGRsZSBvZlxuICAgIC8vIHRoZSBwYXR0ZXJuLlxuICAgIC8vXG4gICAgLy8gV2UgY2FuIGp1c3QgYWx3YXlzIHJldHVybiB0aGUgc2FtZSBlbmQsIGFuZCBsZWF2ZSBpdCB1cCB0byB0aGUgY2FsbGVyXG4gICAgLy8gdG8ga25vdyB3aGV0aGVyIGl0J3MgZ29pbmcgdG8gYmUgdXNlZCBqb2luZWQgb3IgaW4gcGFydHMuXG4gICAgLy8gQW5kLCBpZiB0aGUgc3RhcnQgaXMgYWRqdXN0ZWQgc2xpZ2h0bHksIGNhbiBkbyB0aGUgc2FtZSB0aGVyZTpcbiAgICAvLyAtIGlmIG5vdCBpc1N0YXJ0OiBub3RoaW5nXG4gICAgLy8gLSBpZiB0cmF2ZXJzYWwgcG9zc2libGUsIGJ1dCBub3QgYWxsb3dlZDogKD86L3xeKSg/IVxcLlxcLj8kKVxuICAgIC8vIC0gaWYgZG90cyBhbGxvd2VkIG9yIG5vdCBwb3NzaWJsZTogKD86L3xeKVxuICAgIC8vIC0gaWYgZG90cyBwb3NzaWJsZSBhbmQgbm90IGFsbG93ZWQ6ICg/Oi98XikoPyFcXC4pXG4gICAgLy9cbiAgICAvLyBCdXQgaXQncyBiZXR0ZXIgdG8gaGF2ZSBhIHNpbXBsZXIgYmluZGluZyB3aXRob3V0IGEgY29uZGl0aW9uYWwsIGZvclxuICAgIC8vIHBlcmZvcm1hbmNlLCBzbyBwcm9iYWJseSBiZXR0ZXIgdG8gcmV0dXJuIGJvdGggc3RhcnQgb3B0aW9ucy5cbiAgICAvL1xuICAgIC8vIFRoZW4gdGhlIGNhbGxlciBqdXN0IGlnbm9yZXMgdGhlIGVuZCBpZiBpdCdzIG5vdCB0aGUgZmlyc3QgcGF0dGVybixcbiAgICAvLyBhbmQgdGhlIHN0YXJ0IGFsd2F5cyBnZXRzIGFwcGxpZWQuXG4gICAgLy9cbiAgICAvLyBCdXQgdGhhdCdzIGFsd2F5cyBnb2luZyB0byBiZSAkIGlmIGl0J3MgdGhlIGVuZGluZyBwYXR0ZXJuLCBvciBub3RoaW5nLFxuICAgIC8vIHNvIHRoZSBjYWxsZXIgY2FuIGp1c3QgYXR0YWNoICQgYXQgdGhlIGVuZCBvZiB0aGUgcGF0dGVybiB3aGVuIGJ1aWxkaW5nLlxuICAgIC8vXG4gICAgLy8gU28gdGhlIHRvZG8gaXM6XG4gICAgLy8gLSBiZXR0ZXIgZGV0ZWN0IHdoYXQga2luZCBvZiBzdGFydCBpcyBuZWVkZWRcbiAgICAvLyAtIHJldHVybiBib3RoIGZsYXZvcnMgb2Ygc3RhcnRpbmcgcGF0dGVyblxuICAgIC8vIC0gYXR0YWNoICQgYXQgdGhlIGVuZCBvZiB0aGUgcGF0dGVybiB3aGVuIGNyZWF0aW5nIHRoZSBhY3R1YWwgUmVnRXhwXG4gICAgLy9cbiAgICAvLyBBaCwgYnV0IHdhaXQsIG5vLCB0aGF0IGFsbCBvbmx5IGFwcGxpZXMgdG8gdGhlIHJvb3Qgd2hlbiB0aGUgZmlyc3QgcGF0dGVyblxuICAgIC8vIGlzIG5vdCBhbiBleHRnbG9iLiBJZiB0aGUgZmlyc3QgcGF0dGVybiBJUyBhbiBleHRnbG9iLCB0aGVuIHdlIG5lZWQgYWxsXG4gICAgLy8gdGhhdCBkb3QgcHJldmVudGlvbiBiaXogdG8gbGl2ZSBpbiB0aGUgZXh0Z2xvYiBwb3J0aW9ucywgYmVjYXVzZSBlZ1xuICAgIC8vICsoKnwueCopIGNhbiBtYXRjaCAueHkgYnV0IG5vdCAueXguXG4gICAgLy9cbiAgICAvLyBTbywgcmV0dXJuIHRoZSB0d28gZmxhdm9ycyBpZiBpdCdzICNyb290IGFuZCB0aGUgZmlyc3QgY2hpbGQgaXMgbm90IGFuXG4gICAgLy8gQVNULCBvdGhlcndpc2UgbGVhdmUgaXQgdG8gdGhlIGNoaWxkIEFTVCB0byBoYW5kbGUgaXQsIGFuZCB0aGVyZSxcbiAgICAvLyB1c2UgdGhlICg/Ol58Lykgc3R5bGUgb2Ygc3RhcnQgYmluZGluZy5cbiAgICAvL1xuICAgIC8vIEV2ZW4gc2ltcGxpZmllZCBmdXJ0aGVyOlxuICAgIC8vIC0gU2luY2UgdGhlIHN0YXJ0IGZvciBhIGpvaW4gaXMgZWcgLyg/IVxcLikgYW5kIHRoZSBzdGFydCBmb3IgYSBwYXJ0XG4gICAgLy8gaXMgXig/IVxcLiksIHdlIGNhbiBqdXN0IHByZXBlbmQgKD8hXFwuKSB0byB0aGUgcGF0dGVybiAoZWl0aGVyIHJvb3RcbiAgICAvLyBvciBzdGFydCBvciB3aGF0ZXZlcikgYW5kIHByZXBlbmQgXiBvciAvIGF0IHRoZSBSZWdleHAgY29uc3RydWN0aW9uLlxuICAgIHRvUmVnRXhwU291cmNlKGFsbG93RG90KSB7XG4gICAgICAgIGNvbnN0IGRvdCA9IGFsbG93RG90ID8/ICEhdGhpcy4jb3B0aW9ucy5kb3Q7XG4gICAgICAgIGlmICh0aGlzLiNyb290ID09PSB0aGlzKVxuICAgICAgICAgICAgdGhpcy4jZmlsbE5lZ3MoKTtcbiAgICAgICAgaWYgKCF0aGlzLnR5cGUpIHtcbiAgICAgICAgICAgIGNvbnN0IG5vRW1wdHkgPSB0aGlzLmlzU3RhcnQoKSAmJiB0aGlzLmlzRW5kKCk7XG4gICAgICAgICAgICBjb25zdCBzcmMgPSB0aGlzLiNwYXJ0c1xuICAgICAgICAgICAgICAgIC5tYXAocCA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgW3JlLCBfLCBoYXNNYWdpYywgdWZsYWddID0gdHlwZW9mIHAgPT09ICdzdHJpbmcnXG4gICAgICAgICAgICAgICAgICAgID8gQVNULiNwYXJzZUdsb2IocCwgdGhpcy4jaGFzTWFnaWMsIG5vRW1wdHkpXG4gICAgICAgICAgICAgICAgICAgIDogcC50b1JlZ0V4cFNvdXJjZShhbGxvd0RvdCk7XG4gICAgICAgICAgICAgICAgdGhpcy4jaGFzTWFnaWMgPSB0aGlzLiNoYXNNYWdpYyB8fCBoYXNNYWdpYztcbiAgICAgICAgICAgICAgICB0aGlzLiN1ZmxhZyA9IHRoaXMuI3VmbGFnIHx8IHVmbGFnO1xuICAgICAgICAgICAgICAgIHJldHVybiByZTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLmpvaW4oJycpO1xuICAgICAgICAgICAgbGV0IHN0YXJ0ID0gJyc7XG4gICAgICAgICAgICBpZiAodGhpcy5pc1N0YXJ0KCkpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHRoaXMuI3BhcnRzWzBdID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICAvLyB0aGlzIGlzIHRoZSBzdHJpbmcgdGhhdCB3aWxsIG1hdGNoIHRoZSBzdGFydCBvZiB0aGUgcGF0dGVybixcbiAgICAgICAgICAgICAgICAgICAgLy8gc28gd2UgbmVlZCB0byBwcm90ZWN0IGFnYWluc3QgZG90cyBhbmQgc3VjaC5cbiAgICAgICAgICAgICAgICAgICAgLy8gJy4nIGFuZCAnLi4nIGNhbm5vdCBtYXRjaCB1bmxlc3MgdGhlIHBhdHRlcm4gaXMgdGhhdCBleGFjdGx5LFxuICAgICAgICAgICAgICAgICAgICAvLyBldmVuIGlmIGl0IHN0YXJ0cyB3aXRoIC4gb3IgZG90OnRydWUgaXMgc2V0LlxuICAgICAgICAgICAgICAgICAgICBjb25zdCBkb3RUcmF2QWxsb3dlZCA9IHRoaXMuI3BhcnRzLmxlbmd0aCA9PT0gMSAmJiBqdXN0RG90cy5oYXModGhpcy4jcGFydHNbMF0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWRvdFRyYXZBbGxvd2VkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBhcHMgPSBhZGRQYXR0ZXJuU3RhcnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjaGVjayBpZiB3ZSBoYXZlIGEgcG9zc2liaWxpdHkgb2YgbWF0Y2hpbmcgLiBvciAuLixcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFuZCBwcmV2ZW50IHRoYXQuXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBuZWVkTm9UcmF2ID0gXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBkb3RzIGFyZSBhbGxvd2VkLCBhbmQgdGhlIHBhdHRlcm4gc3RhcnRzIHdpdGggWyBvciAuXG4gICAgICAgICAgICAgICAgICAgICAgICAoZG90ICYmIGFwcy5oYXMoc3JjLmNoYXJBdCgwKSkpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhlIHBhdHRlcm4gc3RhcnRzIHdpdGggXFwuLCBhbmQgdGhlbiBbIG9yIC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoc3JjLnN0YXJ0c1dpdGgoJ1xcXFwuJykgJiYgYXBzLmhhcyhzcmMuY2hhckF0KDIpKSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGUgcGF0dGVybiBzdGFydHMgd2l0aCBcXC5cXC4sIGFuZCB0aGVuIFsgb3IgLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChzcmMuc3RhcnRzV2l0aCgnXFxcXC5cXFxcLicpICYmIGFwcy5oYXMoc3JjLmNoYXJBdCg0KSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbm8gbmVlZCB0byBwcmV2ZW50IGRvdHMgaWYgaXQgY2FuJ3QgbWF0Y2ggYSBkb3QsIG9yIGlmIGFcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHN1Yi1wYXR0ZXJuIHdpbGwgYmUgcHJldmVudGluZyBpdCBhbnl3YXkuXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBuZWVkTm9Eb3QgPSAhZG90ICYmICFhbGxvd0RvdCAmJiBhcHMuaGFzKHNyYy5jaGFyQXQoMCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQgPSBuZWVkTm9UcmF2ID8gc3RhcnROb1RyYXZlcnNhbCA6IG5lZWROb0RvdCA/IHN0YXJ0Tm9Eb3QgOiAnJztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGFwcGVuZCB0aGUgXCJlbmQgb2YgcGF0aCBwb3J0aW9uXCIgcGF0dGVybiB0byBuZWdhdGlvbiB0YWlsc1xuICAgICAgICAgICAgbGV0IGVuZCA9ICcnO1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNFbmQoKSAmJlxuICAgICAgICAgICAgICAgIHRoaXMuI3Jvb3QuI2ZpbGxlZE5lZ3MgJiZcbiAgICAgICAgICAgICAgICB0aGlzLiNwYXJlbnQ/LnR5cGUgPT09ICchJykge1xuICAgICAgICAgICAgICAgIGVuZCA9ICcoPzokfFxcXFwvKSc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBmaW5hbCA9IHN0YXJ0ICsgc3JjICsgZW5kO1xuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICBmaW5hbCxcbiAgICAgICAgICAgICAgICAoMCwgdW5lc2NhcGVfanNfMS51bmVzY2FwZSkoc3JjKSxcbiAgICAgICAgICAgICAgICAodGhpcy4jaGFzTWFnaWMgPSAhIXRoaXMuI2hhc01hZ2ljKSxcbiAgICAgICAgICAgICAgICB0aGlzLiN1ZmxhZyxcbiAgICAgICAgICAgIF07XG4gICAgICAgIH1cbiAgICAgICAgLy8gV2UgbmVlZCB0byBjYWxjdWxhdGUgdGhlIGJvZHkgKnR3aWNlKiBpZiBpdCdzIGEgcmVwZWF0IHBhdHRlcm5cbiAgICAgICAgLy8gYXQgdGhlIHN0YXJ0LCBvbmNlIGluIG5vZG90IG1vZGUsIHRoZW4gYWdhaW4gaW4gZG90IG1vZGUsIHNvIGFcbiAgICAgICAgLy8gcGF0dGVybiBsaWtlICooPykgY2FuIG1hdGNoICd4LnknXG4gICAgICAgIGNvbnN0IHJlcGVhdGVkID0gdGhpcy50eXBlID09PSAnKicgfHwgdGhpcy50eXBlID09PSAnKyc7XG4gICAgICAgIC8vIHNvbWUga2luZCBvZiBleHRnbG9iXG4gICAgICAgIGNvbnN0IHN0YXJ0ID0gdGhpcy50eXBlID09PSAnIScgPyAnKD86KD8hKD86JyA6ICcoPzonO1xuICAgICAgICBsZXQgYm9keSA9IHRoaXMuI3BhcnRzVG9SZWdFeHAoZG90KTtcbiAgICAgICAgaWYgKHRoaXMuaXNTdGFydCgpICYmIHRoaXMuaXNFbmQoKSAmJiAhYm9keSAmJiB0aGlzLnR5cGUgIT09ICchJykge1xuICAgICAgICAgICAgLy8gaW52YWxpZCBleHRnbG9iLCBoYXMgdG8gYXQgbGVhc3QgYmUgKnNvbWV0aGluZyogcHJlc2VudCwgaWYgaXQnc1xuICAgICAgICAgICAgLy8gdGhlIGVudGlyZSBwYXRoIHBvcnRpb24uXG4gICAgICAgICAgICBjb25zdCBzID0gdGhpcy50b1N0cmluZygpO1xuICAgICAgICAgICAgdGhpcy4jcGFydHMgPSBbc107XG4gICAgICAgICAgICB0aGlzLnR5cGUgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy4jaGFzTWFnaWMgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICByZXR1cm4gW3MsICgwLCB1bmVzY2FwZV9qc18xLnVuZXNjYXBlKSh0aGlzLnRvU3RyaW5nKCkpLCBmYWxzZSwgZmFsc2VdO1xuICAgICAgICB9XG4gICAgICAgIC8vIFhYWCBhYnN0cmFjdCBvdXQgdGhpcyBtYXAgbWV0aG9kXG4gICAgICAgIGxldCBib2R5RG90QWxsb3dlZCA9ICFyZXBlYXRlZCB8fCBhbGxvd0RvdCB8fCBkb3QgfHwgIXN0YXJ0Tm9Eb3RcbiAgICAgICAgICAgID8gJydcbiAgICAgICAgICAgIDogdGhpcy4jcGFydHNUb1JlZ0V4cCh0cnVlKTtcbiAgICAgICAgaWYgKGJvZHlEb3RBbGxvd2VkID09PSBib2R5KSB7XG4gICAgICAgICAgICBib2R5RG90QWxsb3dlZCA9ICcnO1xuICAgICAgICB9XG4gICAgICAgIGlmIChib2R5RG90QWxsb3dlZCkge1xuICAgICAgICAgICAgYm9keSA9IGAoPzoke2JvZHl9KSg/OiR7Ym9keURvdEFsbG93ZWR9KSo/YDtcbiAgICAgICAgfVxuICAgICAgICAvLyBhbiBlbXB0eSAhKCkgaXMgZXhhY3RseSBlcXVpdmFsZW50IHRvIGEgc3Rhck5vRW1wdHlcbiAgICAgICAgbGV0IGZpbmFsID0gJyc7XG4gICAgICAgIGlmICh0aGlzLnR5cGUgPT09ICchJyAmJiB0aGlzLiNlbXB0eUV4dCkge1xuICAgICAgICAgICAgZmluYWwgPSAodGhpcy5pc1N0YXJ0KCkgJiYgIWRvdCA/IHN0YXJ0Tm9Eb3QgOiAnJykgKyBzdGFyTm9FbXB0eTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGNsb3NlID0gdGhpcy50eXBlID09PSAnISdcbiAgICAgICAgICAgICAgICA/IC8vICEoKSBtdXN0IG1hdGNoIHNvbWV0aGluZyxidXQgISh4KSBjYW4gbWF0Y2ggJydcbiAgICAgICAgICAgICAgICAgICAgJykpJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAodGhpcy5pc1N0YXJ0KCkgJiYgIWRvdCAmJiAhYWxsb3dEb3QgPyBzdGFydE5vRG90IDogJycpICtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJyknXG4gICAgICAgICAgICAgICAgOiB0aGlzLnR5cGUgPT09ICdAJ1xuICAgICAgICAgICAgICAgICAgICA/ICcpJ1xuICAgICAgICAgICAgICAgICAgICA6IHRoaXMudHlwZSA9PT0gJz8nXG4gICAgICAgICAgICAgICAgICAgICAgICA/ICcpPydcbiAgICAgICAgICAgICAgICAgICAgICAgIDogdGhpcy50eXBlID09PSAnKycgJiYgYm9keURvdEFsbG93ZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/ICcpJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogdGhpcy50eXBlID09PSAnKicgJiYgYm9keURvdEFsbG93ZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBgKT9gXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogYCkke3RoaXMudHlwZX1gO1xuICAgICAgICAgICAgZmluYWwgPSBzdGFydCArIGJvZHkgKyBjbG9zZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgZmluYWwsXG4gICAgICAgICAgICAoMCwgdW5lc2NhcGVfanNfMS51bmVzY2FwZSkoYm9keSksXG4gICAgICAgICAgICAodGhpcy4jaGFzTWFnaWMgPSAhIXRoaXMuI2hhc01hZ2ljKSxcbiAgICAgICAgICAgIHRoaXMuI3VmbGFnLFxuICAgICAgICBdO1xuICAgIH1cbiAgICAjcGFydHNUb1JlZ0V4cChkb3QpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI3BhcnRzXG4gICAgICAgICAgICAubWFwKHAgPT4ge1xuICAgICAgICAgICAgLy8gZXh0Z2xvYiBBU1RzIHNob3VsZCBvbmx5IGNvbnRhaW4gcGFyZW50IEFTVHNcbiAgICAgICAgICAgIC8qIGM4IGlnbm9yZSBzdGFydCAqL1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBwID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignc3RyaW5nIHR5cGUgaW4gZXh0Z2xvYiBhc3Q/PycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLyogYzggaWdub3JlIHN0b3AgKi9cbiAgICAgICAgICAgIC8vIGNhbiBpZ25vcmUgaGFzTWFnaWMsIGJlY2F1c2UgZXh0Z2xvYnMgYXJlIGFscmVhZHkgYWx3YXlzIG1hZ2ljXG4gICAgICAgICAgICBjb25zdCBbcmUsIF8sIF9oYXNNYWdpYywgdWZsYWddID0gcC50b1JlZ0V4cFNvdXJjZShkb3QpO1xuICAgICAgICAgICAgdGhpcy4jdWZsYWcgPSB0aGlzLiN1ZmxhZyB8fCB1ZmxhZztcbiAgICAgICAgICAgIHJldHVybiByZTtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5maWx0ZXIocCA9PiAhKHRoaXMuaXNTdGFydCgpICYmIHRoaXMuaXNFbmQoKSkgfHwgISFwKVxuICAgICAgICAgICAgLmpvaW4oJ3wnKTtcbiAgICB9XG4gICAgc3RhdGljICNwYXJzZUdsb2IoZ2xvYiwgaGFzTWFnaWMsIG5vRW1wdHkgPSBmYWxzZSkge1xuICAgICAgICBsZXQgZXNjYXBpbmcgPSBmYWxzZTtcbiAgICAgICAgbGV0IHJlID0gJyc7XG4gICAgICAgIGxldCB1ZmxhZyA9IGZhbHNlO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGdsb2IubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGMgPSBnbG9iLmNoYXJBdChpKTtcbiAgICAgICAgICAgIGlmIChlc2NhcGluZykge1xuICAgICAgICAgICAgICAgIGVzY2FwaW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgcmUgKz0gKHJlU3BlY2lhbHMuaGFzKGMpID8gJ1xcXFwnIDogJycpICsgYztcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjID09PSAnXFxcXCcpIHtcbiAgICAgICAgICAgICAgICBpZiAoaSA9PT0gZ2xvYi5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlICs9ICdcXFxcXFxcXCc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBlc2NhcGluZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGMgPT09ICdbJykge1xuICAgICAgICAgICAgICAgIGNvbnN0IFtzcmMsIG5lZWRVZmxhZywgY29uc3VtZWQsIG1hZ2ljXSA9ICgwLCBicmFjZV9leHByZXNzaW9uc19qc18xLnBhcnNlQ2xhc3MpKGdsb2IsIGkpO1xuICAgICAgICAgICAgICAgIGlmIChjb25zdW1lZCkge1xuICAgICAgICAgICAgICAgICAgICByZSArPSBzcmM7XG4gICAgICAgICAgICAgICAgICAgIHVmbGFnID0gdWZsYWcgfHwgbmVlZFVmbGFnO1xuICAgICAgICAgICAgICAgICAgICBpICs9IGNvbnN1bWVkIC0gMTtcbiAgICAgICAgICAgICAgICAgICAgaGFzTWFnaWMgPSBoYXNNYWdpYyB8fCBtYWdpYztcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGMgPT09ICcqJykge1xuICAgICAgICAgICAgICAgIGlmIChub0VtcHR5ICYmIGdsb2IgPT09ICcqJylcbiAgICAgICAgICAgICAgICAgICAgcmUgKz0gc3Rhck5vRW1wdHk7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICByZSArPSBzdGFyO1xuICAgICAgICAgICAgICAgIGhhc01hZ2ljID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjID09PSAnPycpIHtcbiAgICAgICAgICAgICAgICByZSArPSBxbWFyaztcbiAgICAgICAgICAgICAgICBoYXNNYWdpYyA9IHRydWU7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZSArPSByZWdFeHBFc2NhcGUoYyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtyZSwgKDAsIHVuZXNjYXBlX2pzXzEudW5lc2NhcGUpKGdsb2IpLCAhIWhhc01hZ2ljLCB1ZmxhZ107XG4gICAgfVxufVxuZXhwb3J0cy5BU1QgPSBBU1Q7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hc3QuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/minimatch/dist/commonjs/ast.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/minimatch/dist/commonjs/brace-expressions.js":
/*!*******************************************************************!*\
  !*** ./node_modules/minimatch/dist/commonjs/brace-expressions.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n// translate the various posix character classes into unicode properties\n// this works across all unicode locales\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.parseClass = void 0;\n// { <posix class>: [<translation>, /u flag required, negated]\nconst posixClasses = {\n    '[:alnum:]': ['\\\\p{L}\\\\p{Nl}\\\\p{Nd}', true],\n    '[:alpha:]': ['\\\\p{L}\\\\p{Nl}', true],\n    '[:ascii:]': ['\\\\x' + '00-\\\\x' + '7f', false],\n    '[:blank:]': ['\\\\p{Zs}\\\\t', true],\n    '[:cntrl:]': ['\\\\p{Cc}', true],\n    '[:digit:]': ['\\\\p{Nd}', true],\n    '[:graph:]': ['\\\\p{Z}\\\\p{C}', true, true],\n    '[:lower:]': ['\\\\p{Ll}', true],\n    '[:print:]': ['\\\\p{C}', true],\n    '[:punct:]': ['\\\\p{P}', true],\n    '[:space:]': ['\\\\p{Z}\\\\t\\\\r\\\\n\\\\v\\\\f', true],\n    '[:upper:]': ['\\\\p{Lu}', true],\n    '[:word:]': ['\\\\p{L}\\\\p{Nl}\\\\p{Nd}\\\\p{Pc}', true],\n    '[:xdigit:]': ['A-Fa-f0-9', false],\n};\n// only need to escape a few things inside of brace expressions\n// escapes: [ \\ ] -\nconst braceEscape = (s) => s.replace(/[[\\]\\\\-]/g, '\\\\$&');\n// escape all regexp magic characters\nconst regexpEscape = (s) => s.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, '\\\\$&');\n// everything has already been escaped, we just have to join\nconst rangesToString = (ranges) => ranges.join('');\n// takes a glob string at a posix brace expression, and returns\n// an equivalent regular expression source, and boolean indicating\n// whether the /u flag needs to be applied, and the number of chars\n// consumed to parse the character class.\n// This also removes out of order ranges, and returns ($.) if the\n// entire class just no good.\nconst parseClass = (glob, position) => {\n    const pos = position;\n    /* c8 ignore start */\n    if (glob.charAt(pos) !== '[') {\n        throw new Error('not in a brace expression');\n    }\n    /* c8 ignore stop */\n    const ranges = [];\n    const negs = [];\n    let i = pos + 1;\n    let sawStart = false;\n    let uflag = false;\n    let escaping = false;\n    let negate = false;\n    let endPos = pos;\n    let rangeStart = '';\n    WHILE: while (i < glob.length) {\n        const c = glob.charAt(i);\n        if ((c === '!' || c === '^') && i === pos + 1) {\n            negate = true;\n            i++;\n            continue;\n        }\n        if (c === ']' && sawStart && !escaping) {\n            endPos = i + 1;\n            break;\n        }\n        sawStart = true;\n        if (c === '\\\\') {\n            if (!escaping) {\n                escaping = true;\n                i++;\n                continue;\n            }\n            // escaped \\ char, fall through and treat like normal char\n        }\n        if (c === '[' && !escaping) {\n            // either a posix class, a collation equivalent, or just a [\n            for (const [cls, [unip, u, neg]] of Object.entries(posixClasses)) {\n                if (glob.startsWith(cls, i)) {\n                    // invalid, [a-[] is fine, but not [a-[:alpha]]\n                    if (rangeStart) {\n                        return ['$.', false, glob.length - pos, true];\n                    }\n                    i += cls.length;\n                    if (neg)\n                        negs.push(unip);\n                    else\n                        ranges.push(unip);\n                    uflag = uflag || u;\n                    continue WHILE;\n                }\n            }\n        }\n        // now it's just a normal character, effectively\n        escaping = false;\n        if (rangeStart) {\n            // throw this range away if it's not valid, but others\n            // can still match.\n            if (c > rangeStart) {\n                ranges.push(braceEscape(rangeStart) + '-' + braceEscape(c));\n            }\n            else if (c === rangeStart) {\n                ranges.push(braceEscape(c));\n            }\n            rangeStart = '';\n            i++;\n            continue;\n        }\n        // now might be the start of a range.\n        // can be either c-d or c-] or c<more...>] or c] at this point\n        if (glob.startsWith('-]', i + 1)) {\n            ranges.push(braceEscape(c + '-'));\n            i += 2;\n            continue;\n        }\n        if (glob.startsWith('-', i + 1)) {\n            rangeStart = c;\n            i += 2;\n            continue;\n        }\n        // not the start of a range, just a single character\n        ranges.push(braceEscape(c));\n        i++;\n    }\n    if (endPos < i) {\n        // didn't see the end of the class, not a valid class,\n        // but might still be valid as a literal match.\n        return ['', false, 0, false];\n    }\n    // if we got no ranges and no negates, then we have a range that\n    // cannot possibly match anything, and that poisons the whole glob\n    if (!ranges.length && !negs.length) {\n        return ['$.', false, glob.length - pos, true];\n    }\n    // if we got one positive range, and it's a single character, then that's\n    // not actually a magic pattern, it's just that one literal character.\n    // we should not treat that as \"magic\", we should just return the literal\n    // character. [_] is a perfectly valid way to escape glob magic chars.\n    if (negs.length === 0 &&\n        ranges.length === 1 &&\n        /^\\\\?.$/.test(ranges[0]) &&\n        !negate) {\n        const r = ranges[0].length === 2 ? ranges[0].slice(-1) : ranges[0];\n        return [regexpEscape(r), false, endPos - pos, false];\n    }\n    const sranges = '[' + (negate ? '^' : '') + rangesToString(ranges) + ']';\n    const snegs = '[' + (negate ? '' : '^') + rangesToString(negs) + ']';\n    const comb = ranges.length && negs.length\n        ? '(' + sranges + '|' + snegs + ')'\n        : ranges.length\n            ? sranges\n            : snegs;\n    return [comb, uflag, endPos - pos, true];\n};\nexports.parseClass = parseClass;\n//# sourceMappingURL=brace-expressions.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbWluaW1hdGNoL2Rpc3QvY29tbW9uanMvYnJhY2UtZXhwcmVzc2lvbnMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGtCQUFrQjtBQUNsQixLQUFLO0FBQ0w7QUFDQSx1QkFBdUIsRUFBRSxJQUFJLEdBQUcsSUFBSSxHQUFHO0FBQ3ZDLHVCQUF1QixFQUFFLElBQUksR0FBRztBQUNoQztBQUNBLHVCQUF1QixHQUFHO0FBQzFCLHVCQUF1QixHQUFHO0FBQzFCLHVCQUF1QixHQUFHO0FBQzFCLHVCQUF1QixFQUFFLElBQUksRUFBRTtBQUMvQix1QkFBdUIsR0FBRztBQUMxQix1QkFBdUIsRUFBRTtBQUN6Qix1QkFBdUIsRUFBRTtBQUN6Qix1QkFBdUIsRUFBRTtBQUN6Qix1QkFBdUIsR0FBRztBQUMxQixzQkFBc0IsRUFBRSxJQUFJLEdBQUcsSUFBSSxHQUFHLElBQUksR0FBRztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYXV0by1sb29wLWRlbW8vLi9ub2RlX21vZHVsZXMvbWluaW1hdGNoL2Rpc3QvY29tbW9uanMvYnJhY2UtZXhwcmVzc2lvbnMuanM/NzA4ZCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8vIHRyYW5zbGF0ZSB0aGUgdmFyaW91cyBwb3NpeCBjaGFyYWN0ZXIgY2xhc3NlcyBpbnRvIHVuaWNvZGUgcHJvcGVydGllc1xuLy8gdGhpcyB3b3JrcyBhY3Jvc3MgYWxsIHVuaWNvZGUgbG9jYWxlc1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5wYXJzZUNsYXNzID0gdm9pZCAwO1xuLy8geyA8cG9zaXggY2xhc3M+OiBbPHRyYW5zbGF0aW9uPiwgL3UgZmxhZyByZXF1aXJlZCwgbmVnYXRlZF1cbmNvbnN0IHBvc2l4Q2xhc3NlcyA9IHtcbiAgICAnWzphbG51bTpdJzogWydcXFxccHtMfVxcXFxwe05sfVxcXFxwe05kfScsIHRydWVdLFxuICAgICdbOmFscGhhOl0nOiBbJ1xcXFxwe0x9XFxcXHB7Tmx9JywgdHJ1ZV0sXG4gICAgJ1s6YXNjaWk6XSc6IFsnXFxcXHgnICsgJzAwLVxcXFx4JyArICc3ZicsIGZhbHNlXSxcbiAgICAnWzpibGFuazpdJzogWydcXFxccHtac31cXFxcdCcsIHRydWVdLFxuICAgICdbOmNudHJsOl0nOiBbJ1xcXFxwe0NjfScsIHRydWVdLFxuICAgICdbOmRpZ2l0Ol0nOiBbJ1xcXFxwe05kfScsIHRydWVdLFxuICAgICdbOmdyYXBoOl0nOiBbJ1xcXFxwe1p9XFxcXHB7Q30nLCB0cnVlLCB0cnVlXSxcbiAgICAnWzpsb3dlcjpdJzogWydcXFxccHtMbH0nLCB0cnVlXSxcbiAgICAnWzpwcmludDpdJzogWydcXFxccHtDfScsIHRydWVdLFxuICAgICdbOnB1bmN0Ol0nOiBbJ1xcXFxwe1B9JywgdHJ1ZV0sXG4gICAgJ1s6c3BhY2U6XSc6IFsnXFxcXHB7Wn1cXFxcdFxcXFxyXFxcXG5cXFxcdlxcXFxmJywgdHJ1ZV0sXG4gICAgJ1s6dXBwZXI6XSc6IFsnXFxcXHB7THV9JywgdHJ1ZV0sXG4gICAgJ1s6d29yZDpdJzogWydcXFxccHtMfVxcXFxwe05sfVxcXFxwe05kfVxcXFxwe1BjfScsIHRydWVdLFxuICAgICdbOnhkaWdpdDpdJzogWydBLUZhLWYwLTknLCBmYWxzZV0sXG59O1xuLy8gb25seSBuZWVkIHRvIGVzY2FwZSBhIGZldyB0aGluZ3MgaW5zaWRlIG9mIGJyYWNlIGV4cHJlc3Npb25zXG4vLyBlc2NhcGVzOiBbIFxcIF0gLVxuY29uc3QgYnJhY2VFc2NhcGUgPSAocykgPT4gcy5yZXBsYWNlKC9bW1xcXVxcXFwtXS9nLCAnXFxcXCQmJyk7XG4vLyBlc2NhcGUgYWxsIHJlZ2V4cCBtYWdpYyBjaGFyYWN0ZXJzXG5jb25zdCByZWdleHBFc2NhcGUgPSAocykgPT4gcy5yZXBsYWNlKC9bLVtcXF17fSgpKis/LixcXFxcXiR8I1xcc10vZywgJ1xcXFwkJicpO1xuLy8gZXZlcnl0aGluZyBoYXMgYWxyZWFkeSBiZWVuIGVzY2FwZWQsIHdlIGp1c3QgaGF2ZSB0byBqb2luXG5jb25zdCByYW5nZXNUb1N0cmluZyA9IChyYW5nZXMpID0+IHJhbmdlcy5qb2luKCcnKTtcbi8vIHRha2VzIGEgZ2xvYiBzdHJpbmcgYXQgYSBwb3NpeCBicmFjZSBleHByZXNzaW9uLCBhbmQgcmV0dXJuc1xuLy8gYW4gZXF1aXZhbGVudCByZWd1bGFyIGV4cHJlc3Npb24gc291cmNlLCBhbmQgYm9vbGVhbiBpbmRpY2F0aW5nXG4vLyB3aGV0aGVyIHRoZSAvdSBmbGFnIG5lZWRzIHRvIGJlIGFwcGxpZWQsIGFuZCB0aGUgbnVtYmVyIG9mIGNoYXJzXG4vLyBjb25zdW1lZCB0byBwYXJzZSB0aGUgY2hhcmFjdGVyIGNsYXNzLlxuLy8gVGhpcyBhbHNvIHJlbW92ZXMgb3V0IG9mIG9yZGVyIHJhbmdlcywgYW5kIHJldHVybnMgKCQuKSBpZiB0aGVcbi8vIGVudGlyZSBjbGFzcyBqdXN0IG5vIGdvb2QuXG5jb25zdCBwYXJzZUNsYXNzID0gKGdsb2IsIHBvc2l0aW9uKSA9PiB7XG4gICAgY29uc3QgcG9zID0gcG9zaXRpb247XG4gICAgLyogYzggaWdub3JlIHN0YXJ0ICovXG4gICAgaWYgKGdsb2IuY2hhckF0KHBvcykgIT09ICdbJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ25vdCBpbiBhIGJyYWNlIGV4cHJlc3Npb24nKTtcbiAgICB9XG4gICAgLyogYzggaWdub3JlIHN0b3AgKi9cbiAgICBjb25zdCByYW5nZXMgPSBbXTtcbiAgICBjb25zdCBuZWdzID0gW107XG4gICAgbGV0IGkgPSBwb3MgKyAxO1xuICAgIGxldCBzYXdTdGFydCA9IGZhbHNlO1xuICAgIGxldCB1ZmxhZyA9IGZhbHNlO1xuICAgIGxldCBlc2NhcGluZyA9IGZhbHNlO1xuICAgIGxldCBuZWdhdGUgPSBmYWxzZTtcbiAgICBsZXQgZW5kUG9zID0gcG9zO1xuICAgIGxldCByYW5nZVN0YXJ0ID0gJyc7XG4gICAgV0hJTEU6IHdoaWxlIChpIDwgZ2xvYi5sZW5ndGgpIHtcbiAgICAgICAgY29uc3QgYyA9IGdsb2IuY2hhckF0KGkpO1xuICAgICAgICBpZiAoKGMgPT09ICchJyB8fCBjID09PSAnXicpICYmIGkgPT09IHBvcyArIDEpIHtcbiAgICAgICAgICAgIG5lZ2F0ZSA9IHRydWU7XG4gICAgICAgICAgICBpKys7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYyA9PT0gJ10nICYmIHNhd1N0YXJ0ICYmICFlc2NhcGluZykge1xuICAgICAgICAgICAgZW5kUG9zID0gaSArIDE7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBzYXdTdGFydCA9IHRydWU7XG4gICAgICAgIGlmIChjID09PSAnXFxcXCcpIHtcbiAgICAgICAgICAgIGlmICghZXNjYXBpbmcpIHtcbiAgICAgICAgICAgICAgICBlc2NhcGluZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gZXNjYXBlZCBcXCBjaGFyLCBmYWxsIHRocm91Z2ggYW5kIHRyZWF0IGxpa2Ugbm9ybWFsIGNoYXJcbiAgICAgICAgfVxuICAgICAgICBpZiAoYyA9PT0gJ1snICYmICFlc2NhcGluZykge1xuICAgICAgICAgICAgLy8gZWl0aGVyIGEgcG9zaXggY2xhc3MsIGEgY29sbGF0aW9uIGVxdWl2YWxlbnQsIG9yIGp1c3QgYSBbXG4gICAgICAgICAgICBmb3IgKGNvbnN0IFtjbHMsIFt1bmlwLCB1LCBuZWddXSBvZiBPYmplY3QuZW50cmllcyhwb3NpeENsYXNzZXMpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGdsb2Iuc3RhcnRzV2l0aChjbHMsIGkpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGludmFsaWQsIFthLVtdIGlzIGZpbmUsIGJ1dCBub3QgW2EtWzphbHBoYV1dXG4gICAgICAgICAgICAgICAgICAgIGlmIChyYW5nZVN0YXJ0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWyckLicsIGZhbHNlLCBnbG9iLmxlbmd0aCAtIHBvcywgdHJ1ZV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaSArPSBjbHMubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICBpZiAobmVnKVxuICAgICAgICAgICAgICAgICAgICAgICAgbmVncy5wdXNoKHVuaXApO1xuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICByYW5nZXMucHVzaCh1bmlwKTtcbiAgICAgICAgICAgICAgICAgICAgdWZsYWcgPSB1ZmxhZyB8fCB1O1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZSBXSElMRTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gbm93IGl0J3MganVzdCBhIG5vcm1hbCBjaGFyYWN0ZXIsIGVmZmVjdGl2ZWx5XG4gICAgICAgIGVzY2FwaW5nID0gZmFsc2U7XG4gICAgICAgIGlmIChyYW5nZVN0YXJ0KSB7XG4gICAgICAgICAgICAvLyB0aHJvdyB0aGlzIHJhbmdlIGF3YXkgaWYgaXQncyBub3QgdmFsaWQsIGJ1dCBvdGhlcnNcbiAgICAgICAgICAgIC8vIGNhbiBzdGlsbCBtYXRjaC5cbiAgICAgICAgICAgIGlmIChjID4gcmFuZ2VTdGFydCkge1xuICAgICAgICAgICAgICAgIHJhbmdlcy5wdXNoKGJyYWNlRXNjYXBlKHJhbmdlU3RhcnQpICsgJy0nICsgYnJhY2VFc2NhcGUoYykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYyA9PT0gcmFuZ2VTdGFydCkge1xuICAgICAgICAgICAgICAgIHJhbmdlcy5wdXNoKGJyYWNlRXNjYXBlKGMpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJhbmdlU3RhcnQgPSAnJztcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIG5vdyBtaWdodCBiZSB0aGUgc3RhcnQgb2YgYSByYW5nZS5cbiAgICAgICAgLy8gY2FuIGJlIGVpdGhlciBjLWQgb3IgYy1dIG9yIGM8bW9yZS4uLj5dIG9yIGNdIGF0IHRoaXMgcG9pbnRcbiAgICAgICAgaWYgKGdsb2Iuc3RhcnRzV2l0aCgnLV0nLCBpICsgMSkpIHtcbiAgICAgICAgICAgIHJhbmdlcy5wdXNoKGJyYWNlRXNjYXBlKGMgKyAnLScpKTtcbiAgICAgICAgICAgIGkgKz0gMjtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChnbG9iLnN0YXJ0c1dpdGgoJy0nLCBpICsgMSkpIHtcbiAgICAgICAgICAgIHJhbmdlU3RhcnQgPSBjO1xuICAgICAgICAgICAgaSArPSAyO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gbm90IHRoZSBzdGFydCBvZiBhIHJhbmdlLCBqdXN0IGEgc2luZ2xlIGNoYXJhY3RlclxuICAgICAgICByYW5nZXMucHVzaChicmFjZUVzY2FwZShjKSk7XG4gICAgICAgIGkrKztcbiAgICB9XG4gICAgaWYgKGVuZFBvcyA8IGkpIHtcbiAgICAgICAgLy8gZGlkbid0IHNlZSB0aGUgZW5kIG9mIHRoZSBjbGFzcywgbm90IGEgdmFsaWQgY2xhc3MsXG4gICAgICAgIC8vIGJ1dCBtaWdodCBzdGlsbCBiZSB2YWxpZCBhcyBhIGxpdGVyYWwgbWF0Y2guXG4gICAgICAgIHJldHVybiBbJycsIGZhbHNlLCAwLCBmYWxzZV07XG4gICAgfVxuICAgIC8vIGlmIHdlIGdvdCBubyByYW5nZXMgYW5kIG5vIG5lZ2F0ZXMsIHRoZW4gd2UgaGF2ZSBhIHJhbmdlIHRoYXRcbiAgICAvLyBjYW5ub3QgcG9zc2libHkgbWF0Y2ggYW55dGhpbmcsIGFuZCB0aGF0IHBvaXNvbnMgdGhlIHdob2xlIGdsb2JcbiAgICBpZiAoIXJhbmdlcy5sZW5ndGggJiYgIW5lZ3MubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBbJyQuJywgZmFsc2UsIGdsb2IubGVuZ3RoIC0gcG9zLCB0cnVlXTtcbiAgICB9XG4gICAgLy8gaWYgd2UgZ290IG9uZSBwb3NpdGl2ZSByYW5nZSwgYW5kIGl0J3MgYSBzaW5nbGUgY2hhcmFjdGVyLCB0aGVuIHRoYXQnc1xuICAgIC8vIG5vdCBhY3R1YWxseSBhIG1hZ2ljIHBhdHRlcm4sIGl0J3MganVzdCB0aGF0IG9uZSBsaXRlcmFsIGNoYXJhY3Rlci5cbiAgICAvLyB3ZSBzaG91bGQgbm90IHRyZWF0IHRoYXQgYXMgXCJtYWdpY1wiLCB3ZSBzaG91bGQganVzdCByZXR1cm4gdGhlIGxpdGVyYWxcbiAgICAvLyBjaGFyYWN0ZXIuIFtfXSBpcyBhIHBlcmZlY3RseSB2YWxpZCB3YXkgdG8gZXNjYXBlIGdsb2IgbWFnaWMgY2hhcnMuXG4gICAgaWYgKG5lZ3MubGVuZ3RoID09PSAwICYmXG4gICAgICAgIHJhbmdlcy5sZW5ndGggPT09IDEgJiZcbiAgICAgICAgL15cXFxcPy4kLy50ZXN0KHJhbmdlc1swXSkgJiZcbiAgICAgICAgIW5lZ2F0ZSkge1xuICAgICAgICBjb25zdCByID0gcmFuZ2VzWzBdLmxlbmd0aCA9PT0gMiA/IHJhbmdlc1swXS5zbGljZSgtMSkgOiByYW5nZXNbMF07XG4gICAgICAgIHJldHVybiBbcmVnZXhwRXNjYXBlKHIpLCBmYWxzZSwgZW5kUG9zIC0gcG9zLCBmYWxzZV07XG4gICAgfVxuICAgIGNvbnN0IHNyYW5nZXMgPSAnWycgKyAobmVnYXRlID8gJ14nIDogJycpICsgcmFuZ2VzVG9TdHJpbmcocmFuZ2VzKSArICddJztcbiAgICBjb25zdCBzbmVncyA9ICdbJyArIChuZWdhdGUgPyAnJyA6ICdeJykgKyByYW5nZXNUb1N0cmluZyhuZWdzKSArICddJztcbiAgICBjb25zdCBjb21iID0gcmFuZ2VzLmxlbmd0aCAmJiBuZWdzLmxlbmd0aFxuICAgICAgICA/ICcoJyArIHNyYW5nZXMgKyAnfCcgKyBzbmVncyArICcpJ1xuICAgICAgICA6IHJhbmdlcy5sZW5ndGhcbiAgICAgICAgICAgID8gc3Jhbmdlc1xuICAgICAgICAgICAgOiBzbmVncztcbiAgICByZXR1cm4gW2NvbWIsIHVmbGFnLCBlbmRQb3MgLSBwb3MsIHRydWVdO1xufTtcbmV4cG9ydHMucGFyc2VDbGFzcyA9IHBhcnNlQ2xhc3M7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1icmFjZS1leHByZXNzaW9ucy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/minimatch/dist/commonjs/brace-expressions.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/minimatch/dist/commonjs/escape.js":
/*!********************************************************!*\
  !*** ./node_modules/minimatch/dist/commonjs/escape.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.escape = void 0;\n/**\n * Escape all magic characters in a glob pattern.\n *\n * If the {@link windowsPathsNoEscape | GlobOptions.windowsPathsNoEscape}\n * option is used, then characters are escaped by wrapping in `[]`, because\n * a magic character wrapped in a character class can only be satisfied by\n * that exact character.  In this mode, `\\` is _not_ escaped, because it is\n * not interpreted as a magic character, but instead as a path separator.\n */\nconst escape = (s, { windowsPathsNoEscape = false, } = {}) => {\n    // don't need to escape +@! because we escape the parens\n    // that make those magic, and escaping ! as [!] isn't valid,\n    // because [!]] is a valid glob class meaning not ']'.\n    return windowsPathsNoEscape\n        ? s.replace(/[?*()[\\]]/g, '[$&]')\n        : s.replace(/[?*()[\\]\\\\]/g, '\\\\$&');\n};\nexports.escape = escape;\n//# sourceMappingURL=escape.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbWluaW1hdGNoL2Rpc3QvY29tbW9uanMvZXNjYXBlLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixnQ0FBZ0MsSUFBSTtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZCIsInNvdXJjZXMiOlsid2VicGFjazovL2F1dG8tbG9vcC1kZW1vLy4vbm9kZV9tb2R1bGVzL21pbmltYXRjaC9kaXN0L2NvbW1vbmpzL2VzY2FwZS5qcz81MjMzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5lc2NhcGUgPSB2b2lkIDA7XG4vKipcbiAqIEVzY2FwZSBhbGwgbWFnaWMgY2hhcmFjdGVycyBpbiBhIGdsb2IgcGF0dGVybi5cbiAqXG4gKiBJZiB0aGUge0BsaW5rIHdpbmRvd3NQYXRoc05vRXNjYXBlIHwgR2xvYk9wdGlvbnMud2luZG93c1BhdGhzTm9Fc2NhcGV9XG4gKiBvcHRpb24gaXMgdXNlZCwgdGhlbiBjaGFyYWN0ZXJzIGFyZSBlc2NhcGVkIGJ5IHdyYXBwaW5nIGluIGBbXWAsIGJlY2F1c2VcbiAqIGEgbWFnaWMgY2hhcmFjdGVyIHdyYXBwZWQgaW4gYSBjaGFyYWN0ZXIgY2xhc3MgY2FuIG9ubHkgYmUgc2F0aXNmaWVkIGJ5XG4gKiB0aGF0IGV4YWN0IGNoYXJhY3Rlci4gIEluIHRoaXMgbW9kZSwgYFxcYCBpcyBfbm90XyBlc2NhcGVkLCBiZWNhdXNlIGl0IGlzXG4gKiBub3QgaW50ZXJwcmV0ZWQgYXMgYSBtYWdpYyBjaGFyYWN0ZXIsIGJ1dCBpbnN0ZWFkIGFzIGEgcGF0aCBzZXBhcmF0b3IuXG4gKi9cbmNvbnN0IGVzY2FwZSA9IChzLCB7IHdpbmRvd3NQYXRoc05vRXNjYXBlID0gZmFsc2UsIH0gPSB7fSkgPT4ge1xuICAgIC8vIGRvbid0IG5lZWQgdG8gZXNjYXBlICtAISBiZWNhdXNlIHdlIGVzY2FwZSB0aGUgcGFyZW5zXG4gICAgLy8gdGhhdCBtYWtlIHRob3NlIG1hZ2ljLCBhbmQgZXNjYXBpbmcgISBhcyBbIV0gaXNuJ3QgdmFsaWQsXG4gICAgLy8gYmVjYXVzZSBbIV1dIGlzIGEgdmFsaWQgZ2xvYiBjbGFzcyBtZWFuaW5nIG5vdCAnXScuXG4gICAgcmV0dXJuIHdpbmRvd3NQYXRoc05vRXNjYXBlXG4gICAgICAgID8gcy5yZXBsYWNlKC9bPyooKVtcXF1dL2csICdbJCZdJylcbiAgICAgICAgOiBzLnJlcGxhY2UoL1s/KigpW1xcXVxcXFxdL2csICdcXFxcJCYnKTtcbn07XG5leHBvcnRzLmVzY2FwZSA9IGVzY2FwZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWVzY2FwZS5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/minimatch/dist/commonjs/escape.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/minimatch/dist/commonjs/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/minimatch/dist/commonjs/index.js ***!
  \*******************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.unescape = exports.escape = exports.AST = exports.Minimatch = exports.match = exports.makeRe = exports.braceExpand = exports.defaults = exports.filter = exports.GLOBSTAR = exports.sep = exports.minimatch = void 0;\nconst brace_expansion_1 = __importDefault(__webpack_require__(/*! brace-expansion */ \"(rsc)/./node_modules/brace-expansion/index.js\"));\nconst assert_valid_pattern_js_1 = __webpack_require__(/*! ./assert-valid-pattern.js */ \"(rsc)/./node_modules/minimatch/dist/commonjs/assert-valid-pattern.js\");\nconst ast_js_1 = __webpack_require__(/*! ./ast.js */ \"(rsc)/./node_modules/minimatch/dist/commonjs/ast.js\");\nconst escape_js_1 = __webpack_require__(/*! ./escape.js */ \"(rsc)/./node_modules/minimatch/dist/commonjs/escape.js\");\nconst unescape_js_1 = __webpack_require__(/*! ./unescape.js */ \"(rsc)/./node_modules/minimatch/dist/commonjs/unescape.js\");\nconst minimatch = (p, pattern, options = {}) => {\n    (0, assert_valid_pattern_js_1.assertValidPattern)(pattern);\n    // shortcut: comments match nothing.\n    if (!options.nocomment && pattern.charAt(0) === '#') {\n        return false;\n    }\n    return new Minimatch(pattern, options).match(p);\n};\nexports.minimatch = minimatch;\n// Optimized checking for the most common glob patterns.\nconst starDotExtRE = /^\\*+([^+@!?\\*\\[\\(]*)$/;\nconst starDotExtTest = (ext) => (f) => !f.startsWith('.') && f.endsWith(ext);\nconst starDotExtTestDot = (ext) => (f) => f.endsWith(ext);\nconst starDotExtTestNocase = (ext) => {\n    ext = ext.toLowerCase();\n    return (f) => !f.startsWith('.') && f.toLowerCase().endsWith(ext);\n};\nconst starDotExtTestNocaseDot = (ext) => {\n    ext = ext.toLowerCase();\n    return (f) => f.toLowerCase().endsWith(ext);\n};\nconst starDotStarRE = /^\\*+\\.\\*+$/;\nconst starDotStarTest = (f) => !f.startsWith('.') && f.includes('.');\nconst starDotStarTestDot = (f) => f !== '.' && f !== '..' && f.includes('.');\nconst dotStarRE = /^\\.\\*+$/;\nconst dotStarTest = (f) => f !== '.' && f !== '..' && f.startsWith('.');\nconst starRE = /^\\*+$/;\nconst starTest = (f) => f.length !== 0 && !f.startsWith('.');\nconst starTestDot = (f) => f.length !== 0 && f !== '.' && f !== '..';\nconst qmarksRE = /^\\?+([^+@!?\\*\\[\\(]*)?$/;\nconst qmarksTestNocase = ([$0, ext = '']) => {\n    const noext = qmarksTestNoExt([$0]);\n    if (!ext)\n        return noext;\n    ext = ext.toLowerCase();\n    return (f) => noext(f) && f.toLowerCase().endsWith(ext);\n};\nconst qmarksTestNocaseDot = ([$0, ext = '']) => {\n    const noext = qmarksTestNoExtDot([$0]);\n    if (!ext)\n        return noext;\n    ext = ext.toLowerCase();\n    return (f) => noext(f) && f.toLowerCase().endsWith(ext);\n};\nconst qmarksTestDot = ([$0, ext = '']) => {\n    const noext = qmarksTestNoExtDot([$0]);\n    return !ext ? noext : (f) => noext(f) && f.endsWith(ext);\n};\nconst qmarksTest = ([$0, ext = '']) => {\n    const noext = qmarksTestNoExt([$0]);\n    return !ext ? noext : (f) => noext(f) && f.endsWith(ext);\n};\nconst qmarksTestNoExt = ([$0]) => {\n    const len = $0.length;\n    return (f) => f.length === len && !f.startsWith('.');\n};\nconst qmarksTestNoExtDot = ([$0]) => {\n    const len = $0.length;\n    return (f) => f.length === len && f !== '.' && f !== '..';\n};\n/* c8 ignore start */\nconst defaultPlatform = (typeof process === 'object' && process\n    ? (typeof process.env === 'object' &&\n        process.env &&\n        process.env.__MINIMATCH_TESTING_PLATFORM__) ||\n        process.platform\n    : 'posix');\nconst path = {\n    win32: { sep: '\\\\' },\n    posix: { sep: '/' },\n};\n/* c8 ignore stop */\nexports.sep = defaultPlatform === 'win32' ? path.win32.sep : path.posix.sep;\nexports.minimatch.sep = exports.sep;\nexports.GLOBSTAR = Symbol('globstar **');\nexports.minimatch.GLOBSTAR = exports.GLOBSTAR;\n// any single thing other than /\n// don't need to escape / when using new RegExp()\nconst qmark = '[^/]';\n// * => any number of characters\nconst star = qmark + '*?';\n// ** when dots are allowed.  Anything goes, except .. and .\n// not (^ or / followed by one or two dots followed by $ or /),\n// followed by anything, any number of times.\nconst twoStarDot = '(?:(?!(?:\\\\/|^)(?:\\\\.{1,2})($|\\\\/)).)*?';\n// not a ^ or / followed by a dot,\n// followed by anything, any number of times.\nconst twoStarNoDot = '(?:(?!(?:\\\\/|^)\\\\.).)*?';\nconst filter = (pattern, options = {}) => (p) => (0, exports.minimatch)(p, pattern, options);\nexports.filter = filter;\nexports.minimatch.filter = exports.filter;\nconst ext = (a, b = {}) => Object.assign({}, a, b);\nconst defaults = (def) => {\n    if (!def || typeof def !== 'object' || !Object.keys(def).length) {\n        return exports.minimatch;\n    }\n    const orig = exports.minimatch;\n    const m = (p, pattern, options = {}) => orig(p, pattern, ext(def, options));\n    return Object.assign(m, {\n        Minimatch: class Minimatch extends orig.Minimatch {\n            constructor(pattern, options = {}) {\n                super(pattern, ext(def, options));\n            }\n            static defaults(options) {\n                return orig.defaults(ext(def, options)).Minimatch;\n            }\n        },\n        AST: class AST extends orig.AST {\n            /* c8 ignore start */\n            constructor(type, parent, options = {}) {\n                super(type, parent, ext(def, options));\n            }\n            /* c8 ignore stop */\n            static fromGlob(pattern, options = {}) {\n                return orig.AST.fromGlob(pattern, ext(def, options));\n            }\n        },\n        unescape: (s, options = {}) => orig.unescape(s, ext(def, options)),\n        escape: (s, options = {}) => orig.escape(s, ext(def, options)),\n        filter: (pattern, options = {}) => orig.filter(pattern, ext(def, options)),\n        defaults: (options) => orig.defaults(ext(def, options)),\n        makeRe: (pattern, options = {}) => orig.makeRe(pattern, ext(def, options)),\n        braceExpand: (pattern, options = {}) => orig.braceExpand(pattern, ext(def, options)),\n        match: (list, pattern, options = {}) => orig.match(list, pattern, ext(def, options)),\n        sep: orig.sep,\n        GLOBSTAR: exports.GLOBSTAR,\n    });\n};\nexports.defaults = defaults;\nexports.minimatch.defaults = exports.defaults;\n// Brace expansion:\n// a{b,c}d -> abd acd\n// a{b,}c -> abc ac\n// a{0..3}d -> a0d a1d a2d a3d\n// a{b,c{d,e}f}g -> abg acdfg acefg\n// a{b,c}d{e,f}g -> abdeg acdeg abdeg abdfg\n//\n// Invalid sets are not expanded.\n// a{2..}b -> a{2..}b\n// a{b}c -> a{b}c\nconst braceExpand = (pattern, options = {}) => {\n    (0, assert_valid_pattern_js_1.assertValidPattern)(pattern);\n    // Thanks to Yeting Li <https://github.com/yetingli> for\n    // improving this regexp to avoid a ReDOS vulnerability.\n    if (options.nobrace || !/\\{(?:(?!\\{).)*\\}/.test(pattern)) {\n        // shortcut. no need to expand.\n        return [pattern];\n    }\n    return (0, brace_expansion_1.default)(pattern);\n};\nexports.braceExpand = braceExpand;\nexports.minimatch.braceExpand = exports.braceExpand;\n// parse a component of the expanded set.\n// At this point, no pattern may contain \"/\" in it\n// so we're going to return a 2d array, where each entry is the full\n// pattern, split on '/', and then turned into a regular expression.\n// A regexp is made at the end which joins each array with an\n// escaped /, and another full one which joins each regexp with |.\n//\n// Following the lead of Bash 4.1, note that \"**\" only has special meaning\n// when it is the *only* thing in a path portion.  Otherwise, any series\n// of * is equivalent to a single *.  Globstar behavior is enabled by\n// default, and can be disabled by setting options.noglobstar.\nconst makeRe = (pattern, options = {}) => new Minimatch(pattern, options).makeRe();\nexports.makeRe = makeRe;\nexports.minimatch.makeRe = exports.makeRe;\nconst match = (list, pattern, options = {}) => {\n    const mm = new Minimatch(pattern, options);\n    list = list.filter(f => mm.match(f));\n    if (mm.options.nonull && !list.length) {\n        list.push(pattern);\n    }\n    return list;\n};\nexports.match = match;\nexports.minimatch.match = exports.match;\n// replace stuff like \\* with *\nconst globMagic = /[?*]|[+@!]\\(.*?\\)|\\[|\\]/;\nconst regExpEscape = (s) => s.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, '\\\\$&');\nclass Minimatch {\n    options;\n    set;\n    pattern;\n    windowsPathsNoEscape;\n    nonegate;\n    negate;\n    comment;\n    empty;\n    preserveMultipleSlashes;\n    partial;\n    globSet;\n    globParts;\n    nocase;\n    isWindows;\n    platform;\n    windowsNoMagicRoot;\n    regexp;\n    constructor(pattern, options = {}) {\n        (0, assert_valid_pattern_js_1.assertValidPattern)(pattern);\n        options = options || {};\n        this.options = options;\n        this.pattern = pattern;\n        this.platform = options.platform || defaultPlatform;\n        this.isWindows = this.platform === 'win32';\n        this.windowsPathsNoEscape =\n            !!options.windowsPathsNoEscape || options.allowWindowsEscape === false;\n        if (this.windowsPathsNoEscape) {\n            this.pattern = this.pattern.replace(/\\\\/g, '/');\n        }\n        this.preserveMultipleSlashes = !!options.preserveMultipleSlashes;\n        this.regexp = null;\n        this.negate = false;\n        this.nonegate = !!options.nonegate;\n        this.comment = false;\n        this.empty = false;\n        this.partial = !!options.partial;\n        this.nocase = !!this.options.nocase;\n        this.windowsNoMagicRoot =\n            options.windowsNoMagicRoot !== undefined\n                ? options.windowsNoMagicRoot\n                : !!(this.isWindows && this.nocase);\n        this.globSet = [];\n        this.globParts = [];\n        this.set = [];\n        // make the set of regexps etc.\n        this.make();\n    }\n    hasMagic() {\n        if (this.options.magicalBraces && this.set.length > 1) {\n            return true;\n        }\n        for (const pattern of this.set) {\n            for (const part of pattern) {\n                if (typeof part !== 'string')\n                    return true;\n            }\n        }\n        return false;\n    }\n    debug(..._) { }\n    make() {\n        const pattern = this.pattern;\n        const options = this.options;\n        // empty patterns and comments match nothing.\n        if (!options.nocomment && pattern.charAt(0) === '#') {\n            this.comment = true;\n            return;\n        }\n        if (!pattern) {\n            this.empty = true;\n            return;\n        }\n        // step 1: figure out negation, etc.\n        this.parseNegate();\n        // step 2: expand braces\n        this.globSet = [...new Set(this.braceExpand())];\n        if (options.debug) {\n            this.debug = (...args) => console.error(...args);\n        }\n        this.debug(this.pattern, this.globSet);\n        // step 3: now we have a set, so turn each one into a series of\n        // path-portion matching patterns.\n        // These will be regexps, except in the case of \"**\", which is\n        // set to the GLOBSTAR object for globstar behavior,\n        // and will not contain any / characters\n        //\n        // First, we preprocess to make the glob pattern sets a bit simpler\n        // and deduped.  There are some perf-killing patterns that can cause\n        // problems with a glob walk, but we can simplify them down a bit.\n        const rawGlobParts = this.globSet.map(s => this.slashSplit(s));\n        this.globParts = this.preprocess(rawGlobParts);\n        this.debug(this.pattern, this.globParts);\n        // glob --> regexps\n        let set = this.globParts.map((s, _, __) => {\n            if (this.isWindows && this.windowsNoMagicRoot) {\n                // check if it's a drive or unc path.\n                const isUNC = s[0] === '' &&\n                    s[1] === '' &&\n                    (s[2] === '?' || !globMagic.test(s[2])) &&\n                    !globMagic.test(s[3]);\n                const isDrive = /^[a-z]:/i.test(s[0]);\n                if (isUNC) {\n                    return [...s.slice(0, 4), ...s.slice(4).map(ss => this.parse(ss))];\n                }\n                else if (isDrive) {\n                    return [s[0], ...s.slice(1).map(ss => this.parse(ss))];\n                }\n            }\n            return s.map(ss => this.parse(ss));\n        });\n        this.debug(this.pattern, set);\n        // filter out everything that didn't compile properly.\n        this.set = set.filter(s => s.indexOf(false) === -1);\n        // do not treat the ? in UNC paths as magic\n        if (this.isWindows) {\n            for (let i = 0; i < this.set.length; i++) {\n                const p = this.set[i];\n                if (p[0] === '' &&\n                    p[1] === '' &&\n                    this.globParts[i][2] === '?' &&\n                    typeof p[3] === 'string' &&\n                    /^[a-z]:$/i.test(p[3])) {\n                    p[2] = '?';\n                }\n            }\n        }\n        this.debug(this.pattern, this.set);\n    }\n    // various transforms to equivalent pattern sets that are\n    // faster to process in a filesystem walk.  The goal is to\n    // eliminate what we can, and push all ** patterns as far\n    // to the right as possible, even if it increases the number\n    // of patterns that we have to process.\n    preprocess(globParts) {\n        // if we're not in globstar mode, then turn all ** into *\n        if (this.options.noglobstar) {\n            for (let i = 0; i < globParts.length; i++) {\n                for (let j = 0; j < globParts[i].length; j++) {\n                    if (globParts[i][j] === '**') {\n                        globParts[i][j] = '*';\n                    }\n                }\n            }\n        }\n        const { optimizationLevel = 1 } = this.options;\n        if (optimizationLevel >= 2) {\n            // aggressive optimization for the purpose of fs walking\n            globParts = this.firstPhasePreProcess(globParts);\n            globParts = this.secondPhasePreProcess(globParts);\n        }\n        else if (optimizationLevel >= 1) {\n            // just basic optimizations to remove some .. parts\n            globParts = this.levelOneOptimize(globParts);\n        }\n        else {\n            // just collapse multiple ** portions into one\n            globParts = this.adjascentGlobstarOptimize(globParts);\n        }\n        return globParts;\n    }\n    // just get rid of adjascent ** portions\n    adjascentGlobstarOptimize(globParts) {\n        return globParts.map(parts => {\n            let gs = -1;\n            while (-1 !== (gs = parts.indexOf('**', gs + 1))) {\n                let i = gs;\n                while (parts[i + 1] === '**') {\n                    i++;\n                }\n                if (i !== gs) {\n                    parts.splice(gs, i - gs);\n                }\n            }\n            return parts;\n        });\n    }\n    // get rid of adjascent ** and resolve .. portions\n    levelOneOptimize(globParts) {\n        return globParts.map(parts => {\n            parts = parts.reduce((set, part) => {\n                const prev = set[set.length - 1];\n                if (part === '**' && prev === '**') {\n                    return set;\n                }\n                if (part === '..') {\n                    if (prev && prev !== '..' && prev !== '.' && prev !== '**') {\n                        set.pop();\n                        return set;\n                    }\n                }\n                set.push(part);\n                return set;\n            }, []);\n            return parts.length === 0 ? [''] : parts;\n        });\n    }\n    levelTwoFileOptimize(parts) {\n        if (!Array.isArray(parts)) {\n            parts = this.slashSplit(parts);\n        }\n        let didSomething = false;\n        do {\n            didSomething = false;\n            // <pre>/<e>/<rest> -> <pre>/<rest>\n            if (!this.preserveMultipleSlashes) {\n                for (let i = 1; i < parts.length - 1; i++) {\n                    const p = parts[i];\n                    // don't squeeze out UNC patterns\n                    if (i === 1 && p === '' && parts[0] === '')\n                        continue;\n                    if (p === '.' || p === '') {\n                        didSomething = true;\n                        parts.splice(i, 1);\n                        i--;\n                    }\n                }\n                if (parts[0] === '.' &&\n                    parts.length === 2 &&\n                    (parts[1] === '.' || parts[1] === '')) {\n                    didSomething = true;\n                    parts.pop();\n                }\n            }\n            // <pre>/<p>/../<rest> -> <pre>/<rest>\n            let dd = 0;\n            while (-1 !== (dd = parts.indexOf('..', dd + 1))) {\n                const p = parts[dd - 1];\n                if (p && p !== '.' && p !== '..' && p !== '**') {\n                    didSomething = true;\n                    parts.splice(dd - 1, 2);\n                    dd -= 2;\n                }\n            }\n        } while (didSomething);\n        return parts.length === 0 ? [''] : parts;\n    }\n    // First phase: single-pattern processing\n    // <pre> is 1 or more portions\n    // <rest> is 1 or more portions\n    // <p> is any portion other than ., .., '', or **\n    // <e> is . or ''\n    //\n    // **/.. is *brutal* for filesystem walking performance, because\n    // it effectively resets the recursive walk each time it occurs,\n    // and ** cannot be reduced out by a .. pattern part like a regexp\n    // or most strings (other than .., ., and '') can be.\n    //\n    // <pre>/**/../<p>/<p>/<rest> -> {<pre>/../<p>/<p>/<rest>,<pre>/**/<p>/<p>/<rest>}\n    // <pre>/<e>/<rest> -> <pre>/<rest>\n    // <pre>/<p>/../<rest> -> <pre>/<rest>\n    // **/**/<rest> -> **/<rest>\n    //\n    // **/*/<rest> -> */**/<rest> <== not valid because ** doesn't follow\n    // this WOULD be allowed if ** did follow symlinks, or * didn't\n    firstPhasePreProcess(globParts) {\n        let didSomething = false;\n        do {\n            didSomething = false;\n            // <pre>/**/../<p>/<p>/<rest> -> {<pre>/../<p>/<p>/<rest>,<pre>/**/<p>/<p>/<rest>}\n            for (let parts of globParts) {\n                let gs = -1;\n                while (-1 !== (gs = parts.indexOf('**', gs + 1))) {\n                    let gss = gs;\n                    while (parts[gss + 1] === '**') {\n                        // <pre>/**/**/<rest> -> <pre>/**/<rest>\n                        gss++;\n                    }\n                    // eg, if gs is 2 and gss is 4, that means we have 3 **\n                    // parts, and can remove 2 of them.\n                    if (gss > gs) {\n                        parts.splice(gs + 1, gss - gs);\n                    }\n                    let next = parts[gs + 1];\n                    const p = parts[gs + 2];\n                    const p2 = parts[gs + 3];\n                    if (next !== '..')\n                        continue;\n                    if (!p ||\n                        p === '.' ||\n                        p === '..' ||\n                        !p2 ||\n                        p2 === '.' ||\n                        p2 === '..') {\n                        continue;\n                    }\n                    didSomething = true;\n                    // edit parts in place, and push the new one\n                    parts.splice(gs, 1);\n                    const other = parts.slice(0);\n                    other[gs] = '**';\n                    globParts.push(other);\n                    gs--;\n                }\n                // <pre>/<e>/<rest> -> <pre>/<rest>\n                if (!this.preserveMultipleSlashes) {\n                    for (let i = 1; i < parts.length - 1; i++) {\n                        const p = parts[i];\n                        // don't squeeze out UNC patterns\n                        if (i === 1 && p === '' && parts[0] === '')\n                            continue;\n                        if (p === '.' || p === '') {\n                            didSomething = true;\n                            parts.splice(i, 1);\n                            i--;\n                        }\n                    }\n                    if (parts[0] === '.' &&\n                        parts.length === 2 &&\n                        (parts[1] === '.' || parts[1] === '')) {\n                        didSomething = true;\n                        parts.pop();\n                    }\n                }\n                // <pre>/<p>/../<rest> -> <pre>/<rest>\n                let dd = 0;\n                while (-1 !== (dd = parts.indexOf('..', dd + 1))) {\n                    const p = parts[dd - 1];\n                    if (p && p !== '.' && p !== '..' && p !== '**') {\n                        didSomething = true;\n                        const needDot = dd === 1 && parts[dd + 1] === '**';\n                        const splin = needDot ? ['.'] : [];\n                        parts.splice(dd - 1, 2, ...splin);\n                        if (parts.length === 0)\n                            parts.push('');\n                        dd -= 2;\n                    }\n                }\n            }\n        } while (didSomething);\n        return globParts;\n    }\n    // second phase: multi-pattern dedupes\n    // {<pre>/*/<rest>,<pre>/<p>/<rest>} -> <pre>/*/<rest>\n    // {<pre>/<rest>,<pre>/<rest>} -> <pre>/<rest>\n    // {<pre>/**/<rest>,<pre>/<rest>} -> <pre>/**/<rest>\n    //\n    // {<pre>/**/<rest>,<pre>/**/<p>/<rest>} -> <pre>/**/<rest>\n    // ^-- not valid because ** doens't follow symlinks\n    secondPhasePreProcess(globParts) {\n        for (let i = 0; i < globParts.length - 1; i++) {\n            for (let j = i + 1; j < globParts.length; j++) {\n                const matched = this.partsMatch(globParts[i], globParts[j], !this.preserveMultipleSlashes);\n                if (matched) {\n                    globParts[i] = [];\n                    globParts[j] = matched;\n                    break;\n                }\n            }\n        }\n        return globParts.filter(gs => gs.length);\n    }\n    partsMatch(a, b, emptyGSMatch = false) {\n        let ai = 0;\n        let bi = 0;\n        let result = [];\n        let which = '';\n        while (ai < a.length && bi < b.length) {\n            if (a[ai] === b[bi]) {\n                result.push(which === 'b' ? b[bi] : a[ai]);\n                ai++;\n                bi++;\n            }\n            else if (emptyGSMatch && a[ai] === '**' && b[bi] === a[ai + 1]) {\n                result.push(a[ai]);\n                ai++;\n            }\n            else if (emptyGSMatch && b[bi] === '**' && a[ai] === b[bi + 1]) {\n                result.push(b[bi]);\n                bi++;\n            }\n            else if (a[ai] === '*' &&\n                b[bi] &&\n                (this.options.dot || !b[bi].startsWith('.')) &&\n                b[bi] !== '**') {\n                if (which === 'b')\n                    return false;\n                which = 'a';\n                result.push(a[ai]);\n                ai++;\n                bi++;\n            }\n            else if (b[bi] === '*' &&\n                a[ai] &&\n                (this.options.dot || !a[ai].startsWith('.')) &&\n                a[ai] !== '**') {\n                if (which === 'a')\n                    return false;\n                which = 'b';\n                result.push(b[bi]);\n                ai++;\n                bi++;\n            }\n            else {\n                return false;\n            }\n        }\n        // if we fall out of the loop, it means they two are identical\n        // as long as their lengths match\n        return a.length === b.length && result;\n    }\n    parseNegate() {\n        if (this.nonegate)\n            return;\n        const pattern = this.pattern;\n        let negate = false;\n        let negateOffset = 0;\n        for (let i = 0; i < pattern.length && pattern.charAt(i) === '!'; i++) {\n            negate = !negate;\n            negateOffset++;\n        }\n        if (negateOffset)\n            this.pattern = pattern.slice(negateOffset);\n        this.negate = negate;\n    }\n    // set partial to true to test if, for example,\n    // \"/a/b\" matches the start of \"/*/b/*/d\"\n    // Partial means, if you run out of file before you run\n    // out of pattern, then that's fine, as long as all\n    // the parts match.\n    matchOne(file, pattern, partial = false) {\n        const options = this.options;\n        // UNC paths like //?/X:/... can match X:/... and vice versa\n        // Drive letters in absolute drive or unc paths are always compared\n        // case-insensitively.\n        if (this.isWindows) {\n            const fileDrive = typeof file[0] === 'string' && /^[a-z]:$/i.test(file[0]);\n            const fileUNC = !fileDrive &&\n                file[0] === '' &&\n                file[1] === '' &&\n                file[2] === '?' &&\n                /^[a-z]:$/i.test(file[3]);\n            const patternDrive = typeof pattern[0] === 'string' && /^[a-z]:$/i.test(pattern[0]);\n            const patternUNC = !patternDrive &&\n                pattern[0] === '' &&\n                pattern[1] === '' &&\n                pattern[2] === '?' &&\n                typeof pattern[3] === 'string' &&\n                /^[a-z]:$/i.test(pattern[3]);\n            const fdi = fileUNC ? 3 : fileDrive ? 0 : undefined;\n            const pdi = patternUNC ? 3 : patternDrive ? 0 : undefined;\n            if (typeof fdi === 'number' && typeof pdi === 'number') {\n                const [fd, pd] = [file[fdi], pattern[pdi]];\n                if (fd.toLowerCase() === pd.toLowerCase()) {\n                    pattern[pdi] = fd;\n                    if (pdi > fdi) {\n                        pattern = pattern.slice(pdi);\n                    }\n                    else if (fdi > pdi) {\n                        file = file.slice(fdi);\n                    }\n                }\n            }\n        }\n        // resolve and reduce . and .. portions in the file as well.\n        // dont' need to do the second phase, because it's only one string[]\n        const { optimizationLevel = 1 } = this.options;\n        if (optimizationLevel >= 2) {\n            file = this.levelTwoFileOptimize(file);\n        }\n        this.debug('matchOne', this, { file, pattern });\n        this.debug('matchOne', file.length, pattern.length);\n        for (var fi = 0, pi = 0, fl = file.length, pl = pattern.length; fi < fl && pi < pl; fi++, pi++) {\n            this.debug('matchOne loop');\n            var p = pattern[pi];\n            var f = file[fi];\n            this.debug(pattern, p, f);\n            // should be impossible.\n            // some invalid regexp stuff in the set.\n            /* c8 ignore start */\n            if (p === false) {\n                return false;\n            }\n            /* c8 ignore stop */\n            if (p === exports.GLOBSTAR) {\n                this.debug('GLOBSTAR', [pattern, p, f]);\n                // \"**\"\n                // a/**/b/**/c would match the following:\n                // a/b/x/y/z/c\n                // a/x/y/z/b/c\n                // a/b/x/b/x/c\n                // a/b/c\n                // To do this, take the rest of the pattern after\n                // the **, and see if it would match the file remainder.\n                // If so, return success.\n                // If not, the ** \"swallows\" a segment, and try again.\n                // This is recursively awful.\n                //\n                // a/**/b/**/c matching a/b/x/y/z/c\n                // - a matches a\n                // - doublestar\n                //   - matchOne(b/x/y/z/c, b/**/c)\n                //     - b matches b\n                //     - doublestar\n                //       - matchOne(x/y/z/c, c) -> no\n                //       - matchOne(y/z/c, c) -> no\n                //       - matchOne(z/c, c) -> no\n                //       - matchOne(c, c) yes, hit\n                var fr = fi;\n                var pr = pi + 1;\n                if (pr === pl) {\n                    this.debug('** at the end');\n                    // a ** at the end will just swallow the rest.\n                    // We have found a match.\n                    // however, it will not swallow /.x, unless\n                    // options.dot is set.\n                    // . and .. are *never* matched by **, for explosively\n                    // exponential reasons.\n                    for (; fi < fl; fi++) {\n                        if (file[fi] === '.' ||\n                            file[fi] === '..' ||\n                            (!options.dot && file[fi].charAt(0) === '.'))\n                            return false;\n                    }\n                    return true;\n                }\n                // ok, let's see if we can swallow whatever we can.\n                while (fr < fl) {\n                    var swallowee = file[fr];\n                    this.debug('\\nglobstar while', file, fr, pattern, pr, swallowee);\n                    // XXX remove this slice.  Just pass the start index.\n                    if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {\n                        this.debug('globstar found match!', fr, fl, swallowee);\n                        // found a match.\n                        return true;\n                    }\n                    else {\n                        // can't swallow \".\" or \"..\" ever.\n                        // can only swallow \".foo\" when explicitly asked.\n                        if (swallowee === '.' ||\n                            swallowee === '..' ||\n                            (!options.dot && swallowee.charAt(0) === '.')) {\n                            this.debug('dot detected!', file, fr, pattern, pr);\n                            break;\n                        }\n                        // ** swallows a segment, and continue.\n                        this.debug('globstar swallow a segment, and continue');\n                        fr++;\n                    }\n                }\n                // no match was found.\n                // However, in partial mode, we can't say this is necessarily over.\n                /* c8 ignore start */\n                if (partial) {\n                    // ran out of file\n                    this.debug('\\n>>> no match, partial?', file, fr, pattern, pr);\n                    if (fr === fl) {\n                        return true;\n                    }\n                }\n                /* c8 ignore stop */\n                return false;\n            }\n            // something other than **\n            // non-magic patterns just have to match exactly\n            // patterns with magic have been turned into regexps.\n            let hit;\n            if (typeof p === 'string') {\n                hit = f === p;\n                this.debug('string match', p, f, hit);\n            }\n            else {\n                hit = p.test(f);\n                this.debug('pattern match', p, f, hit);\n            }\n            if (!hit)\n                return false;\n        }\n        // Note: ending in / means that we'll get a final \"\"\n        // at the end of the pattern.  This can only match a\n        // corresponding \"\" at the end of the file.\n        // If the file ends in /, then it can only match a\n        // a pattern that ends in /, unless the pattern just\n        // doesn't have any more for it. But, a/b/ should *not*\n        // match \"a/b/*\", even though \"\" matches against the\n        // [^/]*? pattern, except in partial mode, where it might\n        // simply not be reached yet.\n        // However, a/b/ should still satisfy a/*\n        // now either we fell off the end of the pattern, or we're done.\n        if (fi === fl && pi === pl) {\n            // ran out of pattern and filename at the same time.\n            // an exact hit!\n            return true;\n        }\n        else if (fi === fl) {\n            // ran out of file, but still had pattern left.\n            // this is ok if we're doing the match as part of\n            // a glob fs traversal.\n            return partial;\n        }\n        else if (pi === pl) {\n            // ran out of pattern, still have file left.\n            // this is only acceptable if we're on the very last\n            // empty segment of a file with a trailing slash.\n            // a/* should match a/b/\n            return fi === fl - 1 && file[fi] === '';\n            /* c8 ignore start */\n        }\n        else {\n            // should be unreachable.\n            throw new Error('wtf?');\n        }\n        /* c8 ignore stop */\n    }\n    braceExpand() {\n        return (0, exports.braceExpand)(this.pattern, this.options);\n    }\n    parse(pattern) {\n        (0, assert_valid_pattern_js_1.assertValidPattern)(pattern);\n        const options = this.options;\n        // shortcuts\n        if (pattern === '**')\n            return exports.GLOBSTAR;\n        if (pattern === '')\n            return '';\n        // far and away, the most common glob pattern parts are\n        // *, *.*, and *.<ext>  Add a fast check method for those.\n        let m;\n        let fastTest = null;\n        if ((m = pattern.match(starRE))) {\n            fastTest = options.dot ? starTestDot : starTest;\n        }\n        else if ((m = pattern.match(starDotExtRE))) {\n            fastTest = (options.nocase\n                ? options.dot\n                    ? starDotExtTestNocaseDot\n                    : starDotExtTestNocase\n                : options.dot\n                    ? starDotExtTestDot\n                    : starDotExtTest)(m[1]);\n        }\n        else if ((m = pattern.match(qmarksRE))) {\n            fastTest = (options.nocase\n                ? options.dot\n                    ? qmarksTestNocaseDot\n                    : qmarksTestNocase\n                : options.dot\n                    ? qmarksTestDot\n                    : qmarksTest)(m);\n        }\n        else if ((m = pattern.match(starDotStarRE))) {\n            fastTest = options.dot ? starDotStarTestDot : starDotStarTest;\n        }\n        else if ((m = pattern.match(dotStarRE))) {\n            fastTest = dotStarTest;\n        }\n        const re = ast_js_1.AST.fromGlob(pattern, this.options).toMMPattern();\n        if (fastTest && typeof re === 'object') {\n            // Avoids overriding in frozen environments\n            Reflect.defineProperty(re, 'test', { value: fastTest });\n        }\n        return re;\n    }\n    makeRe() {\n        if (this.regexp || this.regexp === false)\n            return this.regexp;\n        // at this point, this.set is a 2d array of partial\n        // pattern strings, or \"**\".\n        //\n        // It's better to use .match().  This function shouldn't\n        // be used, really, but it's pretty convenient sometimes,\n        // when you just want to work with a regex.\n        const set = this.set;\n        if (!set.length) {\n            this.regexp = false;\n            return this.regexp;\n        }\n        const options = this.options;\n        const twoStar = options.noglobstar\n            ? star\n            : options.dot\n                ? twoStarDot\n                : twoStarNoDot;\n        const flags = new Set(options.nocase ? ['i'] : []);\n        // regexpify non-globstar patterns\n        // if ** is only item, then we just do one twoStar\n        // if ** is first, and there are more, prepend (\\/|twoStar\\/)? to next\n        // if ** is last, append (\\/twoStar|) to previous\n        // if ** is in the middle, append (\\/|\\/twoStar\\/) to previous\n        // then filter out GLOBSTAR symbols\n        let re = set\n            .map(pattern => {\n            const pp = pattern.map(p => {\n                if (p instanceof RegExp) {\n                    for (const f of p.flags.split(''))\n                        flags.add(f);\n                }\n                return typeof p === 'string'\n                    ? regExpEscape(p)\n                    : p === exports.GLOBSTAR\n                        ? exports.GLOBSTAR\n                        : p._src;\n            });\n            pp.forEach((p, i) => {\n                const next = pp[i + 1];\n                const prev = pp[i - 1];\n                if (p !== exports.GLOBSTAR || prev === exports.GLOBSTAR) {\n                    return;\n                }\n                if (prev === undefined) {\n                    if (next !== undefined && next !== exports.GLOBSTAR) {\n                        pp[i + 1] = '(?:\\\\/|' + twoStar + '\\\\/)?' + next;\n                    }\n                    else {\n                        pp[i] = twoStar;\n                    }\n                }\n                else if (next === undefined) {\n                    pp[i - 1] = prev + '(?:\\\\/|' + twoStar + ')?';\n                }\n                else if (next !== exports.GLOBSTAR) {\n                    pp[i - 1] = prev + '(?:\\\\/|\\\\/' + twoStar + '\\\\/)' + next;\n                    pp[i + 1] = exports.GLOBSTAR;\n                }\n            });\n            return pp.filter(p => p !== exports.GLOBSTAR).join('/');\n        })\n            .join('|');\n        // need to wrap in parens if we had more than one thing with |,\n        // otherwise only the first will be anchored to ^ and the last to $\n        const [open, close] = set.length > 1 ? ['(?:', ')'] : ['', ''];\n        // must match entire pattern\n        // ending in a * or ** will make it less strict.\n        re = '^' + open + re + close + '$';\n        // can match anything, as long as it's not this.\n        if (this.negate)\n            re = '^(?!' + re + ').+$';\n        try {\n            this.regexp = new RegExp(re, [...flags].join(''));\n            /* c8 ignore start */\n        }\n        catch (ex) {\n            // should be impossible\n            this.regexp = false;\n        }\n        /* c8 ignore stop */\n        return this.regexp;\n    }\n    slashSplit(p) {\n        // if p starts with // on windows, we preserve that\n        // so that UNC paths aren't broken.  Otherwise, any number of\n        // / characters are coalesced into one, unless\n        // preserveMultipleSlashes is set to true.\n        if (this.preserveMultipleSlashes) {\n            return p.split('/');\n        }\n        else if (this.isWindows && /^\\/\\/[^\\/]+/.test(p)) {\n            // add an extra '' for the one we lose\n            return ['', ...p.split(/\\/+/)];\n        }\n        else {\n            return p.split(/\\/+/);\n        }\n    }\n    match(f, partial = this.partial) {\n        this.debug('match', f, this.pattern);\n        // short-circuit in the case of busted things.\n        // comments, etc.\n        if (this.comment) {\n            return false;\n        }\n        if (this.empty) {\n            return f === '';\n        }\n        if (f === '/' && partial) {\n            return true;\n        }\n        const options = this.options;\n        // windows: need to use /, not \\\n        if (this.isWindows) {\n            f = f.split('\\\\').join('/');\n        }\n        // treat the test path as a set of pathparts.\n        const ff = this.slashSplit(f);\n        this.debug(this.pattern, 'split', ff);\n        // just ONE of the pattern sets in this.set needs to match\n        // in order for it to be valid.  If negating, then just one\n        // match means that we have failed.\n        // Either way, return on the first hit.\n        const set = this.set;\n        this.debug(this.pattern, 'set', set);\n        // Find the basename of the path by looking for the last non-empty segment\n        let filename = ff[ff.length - 1];\n        if (!filename) {\n            for (let i = ff.length - 2; !filename && i >= 0; i--) {\n                filename = ff[i];\n            }\n        }\n        for (let i = 0; i < set.length; i++) {\n            const pattern = set[i];\n            let file = ff;\n            if (options.matchBase && pattern.length === 1) {\n                file = [filename];\n            }\n            const hit = this.matchOne(file, pattern, partial);\n            if (hit) {\n                if (options.flipNegate) {\n                    return true;\n                }\n                return !this.negate;\n            }\n        }\n        // didn't get any hits.  this is success if it's a negative\n        // pattern, failure otherwise.\n        if (options.flipNegate) {\n            return false;\n        }\n        return this.negate;\n    }\n    static defaults(def) {\n        return exports.minimatch.defaults(def).Minimatch;\n    }\n}\nexports.Minimatch = Minimatch;\n/* c8 ignore start */\nvar ast_js_2 = __webpack_require__(/*! ./ast.js */ \"(rsc)/./node_modules/minimatch/dist/commonjs/ast.js\");\nObject.defineProperty(exports, \"AST\", ({ enumerable: true, get: function () { return ast_js_2.AST; } }));\nvar escape_js_2 = __webpack_require__(/*! ./escape.js */ \"(rsc)/./node_modules/minimatch/dist/commonjs/escape.js\");\nObject.defineProperty(exports, \"escape\", ({ enumerable: true, get: function () { return escape_js_2.escape; } }));\nvar unescape_js_2 = __webpack_require__(/*! ./unescape.js */ \"(rsc)/./node_modules/minimatch/dist/commonjs/unescape.js\");\nObject.defineProperty(exports, \"unescape\", ({ enumerable: true, get: function () { return unescape_js_2.unescape; } }));\n/* c8 ignore stop */\nexports.minimatch.AST = ast_js_1.AST;\nexports.minimatch.Minimatch = Minimatch;\nexports.minimatch.escape = escape_js_1.escape;\nexports.minimatch.unescape = unescape_js_1.unescape;\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbWluaW1hdGNoL2Rpc3QvY29tbW9uanMvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBLDZDQUE2QztBQUM3QztBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxnQkFBZ0IsR0FBRyxjQUFjLEdBQUcsV0FBVyxHQUFHLGlCQUFpQixHQUFHLGFBQWEsR0FBRyxjQUFjLEdBQUcsbUJBQW1CLEdBQUcsZ0JBQWdCLEdBQUcsY0FBYyxHQUFHLGdCQUFnQixHQUFHLFdBQVcsR0FBRyxpQkFBaUI7QUFDbk4sMENBQTBDLG1CQUFPLENBQUMsc0VBQWlCO0FBQ25FLGtDQUFrQyxtQkFBTyxDQUFDLHVHQUEyQjtBQUNyRSxpQkFBaUIsbUJBQU8sQ0FBQyxxRUFBVTtBQUNuQyxvQkFBb0IsbUJBQU8sQ0FBQywyRUFBYTtBQUN6QyxzQkFBc0IsbUJBQU8sQ0FBQywrRUFBZTtBQUM3QywyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsV0FBVztBQUN4QixhQUFhLFVBQVU7QUFDdkI7QUFDQTtBQUNBLFdBQVc7QUFDWCxxQkFBcUI7QUFDckIsZ0JBQWdCO0FBQ2hCLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLElBQUk7QUFDOUM7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDLGNBQWM7QUFDZCx3QkFBd0I7QUFDeEIsc0JBQXNCLHFCQUFxQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0Esa0RBQWtEO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRDtBQUNqRDtBQUNBO0FBQ0EsU0FBUztBQUNULGtDQUFrQztBQUNsQyxnQ0FBZ0M7QUFDaEMsc0NBQXNDO0FBQ3RDO0FBQ0Esc0NBQXNDO0FBQ3RDLDJDQUEyQztBQUMzQywyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGdCQUFnQjtBQUNoQiwwQkFBMEI7QUFDMUI7QUFDQSxLQUFLLElBQUk7QUFDVCxLQUFLLEdBQUc7QUFDUixLQUFLLEtBQUs7QUFDVixLQUFLLElBQUksSUFBSSxFQUFFO0FBQ2YsS0FBSyxJQUFJLEVBQUUsSUFBSTtBQUNmO0FBQ0E7QUFDQSxLQUFLLElBQUksT0FBTyxJQUFJO0FBQ3BCLEtBQUssRUFBRSxPQUFPLEVBQUU7QUFDaEIsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixRQUFRLE1BQU07QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQiw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQyxjQUFjO0FBQ2Qsd0JBQXdCO0FBQ3hCLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYix1QkFBdUI7QUFDdkI7QUFDQTtBQUNBLDhDQUE4QztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixxQkFBcUI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixzQkFBc0I7QUFDbEQsZ0NBQWdDLHlCQUF5QjtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isd0JBQXdCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxzQkFBc0I7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxzQkFBc0I7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxRQUFRLGlDQUFpQztBQUN6QyxRQUFRLDJCQUEyQjtBQUNuQyxRQUFRLDhCQUE4QjtBQUN0QztBQUNBLFFBQVEscUNBQXFDO0FBQzdDO0FBQ0E7QUFDQSx3QkFBd0IsMEJBQTBCO0FBQ2xELGdDQUFnQyxzQkFBc0I7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixpREFBaUQ7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHdCQUF3QjtBQUN4QztBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsZUFBZTtBQUN0RDtBQUNBLHdFQUF3RSxvQkFBb0I7QUFDNUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLFNBQVM7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxpQkFBaUI7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxxQkFBcUI7QUFDN0Q7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGdCQUFnQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxlQUFlLG1CQUFPLENBQUMscUVBQVU7QUFDakMsdUNBQXNDLEVBQUUscUNBQXFDLHdCQUF3QixFQUFDO0FBQ3RHLGtCQUFrQixtQkFBTyxDQUFDLDJFQUFhO0FBQ3ZDLDBDQUF5QyxFQUFFLHFDQUFxQyw4QkFBOEIsRUFBQztBQUMvRyxvQkFBb0IsbUJBQU8sQ0FBQywrRUFBZTtBQUMzQyw0Q0FBMkMsRUFBRSxxQ0FBcUMsa0NBQWtDLEVBQUM7QUFDckg7QUFDQSxxQkFBcUI7QUFDckIsMkJBQTJCO0FBQzNCLHdCQUF3QjtBQUN4QiwwQkFBMEI7QUFDMUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hdXRvLWxvb3AtZGVtby8uL25vZGVfbW9kdWxlcy9taW5pbWF0Y2gvZGlzdC9jb21tb25qcy9pbmRleC5qcz9mZWM0Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy51bmVzY2FwZSA9IGV4cG9ydHMuZXNjYXBlID0gZXhwb3J0cy5BU1QgPSBleHBvcnRzLk1pbmltYXRjaCA9IGV4cG9ydHMubWF0Y2ggPSBleHBvcnRzLm1ha2VSZSA9IGV4cG9ydHMuYnJhY2VFeHBhbmQgPSBleHBvcnRzLmRlZmF1bHRzID0gZXhwb3J0cy5maWx0ZXIgPSBleHBvcnRzLkdMT0JTVEFSID0gZXhwb3J0cy5zZXAgPSBleHBvcnRzLm1pbmltYXRjaCA9IHZvaWQgMDtcbmNvbnN0IGJyYWNlX2V4cGFuc2lvbl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJicmFjZS1leHBhbnNpb25cIikpO1xuY29uc3QgYXNzZXJ0X3ZhbGlkX3BhdHRlcm5fanNfMSA9IHJlcXVpcmUoXCIuL2Fzc2VydC12YWxpZC1wYXR0ZXJuLmpzXCIpO1xuY29uc3QgYXN0X2pzXzEgPSByZXF1aXJlKFwiLi9hc3QuanNcIik7XG5jb25zdCBlc2NhcGVfanNfMSA9IHJlcXVpcmUoXCIuL2VzY2FwZS5qc1wiKTtcbmNvbnN0IHVuZXNjYXBlX2pzXzEgPSByZXF1aXJlKFwiLi91bmVzY2FwZS5qc1wiKTtcbmNvbnN0IG1pbmltYXRjaCA9IChwLCBwYXR0ZXJuLCBvcHRpb25zID0ge30pID0+IHtcbiAgICAoMCwgYXNzZXJ0X3ZhbGlkX3BhdHRlcm5fanNfMS5hc3NlcnRWYWxpZFBhdHRlcm4pKHBhdHRlcm4pO1xuICAgIC8vIHNob3J0Y3V0OiBjb21tZW50cyBtYXRjaCBub3RoaW5nLlxuICAgIGlmICghb3B0aW9ucy5ub2NvbW1lbnQgJiYgcGF0dGVybi5jaGFyQXQoMCkgPT09ICcjJykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBuZXcgTWluaW1hdGNoKHBhdHRlcm4sIG9wdGlvbnMpLm1hdGNoKHApO1xufTtcbmV4cG9ydHMubWluaW1hdGNoID0gbWluaW1hdGNoO1xuLy8gT3B0aW1pemVkIGNoZWNraW5nIGZvciB0aGUgbW9zdCBjb21tb24gZ2xvYiBwYXR0ZXJucy5cbmNvbnN0IHN0YXJEb3RFeHRSRSA9IC9eXFwqKyhbXitAIT9cXCpcXFtcXChdKikkLztcbmNvbnN0IHN0YXJEb3RFeHRUZXN0ID0gKGV4dCkgPT4gKGYpID0+ICFmLnN0YXJ0c1dpdGgoJy4nKSAmJiBmLmVuZHNXaXRoKGV4dCk7XG5jb25zdCBzdGFyRG90RXh0VGVzdERvdCA9IChleHQpID0+IChmKSA9PiBmLmVuZHNXaXRoKGV4dCk7XG5jb25zdCBzdGFyRG90RXh0VGVzdE5vY2FzZSA9IChleHQpID0+IHtcbiAgICBleHQgPSBleHQudG9Mb3dlckNhc2UoKTtcbiAgICByZXR1cm4gKGYpID0+ICFmLnN0YXJ0c1dpdGgoJy4nKSAmJiBmLnRvTG93ZXJDYXNlKCkuZW5kc1dpdGgoZXh0KTtcbn07XG5jb25zdCBzdGFyRG90RXh0VGVzdE5vY2FzZURvdCA9IChleHQpID0+IHtcbiAgICBleHQgPSBleHQudG9Mb3dlckNhc2UoKTtcbiAgICByZXR1cm4gKGYpID0+IGYudG9Mb3dlckNhc2UoKS5lbmRzV2l0aChleHQpO1xufTtcbmNvbnN0IHN0YXJEb3RTdGFyUkUgPSAvXlxcKitcXC5cXCorJC87XG5jb25zdCBzdGFyRG90U3RhclRlc3QgPSAoZikgPT4gIWYuc3RhcnRzV2l0aCgnLicpICYmIGYuaW5jbHVkZXMoJy4nKTtcbmNvbnN0IHN0YXJEb3RTdGFyVGVzdERvdCA9IChmKSA9PiBmICE9PSAnLicgJiYgZiAhPT0gJy4uJyAmJiBmLmluY2x1ZGVzKCcuJyk7XG5jb25zdCBkb3RTdGFyUkUgPSAvXlxcLlxcKiskLztcbmNvbnN0IGRvdFN0YXJUZXN0ID0gKGYpID0+IGYgIT09ICcuJyAmJiBmICE9PSAnLi4nICYmIGYuc3RhcnRzV2l0aCgnLicpO1xuY29uc3Qgc3RhclJFID0gL15cXCorJC87XG5jb25zdCBzdGFyVGVzdCA9IChmKSA9PiBmLmxlbmd0aCAhPT0gMCAmJiAhZi5zdGFydHNXaXRoKCcuJyk7XG5jb25zdCBzdGFyVGVzdERvdCA9IChmKSA9PiBmLmxlbmd0aCAhPT0gMCAmJiBmICE9PSAnLicgJiYgZiAhPT0gJy4uJztcbmNvbnN0IHFtYXJrc1JFID0gL15cXD8rKFteK0AhP1xcKlxcW1xcKF0qKT8kLztcbmNvbnN0IHFtYXJrc1Rlc3ROb2Nhc2UgPSAoWyQwLCBleHQgPSAnJ10pID0+IHtcbiAgICBjb25zdCBub2V4dCA9IHFtYXJrc1Rlc3ROb0V4dChbJDBdKTtcbiAgICBpZiAoIWV4dClcbiAgICAgICAgcmV0dXJuIG5vZXh0O1xuICAgIGV4dCA9IGV4dC50b0xvd2VyQ2FzZSgpO1xuICAgIHJldHVybiAoZikgPT4gbm9leHQoZikgJiYgZi50b0xvd2VyQ2FzZSgpLmVuZHNXaXRoKGV4dCk7XG59O1xuY29uc3QgcW1hcmtzVGVzdE5vY2FzZURvdCA9IChbJDAsIGV4dCA9ICcnXSkgPT4ge1xuICAgIGNvbnN0IG5vZXh0ID0gcW1hcmtzVGVzdE5vRXh0RG90KFskMF0pO1xuICAgIGlmICghZXh0KVxuICAgICAgICByZXR1cm4gbm9leHQ7XG4gICAgZXh0ID0gZXh0LnRvTG93ZXJDYXNlKCk7XG4gICAgcmV0dXJuIChmKSA9PiBub2V4dChmKSAmJiBmLnRvTG93ZXJDYXNlKCkuZW5kc1dpdGgoZXh0KTtcbn07XG5jb25zdCBxbWFya3NUZXN0RG90ID0gKFskMCwgZXh0ID0gJyddKSA9PiB7XG4gICAgY29uc3Qgbm9leHQgPSBxbWFya3NUZXN0Tm9FeHREb3QoWyQwXSk7XG4gICAgcmV0dXJuICFleHQgPyBub2V4dCA6IChmKSA9PiBub2V4dChmKSAmJiBmLmVuZHNXaXRoKGV4dCk7XG59O1xuY29uc3QgcW1hcmtzVGVzdCA9IChbJDAsIGV4dCA9ICcnXSkgPT4ge1xuICAgIGNvbnN0IG5vZXh0ID0gcW1hcmtzVGVzdE5vRXh0KFskMF0pO1xuICAgIHJldHVybiAhZXh0ID8gbm9leHQgOiAoZikgPT4gbm9leHQoZikgJiYgZi5lbmRzV2l0aChleHQpO1xufTtcbmNvbnN0IHFtYXJrc1Rlc3ROb0V4dCA9IChbJDBdKSA9PiB7XG4gICAgY29uc3QgbGVuID0gJDAubGVuZ3RoO1xuICAgIHJldHVybiAoZikgPT4gZi5sZW5ndGggPT09IGxlbiAmJiAhZi5zdGFydHNXaXRoKCcuJyk7XG59O1xuY29uc3QgcW1hcmtzVGVzdE5vRXh0RG90ID0gKFskMF0pID0+IHtcbiAgICBjb25zdCBsZW4gPSAkMC5sZW5ndGg7XG4gICAgcmV0dXJuIChmKSA9PiBmLmxlbmd0aCA9PT0gbGVuICYmIGYgIT09ICcuJyAmJiBmICE9PSAnLi4nO1xufTtcbi8qIGM4IGlnbm9yZSBzdGFydCAqL1xuY29uc3QgZGVmYXVsdFBsYXRmb3JtID0gKHR5cGVvZiBwcm9jZXNzID09PSAnb2JqZWN0JyAmJiBwcm9jZXNzXG4gICAgPyAodHlwZW9mIHByb2Nlc3MuZW52ID09PSAnb2JqZWN0JyAmJlxuICAgICAgICBwcm9jZXNzLmVudiAmJlxuICAgICAgICBwcm9jZXNzLmVudi5fX01JTklNQVRDSF9URVNUSU5HX1BMQVRGT1JNX18pIHx8XG4gICAgICAgIHByb2Nlc3MucGxhdGZvcm1cbiAgICA6ICdwb3NpeCcpO1xuY29uc3QgcGF0aCA9IHtcbiAgICB3aW4zMjogeyBzZXA6ICdcXFxcJyB9LFxuICAgIHBvc2l4OiB7IHNlcDogJy8nIH0sXG59O1xuLyogYzggaWdub3JlIHN0b3AgKi9cbmV4cG9ydHMuc2VwID0gZGVmYXVsdFBsYXRmb3JtID09PSAnd2luMzInID8gcGF0aC53aW4zMi5zZXAgOiBwYXRoLnBvc2l4LnNlcDtcbmV4cG9ydHMubWluaW1hdGNoLnNlcCA9IGV4cG9ydHMuc2VwO1xuZXhwb3J0cy5HTE9CU1RBUiA9IFN5bWJvbCgnZ2xvYnN0YXIgKionKTtcbmV4cG9ydHMubWluaW1hdGNoLkdMT0JTVEFSID0gZXhwb3J0cy5HTE9CU1RBUjtcbi8vIGFueSBzaW5nbGUgdGhpbmcgb3RoZXIgdGhhbiAvXG4vLyBkb24ndCBuZWVkIHRvIGVzY2FwZSAvIHdoZW4gdXNpbmcgbmV3IFJlZ0V4cCgpXG5jb25zdCBxbWFyayA9ICdbXi9dJztcbi8vICogPT4gYW55IG51bWJlciBvZiBjaGFyYWN0ZXJzXG5jb25zdCBzdGFyID0gcW1hcmsgKyAnKj8nO1xuLy8gKiogd2hlbiBkb3RzIGFyZSBhbGxvd2VkLiAgQW55dGhpbmcgZ29lcywgZXhjZXB0IC4uIGFuZCAuXG4vLyBub3QgKF4gb3IgLyBmb2xsb3dlZCBieSBvbmUgb3IgdHdvIGRvdHMgZm9sbG93ZWQgYnkgJCBvciAvKSxcbi8vIGZvbGxvd2VkIGJ5IGFueXRoaW5nLCBhbnkgbnVtYmVyIG9mIHRpbWVzLlxuY29uc3QgdHdvU3RhckRvdCA9ICcoPzooPyEoPzpcXFxcL3xeKSg/OlxcXFwuezEsMn0pKCR8XFxcXC8pKS4pKj8nO1xuLy8gbm90IGEgXiBvciAvIGZvbGxvd2VkIGJ5IGEgZG90LFxuLy8gZm9sbG93ZWQgYnkgYW55dGhpbmcsIGFueSBudW1iZXIgb2YgdGltZXMuXG5jb25zdCB0d29TdGFyTm9Eb3QgPSAnKD86KD8hKD86XFxcXC98XilcXFxcLikuKSo/JztcbmNvbnN0IGZpbHRlciA9IChwYXR0ZXJuLCBvcHRpb25zID0ge30pID0+IChwKSA9PiAoMCwgZXhwb3J0cy5taW5pbWF0Y2gpKHAsIHBhdHRlcm4sIG9wdGlvbnMpO1xuZXhwb3J0cy5maWx0ZXIgPSBmaWx0ZXI7XG5leHBvcnRzLm1pbmltYXRjaC5maWx0ZXIgPSBleHBvcnRzLmZpbHRlcjtcbmNvbnN0IGV4dCA9IChhLCBiID0ge30pID0+IE9iamVjdC5hc3NpZ24oe30sIGEsIGIpO1xuY29uc3QgZGVmYXVsdHMgPSAoZGVmKSA9PiB7XG4gICAgaWYgKCFkZWYgfHwgdHlwZW9mIGRlZiAhPT0gJ29iamVjdCcgfHwgIU9iamVjdC5rZXlzKGRlZikubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBleHBvcnRzLm1pbmltYXRjaDtcbiAgICB9XG4gICAgY29uc3Qgb3JpZyA9IGV4cG9ydHMubWluaW1hdGNoO1xuICAgIGNvbnN0IG0gPSAocCwgcGF0dGVybiwgb3B0aW9ucyA9IHt9KSA9PiBvcmlnKHAsIHBhdHRlcm4sIGV4dChkZWYsIG9wdGlvbnMpKTtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihtLCB7XG4gICAgICAgIE1pbmltYXRjaDogY2xhc3MgTWluaW1hdGNoIGV4dGVuZHMgb3JpZy5NaW5pbWF0Y2gge1xuICAgICAgICAgICAgY29uc3RydWN0b3IocGF0dGVybiwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgICAgICAgICAgc3VwZXIocGF0dGVybiwgZXh0KGRlZiwgb3B0aW9ucykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3RhdGljIGRlZmF1bHRzKG9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gb3JpZy5kZWZhdWx0cyhleHQoZGVmLCBvcHRpb25zKSkuTWluaW1hdGNoO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBBU1Q6IGNsYXNzIEFTVCBleHRlbmRzIG9yaWcuQVNUIHtcbiAgICAgICAgICAgIC8qIGM4IGlnbm9yZSBzdGFydCAqL1xuICAgICAgICAgICAgY29uc3RydWN0b3IodHlwZSwgcGFyZW50LCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgICAgICAgICBzdXBlcih0eXBlLCBwYXJlbnQsIGV4dChkZWYsIG9wdGlvbnMpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qIGM4IGlnbm9yZSBzdG9wICovXG4gICAgICAgICAgICBzdGF0aWMgZnJvbUdsb2IocGF0dGVybiwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9yaWcuQVNULmZyb21HbG9iKHBhdHRlcm4sIGV4dChkZWYsIG9wdGlvbnMpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgdW5lc2NhcGU6IChzLCBvcHRpb25zID0ge30pID0+IG9yaWcudW5lc2NhcGUocywgZXh0KGRlZiwgb3B0aW9ucykpLFxuICAgICAgICBlc2NhcGU6IChzLCBvcHRpb25zID0ge30pID0+IG9yaWcuZXNjYXBlKHMsIGV4dChkZWYsIG9wdGlvbnMpKSxcbiAgICAgICAgZmlsdGVyOiAocGF0dGVybiwgb3B0aW9ucyA9IHt9KSA9PiBvcmlnLmZpbHRlcihwYXR0ZXJuLCBleHQoZGVmLCBvcHRpb25zKSksXG4gICAgICAgIGRlZmF1bHRzOiAob3B0aW9ucykgPT4gb3JpZy5kZWZhdWx0cyhleHQoZGVmLCBvcHRpb25zKSksXG4gICAgICAgIG1ha2VSZTogKHBhdHRlcm4sIG9wdGlvbnMgPSB7fSkgPT4gb3JpZy5tYWtlUmUocGF0dGVybiwgZXh0KGRlZiwgb3B0aW9ucykpLFxuICAgICAgICBicmFjZUV4cGFuZDogKHBhdHRlcm4sIG9wdGlvbnMgPSB7fSkgPT4gb3JpZy5icmFjZUV4cGFuZChwYXR0ZXJuLCBleHQoZGVmLCBvcHRpb25zKSksXG4gICAgICAgIG1hdGNoOiAobGlzdCwgcGF0dGVybiwgb3B0aW9ucyA9IHt9KSA9PiBvcmlnLm1hdGNoKGxpc3QsIHBhdHRlcm4sIGV4dChkZWYsIG9wdGlvbnMpKSxcbiAgICAgICAgc2VwOiBvcmlnLnNlcCxcbiAgICAgICAgR0xPQlNUQVI6IGV4cG9ydHMuR0xPQlNUQVIsXG4gICAgfSk7XG59O1xuZXhwb3J0cy5kZWZhdWx0cyA9IGRlZmF1bHRzO1xuZXhwb3J0cy5taW5pbWF0Y2guZGVmYXVsdHMgPSBleHBvcnRzLmRlZmF1bHRzO1xuLy8gQnJhY2UgZXhwYW5zaW9uOlxuLy8gYXtiLGN9ZCAtPiBhYmQgYWNkXG4vLyBhe2IsfWMgLT4gYWJjIGFjXG4vLyBhezAuLjN9ZCAtPiBhMGQgYTFkIGEyZCBhM2Rcbi8vIGF7Yixje2QsZX1mfWcgLT4gYWJnIGFjZGZnIGFjZWZnXG4vLyBhe2IsY31ke2UsZn1nIC0+IGFiZGVnIGFjZGVnIGFiZGVnIGFiZGZnXG4vL1xuLy8gSW52YWxpZCBzZXRzIGFyZSBub3QgZXhwYW5kZWQuXG4vLyBhezIuLn1iIC0+IGF7Mi4ufWJcbi8vIGF7Yn1jIC0+IGF7Yn1jXG5jb25zdCBicmFjZUV4cGFuZCA9IChwYXR0ZXJuLCBvcHRpb25zID0ge30pID0+IHtcbiAgICAoMCwgYXNzZXJ0X3ZhbGlkX3BhdHRlcm5fanNfMS5hc3NlcnRWYWxpZFBhdHRlcm4pKHBhdHRlcm4pO1xuICAgIC8vIFRoYW5rcyB0byBZZXRpbmcgTGkgPGh0dHBzOi8vZ2l0aHViLmNvbS95ZXRpbmdsaT4gZm9yXG4gICAgLy8gaW1wcm92aW5nIHRoaXMgcmVnZXhwIHRvIGF2b2lkIGEgUmVET1MgdnVsbmVyYWJpbGl0eS5cbiAgICBpZiAob3B0aW9ucy5ub2JyYWNlIHx8ICEvXFx7KD86KD8hXFx7KS4pKlxcfS8udGVzdChwYXR0ZXJuKSkge1xuICAgICAgICAvLyBzaG9ydGN1dC4gbm8gbmVlZCB0byBleHBhbmQuXG4gICAgICAgIHJldHVybiBbcGF0dGVybl07XG4gICAgfVxuICAgIHJldHVybiAoMCwgYnJhY2VfZXhwYW5zaW9uXzEuZGVmYXVsdCkocGF0dGVybik7XG59O1xuZXhwb3J0cy5icmFjZUV4cGFuZCA9IGJyYWNlRXhwYW5kO1xuZXhwb3J0cy5taW5pbWF0Y2guYnJhY2VFeHBhbmQgPSBleHBvcnRzLmJyYWNlRXhwYW5kO1xuLy8gcGFyc2UgYSBjb21wb25lbnQgb2YgdGhlIGV4cGFuZGVkIHNldC5cbi8vIEF0IHRoaXMgcG9pbnQsIG5vIHBhdHRlcm4gbWF5IGNvbnRhaW4gXCIvXCIgaW4gaXRcbi8vIHNvIHdlJ3JlIGdvaW5nIHRvIHJldHVybiBhIDJkIGFycmF5LCB3aGVyZSBlYWNoIGVudHJ5IGlzIHRoZSBmdWxsXG4vLyBwYXR0ZXJuLCBzcGxpdCBvbiAnLycsIGFuZCB0aGVuIHR1cm5lZCBpbnRvIGEgcmVndWxhciBleHByZXNzaW9uLlxuLy8gQSByZWdleHAgaXMgbWFkZSBhdCB0aGUgZW5kIHdoaWNoIGpvaW5zIGVhY2ggYXJyYXkgd2l0aCBhblxuLy8gZXNjYXBlZCAvLCBhbmQgYW5vdGhlciBmdWxsIG9uZSB3aGljaCBqb2lucyBlYWNoIHJlZ2V4cCB3aXRoIHwuXG4vL1xuLy8gRm9sbG93aW5nIHRoZSBsZWFkIG9mIEJhc2ggNC4xLCBub3RlIHRoYXQgXCIqKlwiIG9ubHkgaGFzIHNwZWNpYWwgbWVhbmluZ1xuLy8gd2hlbiBpdCBpcyB0aGUgKm9ubHkqIHRoaW5nIGluIGEgcGF0aCBwb3J0aW9uLiAgT3RoZXJ3aXNlLCBhbnkgc2VyaWVzXG4vLyBvZiAqIGlzIGVxdWl2YWxlbnQgdG8gYSBzaW5nbGUgKi4gIEdsb2JzdGFyIGJlaGF2aW9yIGlzIGVuYWJsZWQgYnlcbi8vIGRlZmF1bHQsIGFuZCBjYW4gYmUgZGlzYWJsZWQgYnkgc2V0dGluZyBvcHRpb25zLm5vZ2xvYnN0YXIuXG5jb25zdCBtYWtlUmUgPSAocGF0dGVybiwgb3B0aW9ucyA9IHt9KSA9PiBuZXcgTWluaW1hdGNoKHBhdHRlcm4sIG9wdGlvbnMpLm1ha2VSZSgpO1xuZXhwb3J0cy5tYWtlUmUgPSBtYWtlUmU7XG5leHBvcnRzLm1pbmltYXRjaC5tYWtlUmUgPSBleHBvcnRzLm1ha2VSZTtcbmNvbnN0IG1hdGNoID0gKGxpc3QsIHBhdHRlcm4sIG9wdGlvbnMgPSB7fSkgPT4ge1xuICAgIGNvbnN0IG1tID0gbmV3IE1pbmltYXRjaChwYXR0ZXJuLCBvcHRpb25zKTtcbiAgICBsaXN0ID0gbGlzdC5maWx0ZXIoZiA9PiBtbS5tYXRjaChmKSk7XG4gICAgaWYgKG1tLm9wdGlvbnMubm9udWxsICYmICFsaXN0Lmxlbmd0aCkge1xuICAgICAgICBsaXN0LnB1c2gocGF0dGVybik7XG4gICAgfVxuICAgIHJldHVybiBsaXN0O1xufTtcbmV4cG9ydHMubWF0Y2ggPSBtYXRjaDtcbmV4cG9ydHMubWluaW1hdGNoLm1hdGNoID0gZXhwb3J0cy5tYXRjaDtcbi8vIHJlcGxhY2Ugc3R1ZmYgbGlrZSBcXCogd2l0aCAqXG5jb25zdCBnbG9iTWFnaWMgPSAvWz8qXXxbK0AhXVxcKC4qP1xcKXxcXFt8XFxdLztcbmNvbnN0IHJlZ0V4cEVzY2FwZSA9IChzKSA9PiBzLnJlcGxhY2UoL1stW1xcXXt9KCkqKz8uLFxcXFxeJHwjXFxzXS9nLCAnXFxcXCQmJyk7XG5jbGFzcyBNaW5pbWF0Y2gge1xuICAgIG9wdGlvbnM7XG4gICAgc2V0O1xuICAgIHBhdHRlcm47XG4gICAgd2luZG93c1BhdGhzTm9Fc2NhcGU7XG4gICAgbm9uZWdhdGU7XG4gICAgbmVnYXRlO1xuICAgIGNvbW1lbnQ7XG4gICAgZW1wdHk7XG4gICAgcHJlc2VydmVNdWx0aXBsZVNsYXNoZXM7XG4gICAgcGFydGlhbDtcbiAgICBnbG9iU2V0O1xuICAgIGdsb2JQYXJ0cztcbiAgICBub2Nhc2U7XG4gICAgaXNXaW5kb3dzO1xuICAgIHBsYXRmb3JtO1xuICAgIHdpbmRvd3NOb01hZ2ljUm9vdDtcbiAgICByZWdleHA7XG4gICAgY29uc3RydWN0b3IocGF0dGVybiwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgICgwLCBhc3NlcnRfdmFsaWRfcGF0dGVybl9qc18xLmFzc2VydFZhbGlkUGF0dGVybikocGF0dGVybik7XG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICB0aGlzLnBhdHRlcm4gPSBwYXR0ZXJuO1xuICAgICAgICB0aGlzLnBsYXRmb3JtID0gb3B0aW9ucy5wbGF0Zm9ybSB8fCBkZWZhdWx0UGxhdGZvcm07XG4gICAgICAgIHRoaXMuaXNXaW5kb3dzID0gdGhpcy5wbGF0Zm9ybSA9PT0gJ3dpbjMyJztcbiAgICAgICAgdGhpcy53aW5kb3dzUGF0aHNOb0VzY2FwZSA9XG4gICAgICAgICAgICAhIW9wdGlvbnMud2luZG93c1BhdGhzTm9Fc2NhcGUgfHwgb3B0aW9ucy5hbGxvd1dpbmRvd3NFc2NhcGUgPT09IGZhbHNlO1xuICAgICAgICBpZiAodGhpcy53aW5kb3dzUGF0aHNOb0VzY2FwZSkge1xuICAgICAgICAgICAgdGhpcy5wYXR0ZXJuID0gdGhpcy5wYXR0ZXJuLnJlcGxhY2UoL1xcXFwvZywgJy8nKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnByZXNlcnZlTXVsdGlwbGVTbGFzaGVzID0gISFvcHRpb25zLnByZXNlcnZlTXVsdGlwbGVTbGFzaGVzO1xuICAgICAgICB0aGlzLnJlZ2V4cCA9IG51bGw7XG4gICAgICAgIHRoaXMubmVnYXRlID0gZmFsc2U7XG4gICAgICAgIHRoaXMubm9uZWdhdGUgPSAhIW9wdGlvbnMubm9uZWdhdGU7XG4gICAgICAgIHRoaXMuY29tbWVudCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmVtcHR5ID0gZmFsc2U7XG4gICAgICAgIHRoaXMucGFydGlhbCA9ICEhb3B0aW9ucy5wYXJ0aWFsO1xuICAgICAgICB0aGlzLm5vY2FzZSA9ICEhdGhpcy5vcHRpb25zLm5vY2FzZTtcbiAgICAgICAgdGhpcy53aW5kb3dzTm9NYWdpY1Jvb3QgPVxuICAgICAgICAgICAgb3B0aW9ucy53aW5kb3dzTm9NYWdpY1Jvb3QgIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgID8gb3B0aW9ucy53aW5kb3dzTm9NYWdpY1Jvb3RcbiAgICAgICAgICAgICAgICA6ICEhKHRoaXMuaXNXaW5kb3dzICYmIHRoaXMubm9jYXNlKTtcbiAgICAgICAgdGhpcy5nbG9iU2V0ID0gW107XG4gICAgICAgIHRoaXMuZ2xvYlBhcnRzID0gW107XG4gICAgICAgIHRoaXMuc2V0ID0gW107XG4gICAgICAgIC8vIG1ha2UgdGhlIHNldCBvZiByZWdleHBzIGV0Yy5cbiAgICAgICAgdGhpcy5tYWtlKCk7XG4gICAgfVxuICAgIGhhc01hZ2ljKCkge1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLm1hZ2ljYWxCcmFjZXMgJiYgdGhpcy5zZXQubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBwYXR0ZXJuIG9mIHRoaXMuc2V0KSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHBhcnQgb2YgcGF0dGVybikge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcGFydCAhPT0gJ3N0cmluZycpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZGVidWcoLi4uXykgeyB9XG4gICAgbWFrZSgpIHtcbiAgICAgICAgY29uc3QgcGF0dGVybiA9IHRoaXMucGF0dGVybjtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICAgICAgLy8gZW1wdHkgcGF0dGVybnMgYW5kIGNvbW1lbnRzIG1hdGNoIG5vdGhpbmcuXG4gICAgICAgIGlmICghb3B0aW9ucy5ub2NvbW1lbnQgJiYgcGF0dGVybi5jaGFyQXQoMCkgPT09ICcjJykge1xuICAgICAgICAgICAgdGhpcy5jb21tZW50ID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXBhdHRlcm4pIHtcbiAgICAgICAgICAgIHRoaXMuZW1wdHkgPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIHN0ZXAgMTogZmlndXJlIG91dCBuZWdhdGlvbiwgZXRjLlxuICAgICAgICB0aGlzLnBhcnNlTmVnYXRlKCk7XG4gICAgICAgIC8vIHN0ZXAgMjogZXhwYW5kIGJyYWNlc1xuICAgICAgICB0aGlzLmdsb2JTZXQgPSBbLi4ubmV3IFNldCh0aGlzLmJyYWNlRXhwYW5kKCkpXTtcbiAgICAgICAgaWYgKG9wdGlvbnMuZGVidWcpIHtcbiAgICAgICAgICAgIHRoaXMuZGVidWcgPSAoLi4uYXJncykgPT4gY29uc29sZS5lcnJvciguLi5hcmdzKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRlYnVnKHRoaXMucGF0dGVybiwgdGhpcy5nbG9iU2V0KTtcbiAgICAgICAgLy8gc3RlcCAzOiBub3cgd2UgaGF2ZSBhIHNldCwgc28gdHVybiBlYWNoIG9uZSBpbnRvIGEgc2VyaWVzIG9mXG4gICAgICAgIC8vIHBhdGgtcG9ydGlvbiBtYXRjaGluZyBwYXR0ZXJucy5cbiAgICAgICAgLy8gVGhlc2Ugd2lsbCBiZSByZWdleHBzLCBleGNlcHQgaW4gdGhlIGNhc2Ugb2YgXCIqKlwiLCB3aGljaCBpc1xuICAgICAgICAvLyBzZXQgdG8gdGhlIEdMT0JTVEFSIG9iamVjdCBmb3IgZ2xvYnN0YXIgYmVoYXZpb3IsXG4gICAgICAgIC8vIGFuZCB3aWxsIG5vdCBjb250YWluIGFueSAvIGNoYXJhY3RlcnNcbiAgICAgICAgLy9cbiAgICAgICAgLy8gRmlyc3QsIHdlIHByZXByb2Nlc3MgdG8gbWFrZSB0aGUgZ2xvYiBwYXR0ZXJuIHNldHMgYSBiaXQgc2ltcGxlclxuICAgICAgICAvLyBhbmQgZGVkdXBlZC4gIFRoZXJlIGFyZSBzb21lIHBlcmYta2lsbGluZyBwYXR0ZXJucyB0aGF0IGNhbiBjYXVzZVxuICAgICAgICAvLyBwcm9ibGVtcyB3aXRoIGEgZ2xvYiB3YWxrLCBidXQgd2UgY2FuIHNpbXBsaWZ5IHRoZW0gZG93biBhIGJpdC5cbiAgICAgICAgY29uc3QgcmF3R2xvYlBhcnRzID0gdGhpcy5nbG9iU2V0Lm1hcChzID0+IHRoaXMuc2xhc2hTcGxpdChzKSk7XG4gICAgICAgIHRoaXMuZ2xvYlBhcnRzID0gdGhpcy5wcmVwcm9jZXNzKHJhd0dsb2JQYXJ0cyk7XG4gICAgICAgIHRoaXMuZGVidWcodGhpcy5wYXR0ZXJuLCB0aGlzLmdsb2JQYXJ0cyk7XG4gICAgICAgIC8vIGdsb2IgLS0+IHJlZ2V4cHNcbiAgICAgICAgbGV0IHNldCA9IHRoaXMuZ2xvYlBhcnRzLm1hcCgocywgXywgX18pID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzV2luZG93cyAmJiB0aGlzLndpbmRvd3NOb01hZ2ljUm9vdCkge1xuICAgICAgICAgICAgICAgIC8vIGNoZWNrIGlmIGl0J3MgYSBkcml2ZSBvciB1bmMgcGF0aC5cbiAgICAgICAgICAgICAgICBjb25zdCBpc1VOQyA9IHNbMF0gPT09ICcnICYmXG4gICAgICAgICAgICAgICAgICAgIHNbMV0gPT09ICcnICYmXG4gICAgICAgICAgICAgICAgICAgIChzWzJdID09PSAnPycgfHwgIWdsb2JNYWdpYy50ZXN0KHNbMl0pKSAmJlxuICAgICAgICAgICAgICAgICAgICAhZ2xvYk1hZ2ljLnRlc3Qoc1szXSk7XG4gICAgICAgICAgICAgICAgY29uc3QgaXNEcml2ZSA9IC9eW2Etel06L2kudGVzdChzWzBdKTtcbiAgICAgICAgICAgICAgICBpZiAoaXNVTkMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsuLi5zLnNsaWNlKDAsIDQpLCAuLi5zLnNsaWNlKDQpLm1hcChzcyA9PiB0aGlzLnBhcnNlKHNzKSldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChpc0RyaXZlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbc1swXSwgLi4ucy5zbGljZSgxKS5tYXAoc3MgPT4gdGhpcy5wYXJzZShzcykpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcy5tYXAoc3MgPT4gdGhpcy5wYXJzZShzcykpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5kZWJ1Zyh0aGlzLnBhdHRlcm4sIHNldCk7XG4gICAgICAgIC8vIGZpbHRlciBvdXQgZXZlcnl0aGluZyB0aGF0IGRpZG4ndCBjb21waWxlIHByb3Blcmx5LlxuICAgICAgICB0aGlzLnNldCA9IHNldC5maWx0ZXIocyA9PiBzLmluZGV4T2YoZmFsc2UpID09PSAtMSk7XG4gICAgICAgIC8vIGRvIG5vdCB0cmVhdCB0aGUgPyBpbiBVTkMgcGF0aHMgYXMgbWFnaWNcbiAgICAgICAgaWYgKHRoaXMuaXNXaW5kb3dzKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuc2V0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcCA9IHRoaXMuc2V0W2ldO1xuICAgICAgICAgICAgICAgIGlmIChwWzBdID09PSAnJyAmJlxuICAgICAgICAgICAgICAgICAgICBwWzFdID09PSAnJyAmJlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmdsb2JQYXJ0c1tpXVsyXSA9PT0gJz8nICYmXG4gICAgICAgICAgICAgICAgICAgIHR5cGVvZiBwWzNdID09PSAnc3RyaW5nJyAmJlxuICAgICAgICAgICAgICAgICAgICAvXlthLXpdOiQvaS50ZXN0KHBbM10pKSB7XG4gICAgICAgICAgICAgICAgICAgIHBbMl0gPSAnPyc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGVidWcodGhpcy5wYXR0ZXJuLCB0aGlzLnNldCk7XG4gICAgfVxuICAgIC8vIHZhcmlvdXMgdHJhbnNmb3JtcyB0byBlcXVpdmFsZW50IHBhdHRlcm4gc2V0cyB0aGF0IGFyZVxuICAgIC8vIGZhc3RlciB0byBwcm9jZXNzIGluIGEgZmlsZXN5c3RlbSB3YWxrLiAgVGhlIGdvYWwgaXMgdG9cbiAgICAvLyBlbGltaW5hdGUgd2hhdCB3ZSBjYW4sIGFuZCBwdXNoIGFsbCAqKiBwYXR0ZXJucyBhcyBmYXJcbiAgICAvLyB0byB0aGUgcmlnaHQgYXMgcG9zc2libGUsIGV2ZW4gaWYgaXQgaW5jcmVhc2VzIHRoZSBudW1iZXJcbiAgICAvLyBvZiBwYXR0ZXJucyB0aGF0IHdlIGhhdmUgdG8gcHJvY2Vzcy5cbiAgICBwcmVwcm9jZXNzKGdsb2JQYXJ0cykge1xuICAgICAgICAvLyBpZiB3ZSdyZSBub3QgaW4gZ2xvYnN0YXIgbW9kZSwgdGhlbiB0dXJuIGFsbCAqKiBpbnRvICpcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5ub2dsb2JzdGFyKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGdsb2JQYXJ0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgZ2xvYlBhcnRzW2ldLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChnbG9iUGFydHNbaV1bal0gPT09ICcqKicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdsb2JQYXJ0c1tpXVtqXSA9ICcqJztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IG9wdGltaXphdGlvbkxldmVsID0gMSB9ID0gdGhpcy5vcHRpb25zO1xuICAgICAgICBpZiAob3B0aW1pemF0aW9uTGV2ZWwgPj0gMikge1xuICAgICAgICAgICAgLy8gYWdncmVzc2l2ZSBvcHRpbWl6YXRpb24gZm9yIHRoZSBwdXJwb3NlIG9mIGZzIHdhbGtpbmdcbiAgICAgICAgICAgIGdsb2JQYXJ0cyA9IHRoaXMuZmlyc3RQaGFzZVByZVByb2Nlc3MoZ2xvYlBhcnRzKTtcbiAgICAgICAgICAgIGdsb2JQYXJ0cyA9IHRoaXMuc2Vjb25kUGhhc2VQcmVQcm9jZXNzKGdsb2JQYXJ0cyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob3B0aW1pemF0aW9uTGV2ZWwgPj0gMSkge1xuICAgICAgICAgICAgLy8ganVzdCBiYXNpYyBvcHRpbWl6YXRpb25zIHRvIHJlbW92ZSBzb21lIC4uIHBhcnRzXG4gICAgICAgICAgICBnbG9iUGFydHMgPSB0aGlzLmxldmVsT25lT3B0aW1pemUoZ2xvYlBhcnRzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIGp1c3QgY29sbGFwc2UgbXVsdGlwbGUgKiogcG9ydGlvbnMgaW50byBvbmVcbiAgICAgICAgICAgIGdsb2JQYXJ0cyA9IHRoaXMuYWRqYXNjZW50R2xvYnN0YXJPcHRpbWl6ZShnbG9iUGFydHMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBnbG9iUGFydHM7XG4gICAgfVxuICAgIC8vIGp1c3QgZ2V0IHJpZCBvZiBhZGphc2NlbnQgKiogcG9ydGlvbnNcbiAgICBhZGphc2NlbnRHbG9ic3Rhck9wdGltaXplKGdsb2JQYXJ0cykge1xuICAgICAgICByZXR1cm4gZ2xvYlBhcnRzLm1hcChwYXJ0cyA9PiB7XG4gICAgICAgICAgICBsZXQgZ3MgPSAtMTtcbiAgICAgICAgICAgIHdoaWxlICgtMSAhPT0gKGdzID0gcGFydHMuaW5kZXhPZignKionLCBncyArIDEpKSkge1xuICAgICAgICAgICAgICAgIGxldCBpID0gZ3M7XG4gICAgICAgICAgICAgICAgd2hpbGUgKHBhcnRzW2kgKyAxXSA9PT0gJyoqJykge1xuICAgICAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpICE9PSBncykge1xuICAgICAgICAgICAgICAgICAgICBwYXJ0cy5zcGxpY2UoZ3MsIGkgLSBncyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHBhcnRzO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLy8gZ2V0IHJpZCBvZiBhZGphc2NlbnQgKiogYW5kIHJlc29sdmUgLi4gcG9ydGlvbnNcbiAgICBsZXZlbE9uZU9wdGltaXplKGdsb2JQYXJ0cykge1xuICAgICAgICByZXR1cm4gZ2xvYlBhcnRzLm1hcChwYXJ0cyA9PiB7XG4gICAgICAgICAgICBwYXJ0cyA9IHBhcnRzLnJlZHVjZSgoc2V0LCBwYXJ0KSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcHJldiA9IHNldFtzZXQubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgICAgaWYgKHBhcnQgPT09ICcqKicgJiYgcHJldiA9PT0gJyoqJykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2V0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocGFydCA9PT0gJy4uJykge1xuICAgICAgICAgICAgICAgICAgICBpZiAocHJldiAmJiBwcmV2ICE9PSAnLi4nICYmIHByZXYgIT09ICcuJyAmJiBwcmV2ICE9PSAnKionKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXQucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2V0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNldC5wdXNoKHBhcnQpO1xuICAgICAgICAgICAgICAgIHJldHVybiBzZXQ7XG4gICAgICAgICAgICB9LCBbXSk7XG4gICAgICAgICAgICByZXR1cm4gcGFydHMubGVuZ3RoID09PSAwID8gWycnXSA6IHBhcnRzO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgbGV2ZWxUd29GaWxlT3B0aW1pemUocGFydHMpIHtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHBhcnRzKSkge1xuICAgICAgICAgICAgcGFydHMgPSB0aGlzLnNsYXNoU3BsaXQocGFydHMpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBkaWRTb21ldGhpbmcgPSBmYWxzZTtcbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgZGlkU29tZXRoaW5nID0gZmFsc2U7XG4gICAgICAgICAgICAvLyA8cHJlPi88ZT4vPHJlc3Q+IC0+IDxwcmU+LzxyZXN0PlxuICAgICAgICAgICAgaWYgKCF0aGlzLnByZXNlcnZlTXVsdGlwbGVTbGFzaGVzKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCBwYXJ0cy5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcCA9IHBhcnRzW2ldO1xuICAgICAgICAgICAgICAgICAgICAvLyBkb24ndCBzcXVlZXplIG91dCBVTkMgcGF0dGVybnNcbiAgICAgICAgICAgICAgICAgICAgaWYgKGkgPT09IDEgJiYgcCA9PT0gJycgJiYgcGFydHNbMF0gPT09ICcnKVxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwID09PSAnLicgfHwgcCA9PT0gJycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpZFNvbWV0aGluZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJ0cy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpLS07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHBhcnRzWzBdID09PSAnLicgJiZcbiAgICAgICAgICAgICAgICAgICAgcGFydHMubGVuZ3RoID09PSAyICYmXG4gICAgICAgICAgICAgICAgICAgIChwYXJ0c1sxXSA9PT0gJy4nIHx8IHBhcnRzWzFdID09PSAnJykpIHtcbiAgICAgICAgICAgICAgICAgICAgZGlkU29tZXRoaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgcGFydHMucG9wKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gPHByZT4vPHA+Ly4uLzxyZXN0PiAtPiA8cHJlPi88cmVzdD5cbiAgICAgICAgICAgIGxldCBkZCA9IDA7XG4gICAgICAgICAgICB3aGlsZSAoLTEgIT09IChkZCA9IHBhcnRzLmluZGV4T2YoJy4uJywgZGQgKyAxKSkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwID0gcGFydHNbZGQgLSAxXTtcbiAgICAgICAgICAgICAgICBpZiAocCAmJiBwICE9PSAnLicgJiYgcCAhPT0gJy4uJyAmJiBwICE9PSAnKionKSB7XG4gICAgICAgICAgICAgICAgICAgIGRpZFNvbWV0aGluZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHBhcnRzLnNwbGljZShkZCAtIDEsIDIpO1xuICAgICAgICAgICAgICAgICAgICBkZCAtPSAyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSB3aGlsZSAoZGlkU29tZXRoaW5nKTtcbiAgICAgICAgcmV0dXJuIHBhcnRzLmxlbmd0aCA9PT0gMCA/IFsnJ10gOiBwYXJ0cztcbiAgICB9XG4gICAgLy8gRmlyc3QgcGhhc2U6IHNpbmdsZS1wYXR0ZXJuIHByb2Nlc3NpbmdcbiAgICAvLyA8cHJlPiBpcyAxIG9yIG1vcmUgcG9ydGlvbnNcbiAgICAvLyA8cmVzdD4gaXMgMSBvciBtb3JlIHBvcnRpb25zXG4gICAgLy8gPHA+IGlzIGFueSBwb3J0aW9uIG90aGVyIHRoYW4gLiwgLi4sICcnLCBvciAqKlxuICAgIC8vIDxlPiBpcyAuIG9yICcnXG4gICAgLy9cbiAgICAvLyAqKi8uLiBpcyAqYnJ1dGFsKiBmb3IgZmlsZXN5c3RlbSB3YWxraW5nIHBlcmZvcm1hbmNlLCBiZWNhdXNlXG4gICAgLy8gaXQgZWZmZWN0aXZlbHkgcmVzZXRzIHRoZSByZWN1cnNpdmUgd2FsayBlYWNoIHRpbWUgaXQgb2NjdXJzLFxuICAgIC8vIGFuZCAqKiBjYW5ub3QgYmUgcmVkdWNlZCBvdXQgYnkgYSAuLiBwYXR0ZXJuIHBhcnQgbGlrZSBhIHJlZ2V4cFxuICAgIC8vIG9yIG1vc3Qgc3RyaW5ncyAob3RoZXIgdGhhbiAuLiwgLiwgYW5kICcnKSBjYW4gYmUuXG4gICAgLy9cbiAgICAvLyA8cHJlPi8qKi8uLi88cD4vPHA+LzxyZXN0PiAtPiB7PHByZT4vLi4vPHA+LzxwPi88cmVzdD4sPHByZT4vKiovPHA+LzxwPi88cmVzdD59XG4gICAgLy8gPHByZT4vPGU+LzxyZXN0PiAtPiA8cHJlPi88cmVzdD5cbiAgICAvLyA8cHJlPi88cD4vLi4vPHJlc3Q+IC0+IDxwcmU+LzxyZXN0PlxuICAgIC8vICoqLyoqLzxyZXN0PiAtPiAqKi88cmVzdD5cbiAgICAvL1xuICAgIC8vICoqLyovPHJlc3Q+IC0+ICovKiovPHJlc3Q+IDw9PSBub3QgdmFsaWQgYmVjYXVzZSAqKiBkb2Vzbid0IGZvbGxvd1xuICAgIC8vIHRoaXMgV09VTEQgYmUgYWxsb3dlZCBpZiAqKiBkaWQgZm9sbG93IHN5bWxpbmtzLCBvciAqIGRpZG4ndFxuICAgIGZpcnN0UGhhc2VQcmVQcm9jZXNzKGdsb2JQYXJ0cykge1xuICAgICAgICBsZXQgZGlkU29tZXRoaW5nID0gZmFsc2U7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIGRpZFNvbWV0aGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgLy8gPHByZT4vKiovLi4vPHA+LzxwPi88cmVzdD4gLT4gezxwcmU+Ly4uLzxwPi88cD4vPHJlc3Q+LDxwcmU+LyoqLzxwPi88cD4vPHJlc3Q+fVxuICAgICAgICAgICAgZm9yIChsZXQgcGFydHMgb2YgZ2xvYlBhcnRzKSB7XG4gICAgICAgICAgICAgICAgbGV0IGdzID0gLTE7XG4gICAgICAgICAgICAgICAgd2hpbGUgKC0xICE9PSAoZ3MgPSBwYXJ0cy5pbmRleE9mKCcqKicsIGdzICsgMSkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBnc3MgPSBncztcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHBhcnRzW2dzcyArIDFdID09PSAnKionKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyA8cHJlPi8qKi8qKi88cmVzdD4gLT4gPHByZT4vKiovPHJlc3Q+XG4gICAgICAgICAgICAgICAgICAgICAgICBnc3MrKztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBlZywgaWYgZ3MgaXMgMiBhbmQgZ3NzIGlzIDQsIHRoYXQgbWVhbnMgd2UgaGF2ZSAzICoqXG4gICAgICAgICAgICAgICAgICAgIC8vIHBhcnRzLCBhbmQgY2FuIHJlbW92ZSAyIG9mIHRoZW0uXG4gICAgICAgICAgICAgICAgICAgIGlmIChnc3MgPiBncykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFydHMuc3BsaWNlKGdzICsgMSwgZ3NzIC0gZ3MpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGxldCBuZXh0ID0gcGFydHNbZ3MgKyAxXTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcCA9IHBhcnRzW2dzICsgMl07XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHAyID0gcGFydHNbZ3MgKyAzXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5leHQgIT09ICcuLicpXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFwIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBwID09PSAnLicgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIHAgPT09ICcuLicgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICFwMiB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgcDIgPT09ICcuJyB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgcDIgPT09ICcuLicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGRpZFNvbWV0aGluZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIC8vIGVkaXQgcGFydHMgaW4gcGxhY2UsIGFuZCBwdXNoIHRoZSBuZXcgb25lXG4gICAgICAgICAgICAgICAgICAgIHBhcnRzLnNwbGljZShncywgMSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG90aGVyID0gcGFydHMuc2xpY2UoMCk7XG4gICAgICAgICAgICAgICAgICAgIG90aGVyW2dzXSA9ICcqKic7XG4gICAgICAgICAgICAgICAgICAgIGdsb2JQYXJ0cy5wdXNoKG90aGVyKTtcbiAgICAgICAgICAgICAgICAgICAgZ3MtLTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gPHByZT4vPGU+LzxyZXN0PiAtPiA8cHJlPi88cmVzdD5cbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMucHJlc2VydmVNdWx0aXBsZVNsYXNoZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCBwYXJ0cy5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHAgPSBwYXJ0c1tpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGRvbid0IHNxdWVlemUgb3V0IFVOQyBwYXR0ZXJuc1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGkgPT09IDEgJiYgcCA9PT0gJycgJiYgcGFydHNbMF0gPT09ICcnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHAgPT09ICcuJyB8fCBwID09PSAnJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpZFNvbWV0aGluZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFydHMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGktLTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAocGFydHNbMF0gPT09ICcuJyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgcGFydHMubGVuZ3RoID09PSAyICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAocGFydHNbMV0gPT09ICcuJyB8fCBwYXJ0c1sxXSA9PT0gJycpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkaWRTb21ldGhpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFydHMucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gPHByZT4vPHA+Ly4uLzxyZXN0PiAtPiA8cHJlPi88cmVzdD5cbiAgICAgICAgICAgICAgICBsZXQgZGQgPSAwO1xuICAgICAgICAgICAgICAgIHdoaWxlICgtMSAhPT0gKGRkID0gcGFydHMuaW5kZXhPZignLi4nLCBkZCArIDEpKSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwID0gcGFydHNbZGQgLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHAgJiYgcCAhPT0gJy4nICYmIHAgIT09ICcuLicgJiYgcCAhPT0gJyoqJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGlkU29tZXRoaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG5lZWREb3QgPSBkZCA9PT0gMSAmJiBwYXJ0c1tkZCArIDFdID09PSAnKionO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3BsaW4gPSBuZWVkRG90ID8gWycuJ10gOiBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnRzLnNwbGljZShkZCAtIDEsIDIsIC4uLnNwbGluKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXJ0cy5sZW5ndGggPT09IDApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFydHMucHVzaCgnJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZCAtPSAyO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9IHdoaWxlIChkaWRTb21ldGhpbmcpO1xuICAgICAgICByZXR1cm4gZ2xvYlBhcnRzO1xuICAgIH1cbiAgICAvLyBzZWNvbmQgcGhhc2U6IG11bHRpLXBhdHRlcm4gZGVkdXBlc1xuICAgIC8vIHs8cHJlPi8qLzxyZXN0Piw8cHJlPi88cD4vPHJlc3Q+fSAtPiA8cHJlPi8qLzxyZXN0PlxuICAgIC8vIHs8cHJlPi88cmVzdD4sPHByZT4vPHJlc3Q+fSAtPiA8cHJlPi88cmVzdD5cbiAgICAvLyB7PHByZT4vKiovPHJlc3Q+LDxwcmU+LzxyZXN0Pn0gLT4gPHByZT4vKiovPHJlc3Q+XG4gICAgLy9cbiAgICAvLyB7PHByZT4vKiovPHJlc3Q+LDxwcmU+LyoqLzxwPi88cmVzdD59IC0+IDxwcmU+LyoqLzxyZXN0PlxuICAgIC8vIF4tLSBub3QgdmFsaWQgYmVjYXVzZSAqKiBkb2Vucyd0IGZvbGxvdyBzeW1saW5rc1xuICAgIHNlY29uZFBoYXNlUHJlUHJvY2VzcyhnbG9iUGFydHMpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBnbG9iUGFydHMubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBqID0gaSArIDE7IGogPCBnbG9iUGFydHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBtYXRjaGVkID0gdGhpcy5wYXJ0c01hdGNoKGdsb2JQYXJ0c1tpXSwgZ2xvYlBhcnRzW2pdLCAhdGhpcy5wcmVzZXJ2ZU11bHRpcGxlU2xhc2hlcyk7XG4gICAgICAgICAgICAgICAgaWYgKG1hdGNoZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgZ2xvYlBhcnRzW2ldID0gW107XG4gICAgICAgICAgICAgICAgICAgIGdsb2JQYXJ0c1tqXSA9IG1hdGNoZWQ7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZ2xvYlBhcnRzLmZpbHRlcihncyA9PiBncy5sZW5ndGgpO1xuICAgIH1cbiAgICBwYXJ0c01hdGNoKGEsIGIsIGVtcHR5R1NNYXRjaCA9IGZhbHNlKSB7XG4gICAgICAgIGxldCBhaSA9IDA7XG4gICAgICAgIGxldCBiaSA9IDA7XG4gICAgICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICAgICAgbGV0IHdoaWNoID0gJyc7XG4gICAgICAgIHdoaWxlIChhaSA8IGEubGVuZ3RoICYmIGJpIDwgYi5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmIChhW2FpXSA9PT0gYltiaV0pIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh3aGljaCA9PT0gJ2InID8gYltiaV0gOiBhW2FpXSk7XG4gICAgICAgICAgICAgICAgYWkrKztcbiAgICAgICAgICAgICAgICBiaSsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZW1wdHlHU01hdGNoICYmIGFbYWldID09PSAnKionICYmIGJbYmldID09PSBhW2FpICsgMV0pIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChhW2FpXSk7XG4gICAgICAgICAgICAgICAgYWkrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGVtcHR5R1NNYXRjaCAmJiBiW2JpXSA9PT0gJyoqJyAmJiBhW2FpXSA9PT0gYltiaSArIDFdKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goYltiaV0pO1xuICAgICAgICAgICAgICAgIGJpKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChhW2FpXSA9PT0gJyonICYmXG4gICAgICAgICAgICAgICAgYltiaV0gJiZcbiAgICAgICAgICAgICAgICAodGhpcy5vcHRpb25zLmRvdCB8fCAhYltiaV0uc3RhcnRzV2l0aCgnLicpKSAmJlxuICAgICAgICAgICAgICAgIGJbYmldICE9PSAnKionKSB7XG4gICAgICAgICAgICAgICAgaWYgKHdoaWNoID09PSAnYicpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB3aGljaCA9ICdhJztcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChhW2FpXSk7XG4gICAgICAgICAgICAgICAgYWkrKztcbiAgICAgICAgICAgICAgICBiaSsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYltiaV0gPT09ICcqJyAmJlxuICAgICAgICAgICAgICAgIGFbYWldICYmXG4gICAgICAgICAgICAgICAgKHRoaXMub3B0aW9ucy5kb3QgfHwgIWFbYWldLnN0YXJ0c1dpdGgoJy4nKSkgJiZcbiAgICAgICAgICAgICAgICBhW2FpXSAhPT0gJyoqJykge1xuICAgICAgICAgICAgICAgIGlmICh3aGljaCA9PT0gJ2EnKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgd2hpY2ggPSAnYic7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goYltiaV0pO1xuICAgICAgICAgICAgICAgIGFpKys7XG4gICAgICAgICAgICAgICAgYmkrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBpZiB3ZSBmYWxsIG91dCBvZiB0aGUgbG9vcCwgaXQgbWVhbnMgdGhleSB0d28gYXJlIGlkZW50aWNhbFxuICAgICAgICAvLyBhcyBsb25nIGFzIHRoZWlyIGxlbmd0aHMgbWF0Y2hcbiAgICAgICAgcmV0dXJuIGEubGVuZ3RoID09PSBiLmxlbmd0aCAmJiByZXN1bHQ7XG4gICAgfVxuICAgIHBhcnNlTmVnYXRlKCkge1xuICAgICAgICBpZiAodGhpcy5ub25lZ2F0ZSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3QgcGF0dGVybiA9IHRoaXMucGF0dGVybjtcbiAgICAgICAgbGV0IG5lZ2F0ZSA9IGZhbHNlO1xuICAgICAgICBsZXQgbmVnYXRlT2Zmc2V0ID0gMDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXR0ZXJuLmxlbmd0aCAmJiBwYXR0ZXJuLmNoYXJBdChpKSA9PT0gJyEnOyBpKyspIHtcbiAgICAgICAgICAgIG5lZ2F0ZSA9ICFuZWdhdGU7XG4gICAgICAgICAgICBuZWdhdGVPZmZzZXQrKztcbiAgICAgICAgfVxuICAgICAgICBpZiAobmVnYXRlT2Zmc2V0KVxuICAgICAgICAgICAgdGhpcy5wYXR0ZXJuID0gcGF0dGVybi5zbGljZShuZWdhdGVPZmZzZXQpO1xuICAgICAgICB0aGlzLm5lZ2F0ZSA9IG5lZ2F0ZTtcbiAgICB9XG4gICAgLy8gc2V0IHBhcnRpYWwgdG8gdHJ1ZSB0byB0ZXN0IGlmLCBmb3IgZXhhbXBsZSxcbiAgICAvLyBcIi9hL2JcIiBtYXRjaGVzIHRoZSBzdGFydCBvZiBcIi8qL2IvKi9kXCJcbiAgICAvLyBQYXJ0aWFsIG1lYW5zLCBpZiB5b3UgcnVuIG91dCBvZiBmaWxlIGJlZm9yZSB5b3UgcnVuXG4gICAgLy8gb3V0IG9mIHBhdHRlcm4sIHRoZW4gdGhhdCdzIGZpbmUsIGFzIGxvbmcgYXMgYWxsXG4gICAgLy8gdGhlIHBhcnRzIG1hdGNoLlxuICAgIG1hdGNoT25lKGZpbGUsIHBhdHRlcm4sIHBhcnRpYWwgPSBmYWxzZSkge1xuICAgICAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgICAgICAvLyBVTkMgcGF0aHMgbGlrZSAvLz8vWDovLi4uIGNhbiBtYXRjaCBYOi8uLi4gYW5kIHZpY2UgdmVyc2FcbiAgICAgICAgLy8gRHJpdmUgbGV0dGVycyBpbiBhYnNvbHV0ZSBkcml2ZSBvciB1bmMgcGF0aHMgYXJlIGFsd2F5cyBjb21wYXJlZFxuICAgICAgICAvLyBjYXNlLWluc2Vuc2l0aXZlbHkuXG4gICAgICAgIGlmICh0aGlzLmlzV2luZG93cykge1xuICAgICAgICAgICAgY29uc3QgZmlsZURyaXZlID0gdHlwZW9mIGZpbGVbMF0gPT09ICdzdHJpbmcnICYmIC9eW2Etel06JC9pLnRlc3QoZmlsZVswXSk7XG4gICAgICAgICAgICBjb25zdCBmaWxlVU5DID0gIWZpbGVEcml2ZSAmJlxuICAgICAgICAgICAgICAgIGZpbGVbMF0gPT09ICcnICYmXG4gICAgICAgICAgICAgICAgZmlsZVsxXSA9PT0gJycgJiZcbiAgICAgICAgICAgICAgICBmaWxlWzJdID09PSAnPycgJiZcbiAgICAgICAgICAgICAgICAvXlthLXpdOiQvaS50ZXN0KGZpbGVbM10pO1xuICAgICAgICAgICAgY29uc3QgcGF0dGVybkRyaXZlID0gdHlwZW9mIHBhdHRlcm5bMF0gPT09ICdzdHJpbmcnICYmIC9eW2Etel06JC9pLnRlc3QocGF0dGVyblswXSk7XG4gICAgICAgICAgICBjb25zdCBwYXR0ZXJuVU5DID0gIXBhdHRlcm5Ecml2ZSAmJlxuICAgICAgICAgICAgICAgIHBhdHRlcm5bMF0gPT09ICcnICYmXG4gICAgICAgICAgICAgICAgcGF0dGVyblsxXSA9PT0gJycgJiZcbiAgICAgICAgICAgICAgICBwYXR0ZXJuWzJdID09PSAnPycgJiZcbiAgICAgICAgICAgICAgICB0eXBlb2YgcGF0dGVyblszXSA9PT0gJ3N0cmluZycgJiZcbiAgICAgICAgICAgICAgICAvXlthLXpdOiQvaS50ZXN0KHBhdHRlcm5bM10pO1xuICAgICAgICAgICAgY29uc3QgZmRpID0gZmlsZVVOQyA/IDMgOiBmaWxlRHJpdmUgPyAwIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgY29uc3QgcGRpID0gcGF0dGVyblVOQyA/IDMgOiBwYXR0ZXJuRHJpdmUgPyAwIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBmZGkgPT09ICdudW1iZXInICYmIHR5cGVvZiBwZGkgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgW2ZkLCBwZF0gPSBbZmlsZVtmZGldLCBwYXR0ZXJuW3BkaV1dO1xuICAgICAgICAgICAgICAgIGlmIChmZC50b0xvd2VyQ2FzZSgpID09PSBwZC50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhdHRlcm5bcGRpXSA9IGZkO1xuICAgICAgICAgICAgICAgICAgICBpZiAocGRpID4gZmRpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXR0ZXJuID0gcGF0dGVybi5zbGljZShwZGkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGZkaSA+IHBkaSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZmlsZSA9IGZpbGUuc2xpY2UoZmRpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyByZXNvbHZlIGFuZCByZWR1Y2UgLiBhbmQgLi4gcG9ydGlvbnMgaW4gdGhlIGZpbGUgYXMgd2VsbC5cbiAgICAgICAgLy8gZG9udCcgbmVlZCB0byBkbyB0aGUgc2Vjb25kIHBoYXNlLCBiZWNhdXNlIGl0J3Mgb25seSBvbmUgc3RyaW5nW11cbiAgICAgICAgY29uc3QgeyBvcHRpbWl6YXRpb25MZXZlbCA9IDEgfSA9IHRoaXMub3B0aW9ucztcbiAgICAgICAgaWYgKG9wdGltaXphdGlvbkxldmVsID49IDIpIHtcbiAgICAgICAgICAgIGZpbGUgPSB0aGlzLmxldmVsVHdvRmlsZU9wdGltaXplKGZpbGUpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGVidWcoJ21hdGNoT25lJywgdGhpcywgeyBmaWxlLCBwYXR0ZXJuIH0pO1xuICAgICAgICB0aGlzLmRlYnVnKCdtYXRjaE9uZScsIGZpbGUubGVuZ3RoLCBwYXR0ZXJuLmxlbmd0aCk7XG4gICAgICAgIGZvciAodmFyIGZpID0gMCwgcGkgPSAwLCBmbCA9IGZpbGUubGVuZ3RoLCBwbCA9IHBhdHRlcm4ubGVuZ3RoOyBmaSA8IGZsICYmIHBpIDwgcGw7IGZpKyssIHBpKyspIHtcbiAgICAgICAgICAgIHRoaXMuZGVidWcoJ21hdGNoT25lIGxvb3AnKTtcbiAgICAgICAgICAgIHZhciBwID0gcGF0dGVybltwaV07XG4gICAgICAgICAgICB2YXIgZiA9IGZpbGVbZmldO1xuICAgICAgICAgICAgdGhpcy5kZWJ1ZyhwYXR0ZXJuLCBwLCBmKTtcbiAgICAgICAgICAgIC8vIHNob3VsZCBiZSBpbXBvc3NpYmxlLlxuICAgICAgICAgICAgLy8gc29tZSBpbnZhbGlkIHJlZ2V4cCBzdHVmZiBpbiB0aGUgc2V0LlxuICAgICAgICAgICAgLyogYzggaWdub3JlIHN0YXJ0ICovXG4gICAgICAgICAgICBpZiAocCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvKiBjOCBpZ25vcmUgc3RvcCAqL1xuICAgICAgICAgICAgaWYgKHAgPT09IGV4cG9ydHMuR0xPQlNUQVIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRlYnVnKCdHTE9CU1RBUicsIFtwYXR0ZXJuLCBwLCBmXSk7XG4gICAgICAgICAgICAgICAgLy8gXCIqKlwiXG4gICAgICAgICAgICAgICAgLy8gYS8qKi9iLyoqL2Mgd291bGQgbWF0Y2ggdGhlIGZvbGxvd2luZzpcbiAgICAgICAgICAgICAgICAvLyBhL2IveC95L3ovY1xuICAgICAgICAgICAgICAgIC8vIGEveC95L3ovYi9jXG4gICAgICAgICAgICAgICAgLy8gYS9iL3gvYi94L2NcbiAgICAgICAgICAgICAgICAvLyBhL2IvY1xuICAgICAgICAgICAgICAgIC8vIFRvIGRvIHRoaXMsIHRha2UgdGhlIHJlc3Qgb2YgdGhlIHBhdHRlcm4gYWZ0ZXJcbiAgICAgICAgICAgICAgICAvLyB0aGUgKiosIGFuZCBzZWUgaWYgaXQgd291bGQgbWF0Y2ggdGhlIGZpbGUgcmVtYWluZGVyLlxuICAgICAgICAgICAgICAgIC8vIElmIHNvLCByZXR1cm4gc3VjY2Vzcy5cbiAgICAgICAgICAgICAgICAvLyBJZiBub3QsIHRoZSAqKiBcInN3YWxsb3dzXCIgYSBzZWdtZW50LCBhbmQgdHJ5IGFnYWluLlxuICAgICAgICAgICAgICAgIC8vIFRoaXMgaXMgcmVjdXJzaXZlbHkgYXdmdWwuXG4gICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAvLyBhLyoqL2IvKiovYyBtYXRjaGluZyBhL2IveC95L3ovY1xuICAgICAgICAgICAgICAgIC8vIC0gYSBtYXRjaGVzIGFcbiAgICAgICAgICAgICAgICAvLyAtIGRvdWJsZXN0YXJcbiAgICAgICAgICAgICAgICAvLyAgIC0gbWF0Y2hPbmUoYi94L3kvei9jLCBiLyoqL2MpXG4gICAgICAgICAgICAgICAgLy8gICAgIC0gYiBtYXRjaGVzIGJcbiAgICAgICAgICAgICAgICAvLyAgICAgLSBkb3VibGVzdGFyXG4gICAgICAgICAgICAgICAgLy8gICAgICAgLSBtYXRjaE9uZSh4L3kvei9jLCBjKSAtPiBub1xuICAgICAgICAgICAgICAgIC8vICAgICAgIC0gbWF0Y2hPbmUoeS96L2MsIGMpIC0+IG5vXG4gICAgICAgICAgICAgICAgLy8gICAgICAgLSBtYXRjaE9uZSh6L2MsIGMpIC0+IG5vXG4gICAgICAgICAgICAgICAgLy8gICAgICAgLSBtYXRjaE9uZShjLCBjKSB5ZXMsIGhpdFxuICAgICAgICAgICAgICAgIHZhciBmciA9IGZpO1xuICAgICAgICAgICAgICAgIHZhciBwciA9IHBpICsgMTtcbiAgICAgICAgICAgICAgICBpZiAocHIgPT09IHBsKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGVidWcoJyoqIGF0IHRoZSBlbmQnKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gYSAqKiBhdCB0aGUgZW5kIHdpbGwganVzdCBzd2FsbG93IHRoZSByZXN0LlxuICAgICAgICAgICAgICAgICAgICAvLyBXZSBoYXZlIGZvdW5kIGEgbWF0Y2guXG4gICAgICAgICAgICAgICAgICAgIC8vIGhvd2V2ZXIsIGl0IHdpbGwgbm90IHN3YWxsb3cgLy54LCB1bmxlc3NcbiAgICAgICAgICAgICAgICAgICAgLy8gb3B0aW9ucy5kb3QgaXMgc2V0LlxuICAgICAgICAgICAgICAgICAgICAvLyAuIGFuZCAuLiBhcmUgKm5ldmVyKiBtYXRjaGVkIGJ5ICoqLCBmb3IgZXhwbG9zaXZlbHlcbiAgICAgICAgICAgICAgICAgICAgLy8gZXhwb25lbnRpYWwgcmVhc29ucy5cbiAgICAgICAgICAgICAgICAgICAgZm9yICg7IGZpIDwgZmw7IGZpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmaWxlW2ZpXSA9PT0gJy4nIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsZVtmaV0gPT09ICcuLicgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoIW9wdGlvbnMuZG90ICYmIGZpbGVbZmldLmNoYXJBdCgwKSA9PT0gJy4nKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIG9rLCBsZXQncyBzZWUgaWYgd2UgY2FuIHN3YWxsb3cgd2hhdGV2ZXIgd2UgY2FuLlxuICAgICAgICAgICAgICAgIHdoaWxlIChmciA8IGZsKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzd2FsbG93ZWUgPSBmaWxlW2ZyXTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kZWJ1ZygnXFxuZ2xvYnN0YXIgd2hpbGUnLCBmaWxlLCBmciwgcGF0dGVybiwgcHIsIHN3YWxsb3dlZSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIFhYWCByZW1vdmUgdGhpcyBzbGljZS4gIEp1c3QgcGFzcyB0aGUgc3RhcnQgaW5kZXguXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLm1hdGNoT25lKGZpbGUuc2xpY2UoZnIpLCBwYXR0ZXJuLnNsaWNlKHByKSwgcGFydGlhbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGVidWcoJ2dsb2JzdGFyIGZvdW5kIG1hdGNoIScsIGZyLCBmbCwgc3dhbGxvd2VlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGZvdW5kIGEgbWF0Y2guXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNhbid0IHN3YWxsb3cgXCIuXCIgb3IgXCIuLlwiIGV2ZXIuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjYW4gb25seSBzd2FsbG93IFwiLmZvb1wiIHdoZW4gZXhwbGljaXRseSBhc2tlZC5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzd2FsbG93ZWUgPT09ICcuJyB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN3YWxsb3dlZSA9PT0gJy4uJyB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICghb3B0aW9ucy5kb3QgJiYgc3dhbGxvd2VlLmNoYXJBdCgwKSA9PT0gJy4nKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGVidWcoJ2RvdCBkZXRlY3RlZCEnLCBmaWxlLCBmciwgcGF0dGVybiwgcHIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gKiogc3dhbGxvd3MgYSBzZWdtZW50LCBhbmQgY29udGludWUuXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRlYnVnKCdnbG9ic3RhciBzd2FsbG93IGEgc2VnbWVudCwgYW5kIGNvbnRpbnVlJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBmcisrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIG5vIG1hdGNoIHdhcyBmb3VuZC5cbiAgICAgICAgICAgICAgICAvLyBIb3dldmVyLCBpbiBwYXJ0aWFsIG1vZGUsIHdlIGNhbid0IHNheSB0aGlzIGlzIG5lY2Vzc2FyaWx5IG92ZXIuXG4gICAgICAgICAgICAgICAgLyogYzggaWdub3JlIHN0YXJ0ICovXG4gICAgICAgICAgICAgICAgaWYgKHBhcnRpYWwpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gcmFuIG91dCBvZiBmaWxlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGVidWcoJ1xcbj4+PiBubyBtYXRjaCwgcGFydGlhbD8nLCBmaWxlLCBmciwgcGF0dGVybiwgcHIpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZnIgPT09IGZsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvKiBjOCBpZ25vcmUgc3RvcCAqL1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHNvbWV0aGluZyBvdGhlciB0aGFuICoqXG4gICAgICAgICAgICAvLyBub24tbWFnaWMgcGF0dGVybnMganVzdCBoYXZlIHRvIG1hdGNoIGV4YWN0bHlcbiAgICAgICAgICAgIC8vIHBhdHRlcm5zIHdpdGggbWFnaWMgaGF2ZSBiZWVuIHR1cm5lZCBpbnRvIHJlZ2V4cHMuXG4gICAgICAgICAgICBsZXQgaGl0O1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBwID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIGhpdCA9IGYgPT09IHA7XG4gICAgICAgICAgICAgICAgdGhpcy5kZWJ1Zygnc3RyaW5nIG1hdGNoJywgcCwgZiwgaGl0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGhpdCA9IHAudGVzdChmKTtcbiAgICAgICAgICAgICAgICB0aGlzLmRlYnVnKCdwYXR0ZXJuIG1hdGNoJywgcCwgZiwgaGl0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghaGl0KVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBOb3RlOiBlbmRpbmcgaW4gLyBtZWFucyB0aGF0IHdlJ2xsIGdldCBhIGZpbmFsIFwiXCJcbiAgICAgICAgLy8gYXQgdGhlIGVuZCBvZiB0aGUgcGF0dGVybi4gIFRoaXMgY2FuIG9ubHkgbWF0Y2ggYVxuICAgICAgICAvLyBjb3JyZXNwb25kaW5nIFwiXCIgYXQgdGhlIGVuZCBvZiB0aGUgZmlsZS5cbiAgICAgICAgLy8gSWYgdGhlIGZpbGUgZW5kcyBpbiAvLCB0aGVuIGl0IGNhbiBvbmx5IG1hdGNoIGFcbiAgICAgICAgLy8gYSBwYXR0ZXJuIHRoYXQgZW5kcyBpbiAvLCB1bmxlc3MgdGhlIHBhdHRlcm4ganVzdFxuICAgICAgICAvLyBkb2Vzbid0IGhhdmUgYW55IG1vcmUgZm9yIGl0LiBCdXQsIGEvYi8gc2hvdWxkICpub3QqXG4gICAgICAgIC8vIG1hdGNoIFwiYS9iLypcIiwgZXZlbiB0aG91Z2ggXCJcIiBtYXRjaGVzIGFnYWluc3QgdGhlXG4gICAgICAgIC8vIFteL10qPyBwYXR0ZXJuLCBleGNlcHQgaW4gcGFydGlhbCBtb2RlLCB3aGVyZSBpdCBtaWdodFxuICAgICAgICAvLyBzaW1wbHkgbm90IGJlIHJlYWNoZWQgeWV0LlxuICAgICAgICAvLyBIb3dldmVyLCBhL2IvIHNob3VsZCBzdGlsbCBzYXRpc2Z5IGEvKlxuICAgICAgICAvLyBub3cgZWl0aGVyIHdlIGZlbGwgb2ZmIHRoZSBlbmQgb2YgdGhlIHBhdHRlcm4sIG9yIHdlJ3JlIGRvbmUuXG4gICAgICAgIGlmIChmaSA9PT0gZmwgJiYgcGkgPT09IHBsKSB7XG4gICAgICAgICAgICAvLyByYW4gb3V0IG9mIHBhdHRlcm4gYW5kIGZpbGVuYW1lIGF0IHRoZSBzYW1lIHRpbWUuXG4gICAgICAgICAgICAvLyBhbiBleGFjdCBoaXQhXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChmaSA9PT0gZmwpIHtcbiAgICAgICAgICAgIC8vIHJhbiBvdXQgb2YgZmlsZSwgYnV0IHN0aWxsIGhhZCBwYXR0ZXJuIGxlZnQuXG4gICAgICAgICAgICAvLyB0aGlzIGlzIG9rIGlmIHdlJ3JlIGRvaW5nIHRoZSBtYXRjaCBhcyBwYXJ0IG9mXG4gICAgICAgICAgICAvLyBhIGdsb2IgZnMgdHJhdmVyc2FsLlxuICAgICAgICAgICAgcmV0dXJuIHBhcnRpYWw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocGkgPT09IHBsKSB7XG4gICAgICAgICAgICAvLyByYW4gb3V0IG9mIHBhdHRlcm4sIHN0aWxsIGhhdmUgZmlsZSBsZWZ0LlxuICAgICAgICAgICAgLy8gdGhpcyBpcyBvbmx5IGFjY2VwdGFibGUgaWYgd2UncmUgb24gdGhlIHZlcnkgbGFzdFxuICAgICAgICAgICAgLy8gZW1wdHkgc2VnbWVudCBvZiBhIGZpbGUgd2l0aCBhIHRyYWlsaW5nIHNsYXNoLlxuICAgICAgICAgICAgLy8gYS8qIHNob3VsZCBtYXRjaCBhL2IvXG4gICAgICAgICAgICByZXR1cm4gZmkgPT09IGZsIC0gMSAmJiBmaWxlW2ZpXSA9PT0gJyc7XG4gICAgICAgICAgICAvKiBjOCBpZ25vcmUgc3RhcnQgKi9cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIHNob3VsZCBiZSB1bnJlYWNoYWJsZS5cbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignd3RmPycpO1xuICAgICAgICB9XG4gICAgICAgIC8qIGM4IGlnbm9yZSBzdG9wICovXG4gICAgfVxuICAgIGJyYWNlRXhwYW5kKCkge1xuICAgICAgICByZXR1cm4gKDAsIGV4cG9ydHMuYnJhY2VFeHBhbmQpKHRoaXMucGF0dGVybiwgdGhpcy5vcHRpb25zKTtcbiAgICB9XG4gICAgcGFyc2UocGF0dGVybikge1xuICAgICAgICAoMCwgYXNzZXJ0X3ZhbGlkX3BhdHRlcm5fanNfMS5hc3NlcnRWYWxpZFBhdHRlcm4pKHBhdHRlcm4pO1xuICAgICAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgICAgICAvLyBzaG9ydGN1dHNcbiAgICAgICAgaWYgKHBhdHRlcm4gPT09ICcqKicpXG4gICAgICAgICAgICByZXR1cm4gZXhwb3J0cy5HTE9CU1RBUjtcbiAgICAgICAgaWYgKHBhdHRlcm4gPT09ICcnKVxuICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICAvLyBmYXIgYW5kIGF3YXksIHRoZSBtb3N0IGNvbW1vbiBnbG9iIHBhdHRlcm4gcGFydHMgYXJlXG4gICAgICAgIC8vICosICouKiwgYW5kICouPGV4dD4gIEFkZCBhIGZhc3QgY2hlY2sgbWV0aG9kIGZvciB0aG9zZS5cbiAgICAgICAgbGV0IG07XG4gICAgICAgIGxldCBmYXN0VGVzdCA9IG51bGw7XG4gICAgICAgIGlmICgobSA9IHBhdHRlcm4ubWF0Y2goc3RhclJFKSkpIHtcbiAgICAgICAgICAgIGZhc3RUZXN0ID0gb3B0aW9ucy5kb3QgPyBzdGFyVGVzdERvdCA6IHN0YXJUZXN0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKChtID0gcGF0dGVybi5tYXRjaChzdGFyRG90RXh0UkUpKSkge1xuICAgICAgICAgICAgZmFzdFRlc3QgPSAob3B0aW9ucy5ub2Nhc2VcbiAgICAgICAgICAgICAgICA/IG9wdGlvbnMuZG90XG4gICAgICAgICAgICAgICAgICAgID8gc3RhckRvdEV4dFRlc3ROb2Nhc2VEb3RcbiAgICAgICAgICAgICAgICAgICAgOiBzdGFyRG90RXh0VGVzdE5vY2FzZVxuICAgICAgICAgICAgICAgIDogb3B0aW9ucy5kb3RcbiAgICAgICAgICAgICAgICAgICAgPyBzdGFyRG90RXh0VGVzdERvdFxuICAgICAgICAgICAgICAgICAgICA6IHN0YXJEb3RFeHRUZXN0KShtWzFdKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgobSA9IHBhdHRlcm4ubWF0Y2gocW1hcmtzUkUpKSkge1xuICAgICAgICAgICAgZmFzdFRlc3QgPSAob3B0aW9ucy5ub2Nhc2VcbiAgICAgICAgICAgICAgICA/IG9wdGlvbnMuZG90XG4gICAgICAgICAgICAgICAgICAgID8gcW1hcmtzVGVzdE5vY2FzZURvdFxuICAgICAgICAgICAgICAgICAgICA6IHFtYXJrc1Rlc3ROb2Nhc2VcbiAgICAgICAgICAgICAgICA6IG9wdGlvbnMuZG90XG4gICAgICAgICAgICAgICAgICAgID8gcW1hcmtzVGVzdERvdFxuICAgICAgICAgICAgICAgICAgICA6IHFtYXJrc1Rlc3QpKG0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKChtID0gcGF0dGVybi5tYXRjaChzdGFyRG90U3RhclJFKSkpIHtcbiAgICAgICAgICAgIGZhc3RUZXN0ID0gb3B0aW9ucy5kb3QgPyBzdGFyRG90U3RhclRlc3REb3QgOiBzdGFyRG90U3RhclRlc3Q7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoKG0gPSBwYXR0ZXJuLm1hdGNoKGRvdFN0YXJSRSkpKSB7XG4gICAgICAgICAgICBmYXN0VGVzdCA9IGRvdFN0YXJUZXN0O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlID0gYXN0X2pzXzEuQVNULmZyb21HbG9iKHBhdHRlcm4sIHRoaXMub3B0aW9ucykudG9NTVBhdHRlcm4oKTtcbiAgICAgICAgaWYgKGZhc3RUZXN0ICYmIHR5cGVvZiByZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIC8vIEF2b2lkcyBvdmVycmlkaW5nIGluIGZyb3plbiBlbnZpcm9ubWVudHNcbiAgICAgICAgICAgIFJlZmxlY3QuZGVmaW5lUHJvcGVydHkocmUsICd0ZXN0JywgeyB2YWx1ZTogZmFzdFRlc3QgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlO1xuICAgIH1cbiAgICBtYWtlUmUoKSB7XG4gICAgICAgIGlmICh0aGlzLnJlZ2V4cCB8fCB0aGlzLnJlZ2V4cCA9PT0gZmFsc2UpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZWdleHA7XG4gICAgICAgIC8vIGF0IHRoaXMgcG9pbnQsIHRoaXMuc2V0IGlzIGEgMmQgYXJyYXkgb2YgcGFydGlhbFxuICAgICAgICAvLyBwYXR0ZXJuIHN0cmluZ3MsIG9yIFwiKipcIi5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gSXQncyBiZXR0ZXIgdG8gdXNlIC5tYXRjaCgpLiAgVGhpcyBmdW5jdGlvbiBzaG91bGRuJ3RcbiAgICAgICAgLy8gYmUgdXNlZCwgcmVhbGx5LCBidXQgaXQncyBwcmV0dHkgY29udmVuaWVudCBzb21ldGltZXMsXG4gICAgICAgIC8vIHdoZW4geW91IGp1c3Qgd2FudCB0byB3b3JrIHdpdGggYSByZWdleC5cbiAgICAgICAgY29uc3Qgc2V0ID0gdGhpcy5zZXQ7XG4gICAgICAgIGlmICghc2V0Lmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5yZWdleHAgPSBmYWxzZTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlZ2V4cDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgICAgICBjb25zdCB0d29TdGFyID0gb3B0aW9ucy5ub2dsb2JzdGFyXG4gICAgICAgICAgICA/IHN0YXJcbiAgICAgICAgICAgIDogb3B0aW9ucy5kb3RcbiAgICAgICAgICAgICAgICA/IHR3b1N0YXJEb3RcbiAgICAgICAgICAgICAgICA6IHR3b1N0YXJOb0RvdDtcbiAgICAgICAgY29uc3QgZmxhZ3MgPSBuZXcgU2V0KG9wdGlvbnMubm9jYXNlID8gWydpJ10gOiBbXSk7XG4gICAgICAgIC8vIHJlZ2V4cGlmeSBub24tZ2xvYnN0YXIgcGF0dGVybnNcbiAgICAgICAgLy8gaWYgKiogaXMgb25seSBpdGVtLCB0aGVuIHdlIGp1c3QgZG8gb25lIHR3b1N0YXJcbiAgICAgICAgLy8gaWYgKiogaXMgZmlyc3QsIGFuZCB0aGVyZSBhcmUgbW9yZSwgcHJlcGVuZCAoXFwvfHR3b1N0YXJcXC8pPyB0byBuZXh0XG4gICAgICAgIC8vIGlmICoqIGlzIGxhc3QsIGFwcGVuZCAoXFwvdHdvU3RhcnwpIHRvIHByZXZpb3VzXG4gICAgICAgIC8vIGlmICoqIGlzIGluIHRoZSBtaWRkbGUsIGFwcGVuZCAoXFwvfFxcL3R3b1N0YXJcXC8pIHRvIHByZXZpb3VzXG4gICAgICAgIC8vIHRoZW4gZmlsdGVyIG91dCBHTE9CU1RBUiBzeW1ib2xzXG4gICAgICAgIGxldCByZSA9IHNldFxuICAgICAgICAgICAgLm1hcChwYXR0ZXJuID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHBwID0gcGF0dGVybi5tYXAocCA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHAgaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBmIG9mIHAuZmxhZ3Muc3BsaXQoJycpKVxuICAgICAgICAgICAgICAgICAgICAgICAgZmxhZ3MuYWRkKGYpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZW9mIHAgPT09ICdzdHJpbmcnXG4gICAgICAgICAgICAgICAgICAgID8gcmVnRXhwRXNjYXBlKHApXG4gICAgICAgICAgICAgICAgICAgIDogcCA9PT0gZXhwb3J0cy5HTE9CU1RBUlxuICAgICAgICAgICAgICAgICAgICAgICAgPyBleHBvcnRzLkdMT0JTVEFSXG4gICAgICAgICAgICAgICAgICAgICAgICA6IHAuX3NyYztcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcHAuZm9yRWFjaCgocCwgaSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IG5leHQgPSBwcFtpICsgMV07XG4gICAgICAgICAgICAgICAgY29uc3QgcHJldiA9IHBwW2kgLSAxXTtcbiAgICAgICAgICAgICAgICBpZiAocCAhPT0gZXhwb3J0cy5HTE9CU1RBUiB8fCBwcmV2ID09PSBleHBvcnRzLkdMT0JTVEFSKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHByZXYgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAobmV4dCAhPT0gdW5kZWZpbmVkICYmIG5leHQgIT09IGV4cG9ydHMuR0xPQlNUQVIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBwW2kgKyAxXSA9ICcoPzpcXFxcL3wnICsgdHdvU3RhciArICdcXFxcLyk/JyArIG5leHQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcFtpXSA9IHR3b1N0YXI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAobmV4dCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHBwW2kgLSAxXSA9IHByZXYgKyAnKD86XFxcXC98JyArIHR3b1N0YXIgKyAnKT8nO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChuZXh0ICE9PSBleHBvcnRzLkdMT0JTVEFSKSB7XG4gICAgICAgICAgICAgICAgICAgIHBwW2kgLSAxXSA9IHByZXYgKyAnKD86XFxcXC98XFxcXC8nICsgdHdvU3RhciArICdcXFxcLyknICsgbmV4dDtcbiAgICAgICAgICAgICAgICAgICAgcHBbaSArIDFdID0gZXhwb3J0cy5HTE9CU1RBUjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBwcC5maWx0ZXIocCA9PiBwICE9PSBleHBvcnRzLkdMT0JTVEFSKS5qb2luKCcvJyk7XG4gICAgICAgIH0pXG4gICAgICAgICAgICAuam9pbignfCcpO1xuICAgICAgICAvLyBuZWVkIHRvIHdyYXAgaW4gcGFyZW5zIGlmIHdlIGhhZCBtb3JlIHRoYW4gb25lIHRoaW5nIHdpdGggfCxcbiAgICAgICAgLy8gb3RoZXJ3aXNlIG9ubHkgdGhlIGZpcnN0IHdpbGwgYmUgYW5jaG9yZWQgdG8gXiBhbmQgdGhlIGxhc3QgdG8gJFxuICAgICAgICBjb25zdCBbb3BlbiwgY2xvc2VdID0gc2V0Lmxlbmd0aCA+IDEgPyBbJyg/OicsICcpJ10gOiBbJycsICcnXTtcbiAgICAgICAgLy8gbXVzdCBtYXRjaCBlbnRpcmUgcGF0dGVyblxuICAgICAgICAvLyBlbmRpbmcgaW4gYSAqIG9yICoqIHdpbGwgbWFrZSBpdCBsZXNzIHN0cmljdC5cbiAgICAgICAgcmUgPSAnXicgKyBvcGVuICsgcmUgKyBjbG9zZSArICckJztcbiAgICAgICAgLy8gY2FuIG1hdGNoIGFueXRoaW5nLCBhcyBsb25nIGFzIGl0J3Mgbm90IHRoaXMuXG4gICAgICAgIGlmICh0aGlzLm5lZ2F0ZSlcbiAgICAgICAgICAgIHJlID0gJ14oPyEnICsgcmUgKyAnKS4rJCc7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLnJlZ2V4cCA9IG5ldyBSZWdFeHAocmUsIFsuLi5mbGFnc10uam9pbignJykpO1xuICAgICAgICAgICAgLyogYzggaWdub3JlIHN0YXJ0ICovXG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgICAvLyBzaG91bGQgYmUgaW1wb3NzaWJsZVxuICAgICAgICAgICAgdGhpcy5yZWdleHAgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvKiBjOCBpZ25vcmUgc3RvcCAqL1xuICAgICAgICByZXR1cm4gdGhpcy5yZWdleHA7XG4gICAgfVxuICAgIHNsYXNoU3BsaXQocCkge1xuICAgICAgICAvLyBpZiBwIHN0YXJ0cyB3aXRoIC8vIG9uIHdpbmRvd3MsIHdlIHByZXNlcnZlIHRoYXRcbiAgICAgICAgLy8gc28gdGhhdCBVTkMgcGF0aHMgYXJlbid0IGJyb2tlbi4gIE90aGVyd2lzZSwgYW55IG51bWJlciBvZlxuICAgICAgICAvLyAvIGNoYXJhY3RlcnMgYXJlIGNvYWxlc2NlZCBpbnRvIG9uZSwgdW5sZXNzXG4gICAgICAgIC8vIHByZXNlcnZlTXVsdGlwbGVTbGFzaGVzIGlzIHNldCB0byB0cnVlLlxuICAgICAgICBpZiAodGhpcy5wcmVzZXJ2ZU11bHRpcGxlU2xhc2hlcykge1xuICAgICAgICAgICAgcmV0dXJuIHAuc3BsaXQoJy8nKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLmlzV2luZG93cyAmJiAvXlxcL1xcL1teXFwvXSsvLnRlc3QocCkpIHtcbiAgICAgICAgICAgIC8vIGFkZCBhbiBleHRyYSAnJyBmb3IgdGhlIG9uZSB3ZSBsb3NlXG4gICAgICAgICAgICByZXR1cm4gWycnLCAuLi5wLnNwbGl0KC9cXC8rLyldO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHAuc3BsaXQoL1xcLysvKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBtYXRjaChmLCBwYXJ0aWFsID0gdGhpcy5wYXJ0aWFsKSB7XG4gICAgICAgIHRoaXMuZGVidWcoJ21hdGNoJywgZiwgdGhpcy5wYXR0ZXJuKTtcbiAgICAgICAgLy8gc2hvcnQtY2lyY3VpdCBpbiB0aGUgY2FzZSBvZiBidXN0ZWQgdGhpbmdzLlxuICAgICAgICAvLyBjb21tZW50cywgZXRjLlxuICAgICAgICBpZiAodGhpcy5jb21tZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZW1wdHkpIHtcbiAgICAgICAgICAgIHJldHVybiBmID09PSAnJztcbiAgICAgICAgfVxuICAgICAgICBpZiAoZiA9PT0gJy8nICYmIHBhcnRpYWwpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgICAgIC8vIHdpbmRvd3M6IG5lZWQgdG8gdXNlIC8sIG5vdCBcXFxuICAgICAgICBpZiAodGhpcy5pc1dpbmRvd3MpIHtcbiAgICAgICAgICAgIGYgPSBmLnNwbGl0KCdcXFxcJykuam9pbignLycpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHRyZWF0IHRoZSB0ZXN0IHBhdGggYXMgYSBzZXQgb2YgcGF0aHBhcnRzLlxuICAgICAgICBjb25zdCBmZiA9IHRoaXMuc2xhc2hTcGxpdChmKTtcbiAgICAgICAgdGhpcy5kZWJ1Zyh0aGlzLnBhdHRlcm4sICdzcGxpdCcsIGZmKTtcbiAgICAgICAgLy8ganVzdCBPTkUgb2YgdGhlIHBhdHRlcm4gc2V0cyBpbiB0aGlzLnNldCBuZWVkcyB0byBtYXRjaFxuICAgICAgICAvLyBpbiBvcmRlciBmb3IgaXQgdG8gYmUgdmFsaWQuICBJZiBuZWdhdGluZywgdGhlbiBqdXN0IG9uZVxuICAgICAgICAvLyBtYXRjaCBtZWFucyB0aGF0IHdlIGhhdmUgZmFpbGVkLlxuICAgICAgICAvLyBFaXRoZXIgd2F5LCByZXR1cm4gb24gdGhlIGZpcnN0IGhpdC5cbiAgICAgICAgY29uc3Qgc2V0ID0gdGhpcy5zZXQ7XG4gICAgICAgIHRoaXMuZGVidWcodGhpcy5wYXR0ZXJuLCAnc2V0Jywgc2V0KTtcbiAgICAgICAgLy8gRmluZCB0aGUgYmFzZW5hbWUgb2YgdGhlIHBhdGggYnkgbG9va2luZyBmb3IgdGhlIGxhc3Qgbm9uLWVtcHR5IHNlZ21lbnRcbiAgICAgICAgbGV0IGZpbGVuYW1lID0gZmZbZmYubGVuZ3RoIC0gMV07XG4gICAgICAgIGlmICghZmlsZW5hbWUpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSBmZi5sZW5ndGggLSAyOyAhZmlsZW5hbWUgJiYgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgICAgICBmaWxlbmFtZSA9IGZmW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2V0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBwYXR0ZXJuID0gc2V0W2ldO1xuICAgICAgICAgICAgbGV0IGZpbGUgPSBmZjtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLm1hdGNoQmFzZSAmJiBwYXR0ZXJuLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICAgIGZpbGUgPSBbZmlsZW5hbWVdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgaGl0ID0gdGhpcy5tYXRjaE9uZShmaWxlLCBwYXR0ZXJuLCBwYXJ0aWFsKTtcbiAgICAgICAgICAgIGlmIChoaXQpIHtcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5mbGlwTmVnYXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gIXRoaXMubmVnYXRlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGRpZG4ndCBnZXQgYW55IGhpdHMuICB0aGlzIGlzIHN1Y2Nlc3MgaWYgaXQncyBhIG5lZ2F0aXZlXG4gICAgICAgIC8vIHBhdHRlcm4sIGZhaWx1cmUgb3RoZXJ3aXNlLlxuICAgICAgICBpZiAob3B0aW9ucy5mbGlwTmVnYXRlKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMubmVnYXRlO1xuICAgIH1cbiAgICBzdGF0aWMgZGVmYXVsdHMoZGVmKSB7XG4gICAgICAgIHJldHVybiBleHBvcnRzLm1pbmltYXRjaC5kZWZhdWx0cyhkZWYpLk1pbmltYXRjaDtcbiAgICB9XG59XG5leHBvcnRzLk1pbmltYXRjaCA9IE1pbmltYXRjaDtcbi8qIGM4IGlnbm9yZSBzdGFydCAqL1xudmFyIGFzdF9qc18yID0gcmVxdWlyZShcIi4vYXN0LmpzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQVNUXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBhc3RfanNfMi5BU1Q7IH0gfSk7XG52YXIgZXNjYXBlX2pzXzIgPSByZXF1aXJlKFwiLi9lc2NhcGUuanNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJlc2NhcGVcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGVzY2FwZV9qc18yLmVzY2FwZTsgfSB9KTtcbnZhciB1bmVzY2FwZV9qc18yID0gcmVxdWlyZShcIi4vdW5lc2NhcGUuanNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJ1bmVzY2FwZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdW5lc2NhcGVfanNfMi51bmVzY2FwZTsgfSB9KTtcbi8qIGM4IGlnbm9yZSBzdG9wICovXG5leHBvcnRzLm1pbmltYXRjaC5BU1QgPSBhc3RfanNfMS5BU1Q7XG5leHBvcnRzLm1pbmltYXRjaC5NaW5pbWF0Y2ggPSBNaW5pbWF0Y2g7XG5leHBvcnRzLm1pbmltYXRjaC5lc2NhcGUgPSBlc2NhcGVfanNfMS5lc2NhcGU7XG5leHBvcnRzLm1pbmltYXRjaC51bmVzY2FwZSA9IHVuZXNjYXBlX2pzXzEudW5lc2NhcGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/minimatch/dist/commonjs/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/minimatch/dist/commonjs/unescape.js":
/*!**********************************************************!*\
  !*** ./node_modules/minimatch/dist/commonjs/unescape.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.unescape = void 0;\n/**\n * Un-escape a string that has been escaped with {@link escape}.\n *\n * If the {@link windowsPathsNoEscape} option is used, then square-brace\n * escapes are removed, but not backslash escapes.  For example, it will turn\n * the string `'[*]'` into `*`, but it will not turn `'\\\\*'` into `'*'`,\n * becuase `\\` is a path separator in `windowsPathsNoEscape` mode.\n *\n * When `windowsPathsNoEscape` is not set, then both brace escapes and\n * backslash escapes are removed.\n *\n * Slashes (and backslashes in `windowsPathsNoEscape` mode) cannot be escaped\n * or unescaped.\n */\nconst unescape = (s, { windowsPathsNoEscape = false, } = {}) => {\n    return windowsPathsNoEscape\n        ? s.replace(/\\[([^\\/\\\\])\\]/g, '$1')\n        : s.replace(/((?!\\\\).|^)\\[([^\\/\\\\])\\]/g, '$1$2').replace(/\\\\([^\\/])/g, '$1');\n};\nexports.unescape = unescape;\n//# sourceMappingURL=unescape.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbWluaW1hdGNoL2Rpc3QvY29tbW9uanMvdW5lc2NhcGUuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsZ0JBQWdCO0FBQ2hCO0FBQ0Esa0RBQWtELGFBQWE7QUFDL0Q7QUFDQSxXQUFXLDRCQUE0QjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixnQ0FBZ0MsSUFBSTtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQiIsInNvdXJjZXMiOlsid2VicGFjazovL2F1dG8tbG9vcC1kZW1vLy4vbm9kZV9tb2R1bGVzL21pbmltYXRjaC9kaXN0L2NvbW1vbmpzL3VuZXNjYXBlLmpzP2M4MDQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnVuZXNjYXBlID0gdm9pZCAwO1xuLyoqXG4gKiBVbi1lc2NhcGUgYSBzdHJpbmcgdGhhdCBoYXMgYmVlbiBlc2NhcGVkIHdpdGgge0BsaW5rIGVzY2FwZX0uXG4gKlxuICogSWYgdGhlIHtAbGluayB3aW5kb3dzUGF0aHNOb0VzY2FwZX0gb3B0aW9uIGlzIHVzZWQsIHRoZW4gc3F1YXJlLWJyYWNlXG4gKiBlc2NhcGVzIGFyZSByZW1vdmVkLCBidXQgbm90IGJhY2tzbGFzaCBlc2NhcGVzLiAgRm9yIGV4YW1wbGUsIGl0IHdpbGwgdHVyblxuICogdGhlIHN0cmluZyBgJ1sqXSdgIGludG8gYCpgLCBidXQgaXQgd2lsbCBub3QgdHVybiBgJ1xcXFwqJ2AgaW50byBgJyonYCxcbiAqIGJlY3Vhc2UgYFxcYCBpcyBhIHBhdGggc2VwYXJhdG9yIGluIGB3aW5kb3dzUGF0aHNOb0VzY2FwZWAgbW9kZS5cbiAqXG4gKiBXaGVuIGB3aW5kb3dzUGF0aHNOb0VzY2FwZWAgaXMgbm90IHNldCwgdGhlbiBib3RoIGJyYWNlIGVzY2FwZXMgYW5kXG4gKiBiYWNrc2xhc2ggZXNjYXBlcyBhcmUgcmVtb3ZlZC5cbiAqXG4gKiBTbGFzaGVzIChhbmQgYmFja3NsYXNoZXMgaW4gYHdpbmRvd3NQYXRoc05vRXNjYXBlYCBtb2RlKSBjYW5ub3QgYmUgZXNjYXBlZFxuICogb3IgdW5lc2NhcGVkLlxuICovXG5jb25zdCB1bmVzY2FwZSA9IChzLCB7IHdpbmRvd3NQYXRoc05vRXNjYXBlID0gZmFsc2UsIH0gPSB7fSkgPT4ge1xuICAgIHJldHVybiB3aW5kb3dzUGF0aHNOb0VzY2FwZVxuICAgICAgICA/IHMucmVwbGFjZSgvXFxbKFteXFwvXFxcXF0pXFxdL2csICckMScpXG4gICAgICAgIDogcy5yZXBsYWNlKC8oKD8hXFxcXCkufF4pXFxbKFteXFwvXFxcXF0pXFxdL2csICckMSQyJykucmVwbGFjZSgvXFxcXChbXlxcL10pL2csICckMScpO1xufTtcbmV4cG9ydHMudW5lc2NhcGUgPSB1bmVzY2FwZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXVuZXNjYXBlLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/minimatch/dist/commonjs/unescape.js\n");

/***/ })

};
;